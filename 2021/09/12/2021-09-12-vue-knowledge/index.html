<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <script src="/js/av-min.js"></script>

  <script>
    AV.init({
      appId: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      appKey: 'fstd3ABXC89jc5VDSe6ANGV6',
      serverURLs: {
        push: "https://leancloud.cn",
        stats: "https://leancloud.cn",
        engine: "https://leancloud.cn",
        api: "https://leancloud.cn",
      },
    });
  </script>
  <script async src="/main/js/slider.66b399.js"></script><script async src="/main/js/main.a76a5f.js"></script><script async src="/main/js/mobile.57dfe3.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GWM1JLMFWH"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GWM1JLMFWH")</script>

  <link rel="dns-prefetch" href="https://luckyship.github.io">
  <title>Vue你了解哪些 | luckyship</title>
  <meta name="generator" content="hexo-theme-luckyship">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="一、vuevue 优点 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb；  简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；  双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；  组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；  视图，数据，结构分离：使数据的更改更为简单，不需要">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue你了解哪些">
<meta property="og:url" content="https://luckyship.github.io/2021/09/12/2021-09-12-vue-knowledge/index.html">
<meta property="og:site_name" content="luckyship">
<meta property="og:description" content="一、vuevue 优点 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb；  简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；  双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；  组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；  视图，数据，结构分离：使数据的更改更为简单，不需要">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/001.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/006.png">
<meta property="og:image" content="https://cn.vuejs.org/images/transition.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/008.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/009.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/010.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/011.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/012.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/013.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/014.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/007.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/019.jpg">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/016.jpg">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/017.jpg">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/018.jpg">
<meta property="article:published_time" content="2021-09-12T08:26:18.000Z">
<meta property="article:modified_time" content="2025-08-02T05:46:04.178Z">
<meta property="article:author" content="luckyship">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luckyship.github.io/img/vue-interview/001.png">
  
    <link rel="alternative" href="/atom.xml" title="luckyship" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/main/css/index.a76a5f.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script async src="/lib/clickLove.js"></script>
  
  

<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();

</script>



  

</head>


<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #4d4d4d;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/head.jpg" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">luckyship</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" >主页</a></li>
			
				<li><a href="/archives" >归档</a></li>
			
				<li><a href="/comment/" >留言板</a></li>
			
				<li><a href="/website/" >知识库</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">搜索</a>
				
			
				
					<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
				
			
            </nav>

		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" rel="noopener" href="https://github.com/luckyship" title="GitHub" ><i class="icon-github"></i></a>
				
					<a class="gitee" target="_blank" rel="noopener" href="https://gitee.com/luckyship" title="gitee" ><i class="icon-gitee"></i></a>
				
					<a class="blog" target="_blank" rel="noopener" href="https://juejin.cn/user/730534951787662/posts" title="blog" ><i class="icon-blog"></i></a>
				
					<a class="csdn" target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38319625" title="CSDN" ><i class="icon-csdn"></i></a>
				
			</div>
		
		</nav>

		
		  <nav>
			
  <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81vue"><span class="toc-number">1.</span> <span class="toc-text">一、vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">vue 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E5%AF%B9-vue-%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">谈谈对 vue 渐进式的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-MVVM%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">什么是 MVVM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM-%E5%92%8C-MVC-%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%92%8C%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6-jquery-%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%82%A3%E4%BA%9B%E5%9C%BA%E6%99%AF%E9%80%82%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">MVVM 和 MVC 区别？和其他框架(jquery)区别？那些场景适用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-show-%E5%92%8C-v-if-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9%E5%92%8C%E4%B8%8D%E5%90%8C%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">v-show 和 v-if 指令的共同点和不同点?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD-key-%E5%80%BC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">vue 中 key 值的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">如何在组件内部实现一个双向数据绑定？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.</span> <span class="toc-text">常用指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-%E5%92%8C-method-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">computed 和 method 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vue-%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">1.10.</span> <span class="toc-text">什么是 vue 的单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E9%87%8C%E9%9D%A2%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E6%A0%B7%E5%BC%8F"><span class="toc-number">1.11.</span> <span class="toc-text">vue 里面如何操作样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-if-%E5%92%8C-v-for-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%B8%80%E8%B5%B7%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">v-if 和 v-for 为什么不推荐一起用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.</span> <span class="toc-text">数组更新检测有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E8%8E%B7%E5%8F%96%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.14.</span> <span class="toc-text">如果获取事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="toc-number">1.15.</span> <span class="toc-text">哪些常见事件修饰符，有何作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.16.</span> <span class="toc-text">有哪些常见按键修饰符，以及如何定义按键修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA-v-model-%E6%8C%87%E4%BB%A4"><span class="toc-number">1.17.</span> <span class="toc-text">如何实现一个 v-model 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E6%8E%A7%E4%BB%B6%E7%BB%91%E5%AE%9A%E9%9C%80%E8%A6%81%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">表单控件绑定需要什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E5%8D%95%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">1.19.</span> <span class="toc-text">有哪些常见的表单修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%BB%84%E4%BB%B6"><span class="toc-number">1.20.</span> <span class="toc-text">如何定义一个组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E5%95%A5%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0"><span class="toc-number">1.21.</span> <span class="toc-text">组件 data 为啥是一个函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84-props-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89"><span class="toc-number">1.22.</span> <span class="toc-text">组件的 props 是什么？如何定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model"><span class="toc-number">1.23.</span> <span class="toc-text">如何自定义组件的 v-model</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#native%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E4%BD%95%E7%94%A8"><span class="toc-number">1.24.</span> <span class="toc-text">.native修饰符有何用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sync%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="toc-number">1.25.</span> <span class="toc-text">.sync修饰符有何作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.26.</span> <span class="toc-text">插槽是什么？ 有哪些分类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD"><span class="toc-number">1.27.</span> <span class="toc-text">写一个具名插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD%E5%A6%82%E4%BD%95%E5%86%99"><span class="toc-number">1.28.</span> <span class="toc-text">作用域插槽如何写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">1.29.</span> <span class="toc-text">如何实现动态组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6"><span class="toc-number">1.30.</span> <span class="toc-text">如何实现缓存组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%BB%84%E4%BB%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.31.</span> <span class="toc-text">缓存组件要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6"><span class="toc-number">1.32.</span> <span class="toc-text">如何定义一个递归组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%A6%82%E4%BD%95%E5%BC%BA%E5%88%B6%E5%88%B7%E6%96%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">1.33.</span> <span class="toc-text">vue 如何强制刷新组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BD%BF%E7%94%A8-vue-%E5%8A%A8%E7%94%BB"><span class="toc-number">1.34.</span> <span class="toc-text">什么时候使用 vue 动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%8A%A8%E7%94%BB%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%90%8D"><span class="toc-number">1.35.</span> <span class="toc-text">vue 动画有哪些类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E6%B8%A1%E7%B1%BB%E5%90%8D"><span class="toc-number">1.36.</span> <span class="toc-text">有哪些自定义过渡类名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD-mixins-%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8"><span class="toc-number">1.37.</span> <span class="toc-text">vue 中 mixins 配置选项是什么？有何作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mixin-%E6%B7%B7%E5%85%A5%E5%AF%B9%E8%B1%A1%E5%92%8C-Vuex-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.37.1.</span> <span class="toc-text">mixin 混入对象和 Vuex 的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4"><span class="toc-number">1.38.</span> <span class="toc-text">如何实现一个自定义指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%92%A9%E5%AD%90"><span class="toc-number">1.39.</span> <span class="toc-text">自定义指令有何作用？ 有哪些钩子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.40.</span> <span class="toc-text">过滤器是什么？如何定义？如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-use-%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.41.</span> <span class="toc-text">Vue.use 是什么? 如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-loader-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.42.</span> <span class="toc-text">vue-loader 是什么？使用它的用途有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E8%81%8A%E4%BD%A0%E5%AF%B9-Vue-js-%E7%9A%84-template-%E7%BC%96%E8%AF%91%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">1.43.</span> <span class="toc-text">聊聊你对 Vue.js 的 template 编译的理解？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">1.44.</span> <span class="toc-text">什么是 vue 生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.45.</span> <span class="toc-text">vue 生命周期的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%80%BB%E5%85%B1%E6%9C%89%E5%87%A0%E4%B8%AA%E9%98%B6%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.46.</span> <span class="toc-text">vue 生命周期总共有几个阶段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E4%BC%9A%E8%A7%A6%E5%8F%91%E5%93%AA%E5%87%A0%E4%B8%AA%E9%92%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">1.47.</span> <span class="toc-text">第一次页面加载会触发哪几个钩子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM-%E6%B8%B2%E6%9F%93%E5%9C%A8-%E5%93%AA%E4%B8%AA%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%B0%B1%E5%B7%B2%E7%BB%8F%E5%AE%8C%E6%88%90%EF%BC%9F"><span class="toc-number">1.48.</span> <span class="toc-text">DOM 渲染在 哪个周期中就已经完成？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E6%AF%8F%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%85%B7%E4%BD%93%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.49.</span> <span class="toc-text">简单描述每个周期具体适合哪些场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%BB%84%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">1.50.</span> <span class="toc-text">vue 组件如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E5%87%BA-mount%E3%80%81-watch%E3%80%81-delete%E3%80%81-refs%E3%80%81-slots%E3%80%81-forceUpdate%E3%80%81-nextTick%E3%80%81-destroy-%E8%BF%99%E4%BA%9B-API-%E6%96%B9%E6%B3%95%E6%88%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.51.</span> <span class="toc-text">说出$mount、$watch、$delete、$refs、$slots、$forceUpdate、$nextTick、$destroy 这些 API 方法或属性的的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#is-%E7%9A%84%E7%94%A8%E6%B3%95%EF%BC%88%E7%94%A8%E4%BA%8E%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%94%E5%9F%BA%E4%BA%8E-DOM-%E5%86%85%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%99%90%E5%88%B6%E6%9D%A5%E5%B7%A5%E4%BD%9C%E3%80%82%EF%BC%89"><span class="toc-number">1.52.</span> <span class="toc-text">is 的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%A0%B8%E5%BF%83%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.53.</span> <span class="toc-text">vue 的两个核心是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%9A%84-render-%E5%87%BD%E6%95%B0%E5%BC%8F%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">1.54.</span> <span class="toc-text">vue 的 render 函数式什么？如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-key-%E8%A6%81%E4%BB%80%E4%B9%88%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">1.55.</span> <span class="toc-text">使用 key 要什么要注意的吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84-name-%E9%80%89%E9%A1%B9%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.56.</span> <span class="toc-text">组件的 name 选项有什么作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%92%E5%BD%92%E7%BB%84%E4%BB%B6%EF%BC%9F%E4%B8%BE%E4%B8%AA%E4%BE%8B%E5%AD%90%E8%AF%B4%E6%98%8E%E4%B8%8B%EF%BC%9F"><span class="toc-number">1.57.</span> <span class="toc-text">什么是递归组件？举个例子说明下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B-attrs%E5%92%8C-listeners%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">1.58.</span> <span class="toc-text">说下$attrs和$listeners的使用场景？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventBus-%E6%B3%A8%E5%86%8C%E5%9C%A8%E5%85%A8%E5%B1%80%E4%B8%8A%E6%97%B6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%88%87%E6%8D%A2%E6%97%B6%E4%BC%9A%E9%87%8D%E5%A4%8D%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%91%A2%EF%BC%9F"><span class="toc-number">1.59.</span> <span class="toc-text">EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E6%80%8E%E4%B9%88%E6%94%B9%E5%8F%98%E6%8F%92%E5%85%A5%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%88%86%E9%9A%94%E7%AC%A6%EF%BC%9F"><span class="toc-number">1.60.</span> <span class="toc-text">Vue 怎么改变插入模板的分隔符？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E5%8F%98%E9%87%8F%E5%90%8D%E5%A6%82%E6%9E%9C%E4%BB%A5-%E3%80%81-%E5%BC%80%E5%A4%B4%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%88%B0%E5%AE%83%E4%BB%AC%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-number">1.61.</span> <span class="toc-text">Vue 变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E6%8D%95%E8%8E%B7-Vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF%EF%BC%9F"><span class="toc-number">1.62.</span> <span class="toc-text">怎么捕获 Vue 组件的错误信息？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-favicon%EF%BC%9F"><span class="toc-number">1.63.</span> <span class="toc-text">Vue 项目中如何配置 favicon？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF%E5%8F%AA%E8%83%BD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E5%85%83%E7%B4%A0%EF%BC%9F"><span class="toc-number">1.64.</span> <span class="toc-text">Vue 为什么要求组件模板只能有一个根元素？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.65.</span> <span class="toc-text">说说你对单向数据流和双向数据流的理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81vue-router"><span class="toc-number">2.</span> <span class="toc-text">二、vue-router</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-route-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">vue-route 如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">何为命名路由？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%EF%BC%8C%E8%8E%B7%E5%8F%96%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">如何定义动态路由，获取动态参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">有哪些编程式导航方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%91%BD%E5%90%8D%E8%A7%86%E5%9B%BE%EF%BC%9F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">何为命名视图？如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B1%EF%BC%9F-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">何为嵌套路由？ 如何使用？何时使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%8C%85%E5%B1%91"><span class="toc-number">2.7.</span> <span class="toc-text">怎么通过路由实现面包屑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E4%BC%A0%E5%8F%82"><span class="toc-number">2.8.</span> <span class="toc-text">页面之间如何传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-router-%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">vue-router 有哪几种导航钩子？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#route%E5%92%8C-router-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.</span> <span class="toc-text">$route和$router 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">路由元信息是什么？有何作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C"><span class="toc-number">2.12.</span> <span class="toc-text">如何实现页面的过渡效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">2.13.</span> <span class="toc-text">如何实现路由重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">路由懒加载是什么？ 如何实现？为什么要懒加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">导航钩子有何作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%BF%80%E6%B4%BB%E5%AF%BC%E8%88%AA"><span class="toc-number">2.16.</span> <span class="toc-text">如何实现激活导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%B7%AF%E7%94%B1%E6%A8%A1%E5%BC%8F%EF%BC%9F-%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">有哪些路由模式？ 实现的具体原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#history-%E6%A8%A1%E5%BC%8F%E8%B7%AF%E7%94%B1%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">history 模式路由要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addRoutes-%E6%96%B9%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%9C%89%E4%BD%95%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">addRoutes 方法是什么？有何作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#base-%E9%85%8D%E7%BD%AE%E9%A1%B9%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.20.</span> <span class="toc-text">base 配置项的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.21.</span> <span class="toc-text">如何处理滚动行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%87%8C%E9%9D%A2%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">2.22.</span> <span class="toc-text">路由里面有哪些常用组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E9%87%8C%E9%9D%A2%E8%AF%A6%E6%83%85%E9%A1%B5%E8%B7%B3%E8%BD%AC%E8%AF%A6%E6%83%85%E9%A1%B5%EF%BC%8C%E7%BB%84%E4%BB%B6%E4%B8%8D%E9%87%8D%E6%96%B0%E5%88%9B%E5%BB%BA%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">2.23.</span> <span class="toc-text">路由里面详情页跳转详情页，组件不重新创建如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E8%BF%9B%E5%BA%A6%E6%9D%A1"><span class="toc-number">2.24.</span> <span class="toc-text">如何实现页面加载进度条</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2"><span class="toc-number">2.25.</span> <span class="toc-text">如何实现刷新页面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%A0%87%E7%AD%BE%E9%A1%B5"><span class="toc-number">2.26.</span> <span class="toc-text">如何使用路由实现标签页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.27.</span> <span class="toc-text">说一下路由实现的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84-vue-router-%E5%AF%BC%E8%88%AA%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">2.28.</span> <span class="toc-text">完整的 vue-router 导航解析流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E4%BF%9D%E5%AD%98%E8%8D%89%E7%A8%BF%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%91%A2%EF%BC%9F"><span class="toc-number">2.29.</span> <span class="toc-text">切换路由时，需要保存草稿的功能，怎么实现呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-router-link-%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="toc-number">2.30.</span> <span class="toc-text">说说你对 router-link 的了解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E8%B7%AF%E7%94%B1%E6%80%8E%E4%B9%88%E8%B7%B3%E8%BD%AC%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3%EF%BC%9F"><span class="toc-number">2.31.</span> <span class="toc-text">Vue 路由怎么跳转打开新窗口？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81vuex"><span class="toc-number">3.</span> <span class="toc-text">三、vuex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vuex-%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">vuex 和本地存储的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Vuex%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">什么是 Vuex？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Vuex 解决了什么问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%BC%95%E7%94%A8-Vuex%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">怎么引用 Vuex？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84-5-%E4%B8%AA%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">Vuex 的 5 个核心属性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD%E7%8A%B6%E6%80%81%E5%82%A8%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%8C%E6%80%8E%E4%B9%88%E6%94%B9%E5%8F%98%E5%AE%83%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">Vuex 中状态储存在哪里，怎么改变它？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD%E7%8A%B6%E6%80%81%E6%98%AF%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%97%B6%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">Vuex 中状态是对象时，使用时要注意什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%89%B9%E9%87%8F%E4%BD%BF%E7%94%A8-Vuex-%E7%9A%84-state-%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">怎么在组件中批量使用 Vuex 的 state 状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD%E8%A6%81%E4%BB%8E-state-%E6%B4%BE%E7%94%9F%E4%B8%80%E4%BA%9B%E7%8A%B6%E6%80%81%E5%87%BA%E6%9D%A5%EF%BC%8C%E4%B8%94%E5%A4%9A%E4%B8%AA%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%AE%83%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%8C%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">Vuex 中要从 state 派生一些状态出来，且多个组件使用它，该怎么做，？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87-getter-%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%BB%84%E4%BB%B6%E5%86%85%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E6%9D%A5%E8%8E%B7%E5%8F%96-state-%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">怎么通过 getter 来实现在组件内可以通过特定条件来获取 state 的状态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%89%B9%E9%87%8F%E4%BD%BF%E7%94%A8-Vuex-%E7%9A%84-getter-%E5%B1%9E%E6%80%A7"><span class="toc-number">3.11.</span> <span class="toc-text">怎么在组件中批量使用 Vuex 的 getter 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%89%B9%E9%87%8F%E7%BB%99-Vuex-%E7%9A%84-getter-%E5%B1%9E%E6%80%A7%E5%8F%96%E5%88%AB%E5%90%8D%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">3.12.</span> <span class="toc-text">怎么在组件中批量给 Vuex 的 getter 属性取别名并使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Vuex-%E7%9A%84-state-%E4%B8%AD%E6%9C%89%E4%B8%AA%E7%8A%B6%E6%80%81-number-%E8%A1%A8%E7%A4%BA%E8%B4%A7%E7%89%A9%E6%95%B0%E9%87%8F%EF%BC%8C%E5%9C%A8%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E6%94%B9%E5%8F%98%E5%AE%83%E3%80%82"><span class="toc-number">3.13.</span> <span class="toc-text">在 Vuex 的 state 中有个状态 number 表示货物数量，在组件怎么改变它。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Vuex-%E4%B8%AD%E4%BD%BF%E7%94%A8-mutation-%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%E3%80%82"><span class="toc-number">3.14.</span> <span class="toc-text">在 Vuex 中使用 mutation 要注意什么。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AA-mutation%EF%BC%8C%E6%80%8E%E4%B9%88%E5%86%99%E4%BD%BF%E7%94%A8%E6%9B%B4%E6%96%B9%E4%BE%BF%E3%80%82"><span class="toc-number">3.15.</span> <span class="toc-text">在组件中多次提交同一个 mutation，怎么写使用更方便。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD-action-%E5%92%8C-mutation-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.16.</span> <span class="toc-text">Vuex 中 action 和 mutation 有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD-action-%E5%92%8C-mutation-%E6%9C%89%E4%BB%80%E4%B9%88%E7%9B%B8%E5%90%8C%E7%82%B9%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">Vuex 中 action 和 mutation 有什么相同点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E5%A4%9A%E6%AC%A1%E6%8F%90%E4%BA%A4%E5%90%8C%E4%B8%80%E4%B8%AA-action%EF%BC%8C%E6%80%8E%E4%B9%88%E5%86%99%E4%BD%BF%E7%94%A8%E6%9B%B4%E6%96%B9%E4%BE%BF%E3%80%82"><span class="toc-number">3.18.</span> <span class="toc-text">在组件中多次提交同一个 action，怎么写使用更方便。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD-action-%E9%80%9A%E5%B8%B8%E6%98%AF%E5%BC%82%E6%AD%A5%E7%9A%84%EF%BC%8C%E9%82%A3%E4%B9%88%E5%A6%82%E4%BD%95%E7%9F%A5%E9%81%93-action-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BB%93%E6%9D%9F%E5%91%A2%EF%BC%9F"><span class="toc-number">3.19.</span> <span class="toc-text">Vuex 中 action 通常是异步的，那么如何知道 action 什么时候结束呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA-action%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF-actionA-%E5%92%8C-actionB%EF%BC%8C%E5%85%B6%E5%86%85%E9%83%BD%E6%98%AF%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%9C%A8-actionB-%E8%A6%81%E6%8F%90%E4%BA%A4-actionA%EF%BC%8C%E9%9C%80%E5%9C%A8-actionA-%E5%A4%84%E7%90%86%E7%BB%93%E6%9D%9F%E5%86%8D%E5%A4%84%E7%90%86%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">Vuex 中有两个 action，分别是 actionA 和 actionB，其内都是异步操作，在 actionB 要提交 actionA，需在 actionA 处理结束再处理其它操作，怎么实现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%94%A8%E8%BF%87-Vuex-%E6%A8%A1%E5%9D%97%E5%90%97%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">3.21.</span> <span class="toc-text">有用过 Vuex 模块吗，为什么要使用，怎么使用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%EF%BC%8Cgetter-%E5%92%8C-mutation-%E6%8E%A5%E6%94%B6%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0-state%EF%BC%8C%E6%98%AF%E5%85%A8%E5%B1%80%E7%9A%84%E8%BF%98%E6%98%AF%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">在模块中，getter 和 mutation 接收的第一个参数 state，是全局的还是模块的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%A8%A1%E5%9D%97%E4%B8%AD%EF%BC%8Cgetter-%E5%92%8C-mutation-%E5%92%8C-action-%E4%B8%AD%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E7%9A%84-state-%E5%92%8C-getter%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">在模块中，getter 和 mutation 和 action 中怎么访问全局的 state 和 getter？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E8%AE%BF%E9%97%AE-Vuex-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84-getter-%E5%92%8C-state-%E6%80%8E%E4%B9%88%E6%8F%90%E4%BA%A4-mutation-%E5%92%8C-action%EF%BC%9F"><span class="toc-number">3.24.</span> <span class="toc-text">在组件中怎么访问 Vuex 模块中的 getter 和 state,怎么提交 mutation 和 action？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E8%BF%87-Vuex-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">3.25.</span> <span class="toc-text">用过 Vuex 模块的命名空间吗？为什么使用，怎么使用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E5%86%85%E6%8F%90%E4%BA%A4%E5%85%A8%E5%B1%80%E7%9A%84-mutation-%E5%92%8C-action%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">怎么在带命名空间的模块内提交全局的 mutation 和 action？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%9C%A8%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%E5%86%85%E6%B3%A8%E5%86%8C%E5%85%A8%E5%B1%80%E7%9A%84-action%EF%BC%9F"><span class="toc-number">3.27.</span> <span class="toc-text">怎么在带命名空间的模块内注册全局的 action？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E6%8F%90%E4%BA%A4-modules-%E4%B8%AD%E7%9A%84%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84-moduleA-%E4%B8%AD%E7%9A%84-mutationA%EF%BC%9F"><span class="toc-number">3.28.</span> <span class="toc-text">组件中怎么提交 modules 中的带命名空间的 moduleA 中的 mutationA？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8-mapState%EF%BC%8CmapGetters%EF%BC%8CmapActions-%E5%92%8C-mapMutations-%E8%BF%99%E4%BA%9B%E5%87%BD%E6%95%B0%E6%9D%A5%E7%BB%91%E5%AE%9A%E5%B8%A6%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A8%A1%E5%9D%97%EF%BC%9F"><span class="toc-number">3.29.</span> <span class="toc-text">怎么使用 mapState，mapGetters，mapActions 和 mapMutations 这些函数来绑定带命名空间的模块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E6%8F%92%E4%BB%B6%E6%9C%89%E7%94%A8%E8%BF%87%E5%90%97%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">3.30.</span> <span class="toc-text">Vuex 插件有用过吗？怎么用简单介绍一下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Vuex-%E6%8F%92%E4%BB%B6%E4%B8%AD%E6%80%8E%E4%B9%88%E7%9B%91%E5%90%AC%E7%BB%84%E4%BB%B6%E4%B8%AD%E6%8F%90%E4%BA%A4-mutation-%E5%92%8C-action%EF%BC%9F"><span class="toc-number">3.31.</span> <span class="toc-text">在 Vuex 插件中怎么监听组件中提交 mutation 和 action？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-v-model-%E4%B8%8A%E6%80%8E%E4%B9%88%E7%94%A8-Vuex-%E4%B8%AD-state-%E7%9A%84%E5%80%BC%EF%BC%9F"><span class="toc-number">3.32.</span> <span class="toc-text">在 v-model 上怎么用 Vuex 中 state 的值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8-%E6%80%8E%E4%B9%88%E5%BC%80%E5%90%AF%EF%BC%9F"><span class="toc-number">3.33.</span> <span class="toc-text">Vuex 的严格模式是什么,有什么作用,怎么开启？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E4%BF%AE%E6%94%B9-state"><span class="toc-number">3.34.</span> <span class="toc-text">为什么不推荐直接赋值修改 state</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81axios"><span class="toc-number">4.</span> <span class="toc-text">四、axios</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">axios 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E7%89%B9%E7%82%B9"><span class="toc-number">4.2.</span> <span class="toc-text">axios 特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">axios 常用语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A2%E8%83%BD%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%E5%8F%88%E8%83%BD%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8-node-%E7%8E%AF%E5%A2%83%E8%BF%90%E8%A1%8C%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">axios 为什么既能在浏览器环境运行又能在服务器(node)环境运行？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E7%9B%B8%E6%AF%94%E5%8E%9F%E7%94%9F-ajax-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">4.5.</span> <span class="toc-text">axios 相比原生 ajax 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E4%B8%8B%E4%BD%A0%E4%BA%86%E8%A7%A3%E7%9A%84-axios-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">说下你了解的 axios 相关配置属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-axios-%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-number">4.7.</span> <span class="toc-text">什么是 axios 拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A6%E6%88%AA%E5%99%A8%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">4.8.</span> <span class="toc-text">拦截器如何使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-axios-%E5%AE%9E%E4%BE%8B"><span class="toc-number">4.9.</span> <span class="toc-text">如何创建一个 axios 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#axios-%E5%A4%84%E7%90%86-token-%E8%BF%87%E6%9C%9F%E5%90%8E%E5%A6%82%E4%BD%95%E7%BB%A7%E7%BB%AD%E4%B9%8B%E5%89%8D%E7%9A%84%E8%AF%B7%E6%B1%82"><span class="toc-number">4.10.</span> <span class="toc-text">axios 处理 token 过期后如何继续之前的请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-axios"><span class="toc-number">4.11.</span> <span class="toc-text">vue 中如何使用 axios</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81vue-cli"><span class="toc-number">5.</span> <span class="toc-text">五、vue-cli</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%AD%89%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">5.1.</span> <span class="toc-text">vue 等单页面应用及其优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-cli-%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-2-x-%E7%89%88%E6%9C%AC%E6%A8%A1%E6%9D%BF"><span class="toc-number">5.2.</span> <span class="toc-text">vue-cli 如何安装 2.x 版本模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-cli2-x-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE-less"><span class="toc-number">5.3.</span> <span class="toc-text">vue-cli2.x 如何配置 less</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-cli2-x-%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F"><span class="toc-number">5.4.</span> <span class="toc-text">vue-cli2.x 如何配置跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-cli2-x-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE"><span class="toc-number">5.5.</span> <span class="toc-text">vue-cli2.x 如何进行打包配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81SSR"><span class="toc-number">6.</span> <span class="toc-text">六、SSR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%85%B6%E4%BB%96"><span class="toc-number">7.</span> <span class="toc-text">七、其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%B8%B8%E7%94%A8-UI-%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.1.</span> <span class="toc-text">vue 常用 UI 库有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="toc-number">7.2.</span> <span class="toc-text">vue 常用插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">vue 项目如何实现权限管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9-SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">说说你对 SPA 单页面的理解，它的优缺点分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SPA-%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">SPA 单页面的实现方式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6"><span class="toc-number">7.6.</span> <span class="toc-text">Vue 如何优化首页加载速度</span></a></li></ol></li></ol>
  </div>


		  </nav>
		
	</header>
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
      <a class="forkMe" style="position:absolute;z-index:999;top:0;right:0.5em;"
        href="https://github.com/luckyship/myblog" target="_blank">
        <img src="/img/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/img/head.jpg" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">luckyship</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/luckyship" title="GitHub"><i class="icon-github"></i></a>
			        
						<a class="gitee" target="_blank" href="https://gitee.com/luckyship" title="gitee"><i class="icon-gitee"></i></a>
			        
						<a class="blog" target="_blank" href="https://juejin.cn/user/730534951787662/posts" title="blog"><i class="icon-blog"></i></a>
			        
						<a class="csdn" target="_blank" href="https://blog.csdn.net/sinat_38319625" title="CSDN"><i class="icon-csdn"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/archives">归档</a></li>
		        
					<li style="width: 25%"><a href="/comment/">留言板</a></li>
		        
					<li style="width: 25%"><a href="/website/">知识库</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-2021-09-12-vue-knowledge" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      Vue你了解哪些
    </h1>
  


  
   
<span id="busuanzi_container_page_pv" style="display: none" class="archive-article-date">
  <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
</span>


<a href="/2021/09/12/2021-09-12-vue-knowledge/" class="archive-article-date">
  <!-- <time datetime="2021-09-12T08:26:18.000Z" title="发布时间" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-09-12</time>
        <time datetime="2025-08-02T05:46:04.178Z" title="最后更新" itemprop="datePublished">
                <svg t="1614416122145" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="535" width="16" height="16"><path d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z" p-id="536" fill="#999999"></path><path d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z" p-id="537" fill="#999999"></path></svg>
                2025-08-02</time> -->

  
  <time datetime="2025-08-02T05:46:04.178Z" title="最后更新" itemprop="datePublished">
    <svg
      t="1614416122145"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="535"
      width="16"
      height="16"
    >
      <path
        d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z"
        p-id="536"
        fill="#999999"
      ></path>
      <path
        d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z"
        p-id="537"
        fill="#999999"
      ></path>
    </svg>
    <span >
      2021-09-12
      <span style="font-size: 10px"> (更新于2025-08-02)
    </span>
  </time>
  
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">22.9k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">94分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h2 id="一、vue"><a href="#一、vue" class="headerlink" title="一、vue"></a>一、vue</h2><h3 id="vue-优点"><a href="#vue-优点" class="headerlink" title="vue 优点"></a>vue 优点</h3><ul>
<li><p>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb；</p>
</li>
<li><p>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</p>
</li>
<li><p>双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单；</p>
</li>
<li><p>组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势；</p>
</li>
<li><p>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</p>
</li>
<li><p>虚拟 DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式；</p>
</li>
<li><p>运行速度更快:相比较与 react 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势。</p>
</li>
</ul>
<span id="more"></span>

<h3 id="谈谈对-vue-渐进式的理解"><a href="#谈谈对-vue-渐进式的理解" class="headerlink" title="谈谈对 vue 渐进式的理解"></a>谈谈对 vue 渐进式的理解</h3><p><img src="/img/vue-interview/001.png"></p>
<h3 id="什么是-MVVM？"><a href="#什么是-MVVM？" class="headerlink" title="什么是 MVVM？"></a>什么是 MVVM？</h3><p>MVVM 是是 Model-View-ViewModel 的缩写，Model 代表数据模型，定义数据操作的业务逻辑，View 代表视图层，负责将数据模型渲染到页面上，ViewModel 通过双向绑定把 View 和 Model 进行同步交互，不需要手动操作 DOM 的一种设计思想。</p>
<h3 id="MVVM-和-MVC-区别？和其他框架-jquery-区别？那些场景适用？"><a href="#MVVM-和-MVC-区别？和其他框架-jquery-区别？那些场景适用？" class="headerlink" title="MVVM 和 MVC 区别？和其他框架(jquery)区别？那些场景适用？"></a>MVVM 和 MVC 区别？和其他框架(jquery)区别？那些场景适用？</h3><p>MVVM 和 MVC 都是一种设计思想，主要就是 MVC 中的 Controller 演变成 ViewModel,，<u>MVVM 主要通过数据来显示视图层而不是操作节点，解决了 MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度慢，影响用户体验问题。主要用于数据操作比较多的场景</u>。<br>场景：<strong>数据操作比较多的场景，更加便捷</strong></p>
<h3 id="v-show-和-v-if-指令的共同点和不同点"><a href="#v-show-和-v-if-指令的共同点和不同点" class="headerlink" title="v-show 和 v-if 指令的共同点和不同点?"></a>v-show 和 v-if 指令的共同点和不同点?</h3><ul>
<li>v-show 指令是通过修改元素的 displayCSS 属性让其显示或者隐藏。 【CSS 控制节点是否显示，节点一直存在】</li>
<li>v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果。 【DOM 节点是否存在】</li>
<li>使用场景：需要反复展示就用<code>v-show</code>，如果一次决定不同模板内容就用<code>v-if</code></li>
</ul>
<h3 id="vue-中-key-值的作用"><a href="#vue-中-key-值的作用" class="headerlink" title="vue 中 key 值的作用"></a>vue 中 key 值的作用</h3><p><strong>当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。</strong>如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM 【防止采用就地复用策略进行改变】</p>
<h3 id="如何在组件内部实现一个双向数据绑定？"><a href="#如何在组件内部实现一个双向数据绑定？" class="headerlink" title="如何在组件内部实现一个双向数据绑定？"></a>如何在组件内部实现一个双向数据绑定？</h3><ul>
<li>该题目又可能称之为 ：<strong>如何在组件上面使用 v-model</strong></li>
</ul>
<p><strong>考察组件的 v-model</strong></p>
<p>文档地址：</p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model</a></p>
<p><a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model">https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> component = &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>], <span class="hljs-comment">// 默认props接收value属性</span><br>  <span class="hljs-attr">template</span>: <span class="hljs-string">``</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">handleInput</span>(<span class="hljs-params">e</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;input&#x27;</span>, e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>); <span class="hljs-comment">// 默认触发自定义事件input</span><br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">CompOne</span>: component,<br>  &#125;,<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#root&#x27;</span>,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">``</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;123&#x27;</span>,<br>    &#125;;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p>v-model 双向数据绑定，一般用于表单元素。</p>
</li>
<li><p>v-for 对数组或对象进行循环操作，使用是 v-for 不是 v-repeat</p>
</li>
<li><p>v-on 用来绑定事件，用法：v-on:事件 = ‘函数’</p>
</li>
<li><p>v-show/v-if 用来显示或隐藏元素，v-show 是通过 display 实现，v-if 是每次删除后在创建</p>
</li>
<li><p>v-bind 属性绑定</p>
</li>
<li><p>v-html 渲染文档，可以编译 HTML 字符串</p>
</li>
<li><p>v-text 渲染文本，不可以编译 HTML 字符串</p>
</li>
</ul>
<h3 id="computed-和-method-区别"><a href="#computed-和-method-区别" class="headerlink" title="computed 和 method 区别"></a>computed 和 method 区别</h3><ul>
<li>computed 依赖于缓存，依赖的变量变化了才会变化，模板变化了，即使依赖变量没有变化也不会重新计算；</li>
<li>method 是事件，method 里面的事件每次都会执行，只要模板更新都会再次执行。</li>
</ul>
<h3 id="什么是-vue-的单向数据流"><a href="#什么是-vue-的单向数据流" class="headerlink" title="什么是 vue 的单向数据流"></a>什么是 vue 的单向数据流</h3><ul>
<li><p>文档地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81">https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81</a></p>
</li>
<li><p>vue 的单向数据流指的是 vue 组件通信里面<strong>父子通信是自上而下的，我们不能直接修改 props 里面属性。</strong></p>
</li>
</ul>
<h3 id="vue-里面如何操作样式"><a href="#vue-里面如何操作样式" class="headerlink" title="vue 里面如何操作样式"></a>vue 里面如何操作样式</h3><ul>
<li>操作 style<ul>
<li>对象语法 <code>:style=&quot;&#123;CSS属性名:变量&#125;&quot; </code></li>
<li>数组语法 <code>:style=&quot;[样式描述变量1，样式描述变量2]&quot;</code></li>
<li>直接字符串 <code>style=&#39;css属性名:css属性值;css属性名2:css属性值2;...&#39;</code></li>
</ul>
</li>
<li>操作 class<ul>
<li>对象语法 <code>:class=&quot;&#123;class名:布尔变量&#125;&quot;</code></li>
<li>数组语法 <code>:class=&quot;[变量1,变量2,...]&quot;</code></li>
<li>三木语法：<code> :class = &quot;条件 ? &#39;class名1&#39;:&#39;class名2&#39;&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="v-if-和-v-for-为什么不推荐一起用"><a href="#v-if-和-v-for-为什么不推荐一起用" class="headerlink" title="v-if 和 v-for 为什么不推荐一起用"></a>v-if 和 v-for 为什么不推荐一起用</h3><p>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。 所以会导致每个列表项渲染的时候都会进行条件判断，从而让性能比较低。</p>
<h3 id="数组更新检测有哪些方法"><a href="#数组更新检测有哪些方法" class="headerlink" title="数组更新检测有哪些方法"></a>数组更新检测有哪些方法</h3><ul>
<li>变更方法 【修改原数组】</li>
</ul>
<p>Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">push</span>();<br><span class="hljs-title function_">pop</span>();<br><span class="hljs-title function_">shift</span>();<br><span class="hljs-title function_">unshift</span>();<br><span class="hljs-title function_">splice</span>();<br><span class="hljs-title function_">sort</span>();<br><span class="hljs-title function_">reverse</span>();<br></code></pre></td></tr></table></figure>

<ul>
<li><p>替换数组</p>
<p>变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 <code>filter()</code>、<code>concat()</code> 和 <code>slice()</code>。它们不会变更原始数组，而<strong>总是返回一个新数组</strong>。</p>
</li>
</ul>
<h3 id="如果获取事件对象"><a href="#如果获取事件对象" class="headerlink" title="如果获取事件对象"></a>如果获取事件对象</h3><ul>
<li><p>在书写事件函数的时候直接写上形参就表示事件对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>  <span class="hljs-title function_">fn</span>(<span class="hljs-params">ev</span>)&#123;   <span class="hljs-comment">// ev就是事件对象</span><br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如果既要传参又要获取事件对象，那么传入实参的时候传入一个<code>$event</code>表示事件对象，<code>$event</code>这个单词不能写错</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;run(10,$event)&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">run</span>(<span class="hljs-params">num,ev</span>)&#123;  <span class="hljs-comment">// 形参实参一一对应，ev和$event对应所以 就是事件对象</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="哪些常见事件修饰符，有何作用"><a href="#哪些常见事件修饰符，有何作用" class="headerlink" title="哪些常见事件修饰符，有何作用"></a>哪些常见事件修饰符，有何作用</h3><ul>
<li><code>.stop </code> 阻止冒泡</li>
<li><code>.prevent</code> 阻止默认行为</li>
<li><code>.capture</code> 捕获阶段触发</li>
<li><code>.self</code> 自己本身上面触发</li>
<li><code>.once</code> 一次性绑定</li>
<li><code>.passive</code> 一般给 scroll 或者 resize 事件绑定，等到调整完成之后触发。</li>
</ul>
<h3 id="有哪些常见按键修饰符，以及如何定义按键修饰符"><a href="#有哪些常见按键修饰符，以及如何定义按键修饰符" class="headerlink" title="有哪些常见按键修饰符，以及如何定义按键修饰符"></a>有哪些常见按键修饰符，以及如何定义按键修饰符</h3><ul>
<li><code>.enter</code></li>
<li><code>.tab</code></li>
<li><code>.delete</code> (捕获“删除”和“退格”键)</li>
<li><code>.esc</code></li>
<li><code>.space</code></li>
<li><code>.up</code></li>
<li><code>.down</code></li>
<li><code>.left</code></li>
<li><code>.right</code></li>
<li>所有字母都也是按键修饰符</li>
</ul>
<p><strong>自定义按键修饰符：<code>Vue.config.keyCodes.按键修饰符名 = 按键码</code></strong></p>
<h3 id="如何实现一个-v-model-指令"><a href="#如何实现一个-v-model-指令" class="headerlink" title="如何实现一个 v-model 指令"></a>如何实现一个 v-model 指令</h3><ul>
<li><p>v-model 其实是 属性绑定和事件综合使用的语法糖。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;input type=<span class="hljs-string">&quot;text&quot;</span>  :value=<span class="hljs-string">&quot;msg&quot;</span>   @input=<span class="hljs-string">&quot;msg=$event.target.value&quot;</span>  /&gt;<br><span class="hljs-comment">// 先给输入框的value绑定变量，这叫做属性绑定</span><br><span class="hljs-comment">// 再给输入框绑定input事件，一旦输入，就将输入框的值赋给msg变量，从而实现双向绑定</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="表单控件绑定需要什么？"><a href="#表单控件绑定需要什么？" class="headerlink" title="表单控件绑定需要什么？"></a>表单控件绑定需要什么？</h3><ul>
<li>给一组单选控件绑定给同一个变量，且每个单选控件都要有个一个 value</li>
<li>给一组多选控件绑定同一个变量，且这个变量是一个数组，且每个多选项都要有一个 value</li>
<li>如果 input 的 type 为 checkbox，我们用来做勾选的时候， 应该绑定一个布尔值类型的变量</li>
<li>textarea 绑定数据，同样应该使用 v-model 直接给到标签，而不是插值表达式</li>
</ul>
<h3 id="有哪些常见的表单修饰符"><a href="#有哪些常见的表单修饰符" class="headerlink" title="有哪些常见的表单修饰符"></a>有哪些常见的表单修饰符</h3><ul>
<li><code>.lazy</code> 在“change”时而非“input”时更新</li>
<li><code>.number</code> 将用户的输入值转为数值类型</li>
<li><code>.trim</code> 自动过滤用户输入的首尾空白字符</li>
</ul>
<h3 id="如何定义一个组件"><a href="#如何定义一个组件" class="headerlink" title="如何定义一个组件"></a>如何定义一个组件</h3><ul>
<li>全局注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(组件名, &#123; 组件配置选项 &#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li>局部注册</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件或者vue实例的配置选项里面增加components属性。</span><br>&#123;<br>  ...,<br>  <span class="hljs-attr">components</span>:&#123;<br>    组件名:&#123; 组件配置对象 &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="组件-data-为啥是一个函数"><a href="#组件-data-为啥是一个函数" class="headerlink" title="组件 data 为啥是一个函数"></a>组件 data 为啥是一个函数</h3><p>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。</p>
<p><strong>简而言之：组件的数据应该是各自独立的，互不干扰，所以 data 是函数返回一个对象，这样各自就独立了。</strong></p>
<h3 id="组件的-props-是什么？如何定义"><a href="#组件的-props-是什么？如何定义" class="headerlink" title="组件的 props 是什么？如何定义"></a>组件的 props 是什么？如何定义</h3><ul>
<li><p>props 是组件向外提供的一个接口，用来接收外部数据，也是父组件传递给子组件的主要方式</p>
</li>
<li><p>如何定义</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 方式1： 数组语法</span><br><span class="hljs-attr">props</span>:[<span class="hljs-string">&#x27;自定义属性名1&#x27;</span>,<span class="hljs-string">&#x27;自定义属性名2&#x27;</span>,...]<br><br><span class="hljs-comment">// 方式2： 对象语法</span><br><span class="hljs-attr">props</span>:&#123;<br>  自定义属性名<span class="hljs-number">1</span>:&#123;<br>      <span class="hljs-attr">type</span>:类型 或  [类型<span class="hljs-number">1</span>，类型<span class="hljs-number">2</span>,...],    <span class="hljs-comment">// 类型有  Object,Array,String,Boolean,Number,Date,Function ，</span><br>      <span class="hljs-attr">default</span>:默认值，  <span class="hljs-comment">// 基本数据类型</span><br>      <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>)&#123;        <span class="hljs-comment">// 如果props的值是引用数据类型，那么设置默认值的时候应该是一个函数，返回数组或对象</span><br>        <span class="hljs-keyword">return</span> []/&#123;&#125;<br>      &#125;,<br>      <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">validator</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)&#123;  <span class="hljs-comment">// val就是该属性对应的值，用于内部做判断使用</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>   <span class="hljs-comment">// true表示验证通过，false表示验证不通过，控制台会有警告</span><br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何自定义组件的-v-model"><a href="#如何自定义组件的-v-model" class="headerlink" title="如何自定义组件的 v-model"></a>如何自定义组件的 v-model</h3><p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;base-checkbox&#x27;</span>, &#123;<br>  <span class="hljs-attr">model</span>: &#123;<br>    <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;checked&#x27;</span>,<br>    <span class="hljs-attr">event</span>: <span class="hljs-string">&#x27;change&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">checked</span>: <span class="hljs-title class_">Boolean</span>,<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;input</span><br><span class="hljs-string">      type=&quot;checkbox&quot;</span><br><span class="hljs-string">      v-bind:checked=&quot;checked&quot;</span><br><span class="hljs-string">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="hljs-string">    &gt;</span><br><span class="hljs-string">  `</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;base-checkbox v-model=<span class="hljs-string">&quot;lovingVue&quot;</span>&gt;&lt;/base-checkbox&gt;<br></code></pre></td></tr></table></figure>

<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<p>注意你仍然需要在组件的 <code>props</code> 选项里声明 <code>checked</code> 这个 prop。</p>
<h3 id="native修饰符有何用"><a href="#native修饰符有何用" class="headerlink" title=".native修饰符有何用"></a><code>.native</code>修饰符有何用</h3><ul>
<li>当我们给组件绑定原生事件无效的时候，可以加上<code>.native</code>修饰符就可以让组件上面的原生事件有效。</li>
</ul>
<h3 id="sync修饰符有何作用"><a href="#sync修饰符有何作用" class="headerlink" title=".sync修饰符有何作用"></a><code>.sync</code>修饰符有何作用</h3><p><code>.sync</code>的用法如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">组件</span> <span class="hljs-attr">:属性名.sync</span>=<span class="hljs-string">&quot;变量&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>其实他本质是一个语法糖：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">组件</span> <span class="hljs-attr">:属性名</span>=<span class="hljs-string">&quot;变量&quot;</span> @<span class="hljs-attr">update:属性名</span> = <span class="hljs-string">&quot;变量=$event&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>其实是 v-model 的另外一种使用展示。</p>
<p>这也是为什么我们推荐以 <code>update:myPropName</code> 的模式触发事件取而代之。举个例子，在一个包含 <code>title</code> prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">this.$emit(&#x27;update:title&#x27;, newTitle)<br></code></pre></td></tr></table></figure>

<p>然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;doc.title&quot;</span> <span class="hljs-attr">v-on:update:title</span>=<span class="hljs-string">&quot;doc.title = $event&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>为了方便起见，我们为这种模式提供一个缩写，即 <code>.sync</code> 修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">text-document</span> <span class="hljs-attr">v-bind:title.sync</span>=<span class="hljs-string">&quot;doc.title&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">text-document</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意带有 <code>.sync</code> 修饰符的 <code>v-bind</code> **不能</strong>和表达式一起使用**</p>
<h3 id="插槽是什么？-有哪些分类？"><a href="#插槽是什么？-有哪些分类？" class="headerlink" title="插槽是什么？ 有哪些分类？"></a>插槽是什么？ 有哪些分类？</h3><ul>
<li>插槽是用来自定义组件内部模板内容的一种方式；</li>
<li>分类：<ul>
<li>默认插槽</li>
<li>具名插槽</li>
<li>作用域插槽</li>
</ul>
</li>
</ul>
<h3 id="写一个具名插槽"><a href="#写一个具名插槽" class="headerlink" title="写一个具名插槽"></a>写一个具名插槽</h3><p>方式 1：(老写法)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;名称&quot;</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--组件内部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>方式 2：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:名称</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--组件内部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>方式 3：其实是方式 2 的简写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">名称</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--组件内部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名称&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="作用域插槽如何写"><a href="#作用域插槽如何写" class="headerlink" title="作用域插槽如何写"></a>作用域插槽如何写</h3><p>方式 1：(老写法)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;名称&quot;</span> <span class="hljs-attr">slot-scope</span>=<span class="hljs-string">&quot;作用域名&quot;</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>方式 2：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:名称</span>=<span class="hljs-string">&quot;作用域名&quot;</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>方式 3：其实是方式 2 的简写</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--组件外部--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">名称</span>=<span class="hljs-string">&quot;作用域名&quot;</span>&gt;</span><br>  	自定义HTML内容<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="如何实现动态组件"><a href="#如何实现动态组件" class="headerlink" title="如何实现动态组件"></a>如何实现动态组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;变量&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-comment">&lt;!--变量的值就是组件名，这里就会展示什么组件--&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="如何实现缓存组件"><a href="#如何实现缓存组件" class="headerlink" title="如何实现缓存组件"></a>如何实现缓存组件</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">组件名</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">组件名</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="缓存组件要注意什么？"><a href="#缓存组件要注意什么？" class="headerlink" title="缓存组件要注意什么？"></a>缓存组件要注意什么？</h3><ul>
<li>缓存组件抱起来的组件将会被缓存，下一次打开的时候不会被再次创建（所以前四个生命周期不会再次被创建），所以我们不能把组件一打开就要做的放在 created 或 mounted 里面，因为组件不会再次创建。我们需要放在<code>activated</code>钩子里面。具体可参见文档：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#activated">https://cn.vuejs.org/v2/api/#activated</a></li>
</ul>
<h3 id="如何定义一个递归组件"><a href="#如何定义一个递归组件" class="headerlink" title="如何定义一个递归组件"></a>如何定义一个递归组件</h3><ul>
<li><p>所谓的递归组件就是内部不断调用自己，在我们的树形结构中非常常见，如无限极分类；无限极菜单都常用；</p>
</li>
<li><p>递归组件最核心的就是组件一定要定义好 name 名次，否则无法起作用。</p>
</li>
<li><p>递归组件一定要有不成立的时候，否则无限递归，就会出错。</p>
<img src="/img/vue-interview/006.png" style="zoom:50%;" />
- 数据如下

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = [<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;项目管理&#x27;</span>,<br>      <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">childTreeNode</span>: [<br>      &#123;<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;项目&#x27;</span>,<br>          <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;BusProject&#x27;</span>,<br>        &#125;,<br>        <span class="hljs-attr">childTreeNode</span>: [],<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;我的任务&#x27;</span>,<br>          <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;BusProject&#x27;</span>,<br>        &#125;,<br>        <span class="hljs-attr">childTreeNode</span>: [],<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">data</span>: &#123;<br>          <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;人员周报&#x27;</span>,<br>          <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;BusProject&#x27;</span>,<br>        &#125;,<br>        <span class="hljs-attr">childTreeNode</span>: [],<br>      &#125;,<br>    ],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;2&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;数据统计&#x27;</span>,<br>      <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;BusClock&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">childTreeNode</span>: [],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;3&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;人事管理&#x27;</span>,<br>      <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">childTreeNode</span>: [],<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;4&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-attr">menuName</span>: <span class="hljs-string">&#x27;基础管理&#x27;</span>,<br>      <span class="hljs-attr">menuCode</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">childTreeNode</span>: [],<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure>

<ul>
<li><p>递归组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 父组件中引入items   --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">items</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;model&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;model in data&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">items</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isFolder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa &quot;</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[open ? &#x27;fa-folder-open&#x27; : &#x27;fa-folder&#x27;]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--isFolder判断是否存在子级改变图标--&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!isFolder&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-file-text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>      &#123;&#123; model.data.menuName &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;open&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isFolder&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">items</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;cel in model.childTreeNode&quot;</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;cel&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">items</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;items&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;model&#x27;</span>],</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;&#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">open</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">isFolder</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">isFolder</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">childTreeNode</span> &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-property">model</span>.<span class="hljs-property">childTreeNode</span>.<span class="hljs-property">length</span>;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">toggle</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">isFolder</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">open</span> = !<span class="hljs-variable language_">this</span>.<span class="hljs-property">open</span>;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="vue-如何强制刷新组件"><a href="#vue-如何强制刷新组件" class="headerlink" title="vue 如何强制刷新组件"></a>vue 如何强制刷新组件</h3><p><strong>1.使用 <code>this.$forceUpdate</code> 强制重新渲染</strong></p>
<p>如果要在组件内部中进行强制刷新，则可以调用**<code>this.$forceUpdate()</code>**强制重新渲染组件，从而达到更新目的。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reload()&quot;</span>&gt;</span>刷新当前组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;comp&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">reload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.$forceUpdate()</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>2.使用 v-if 指令</strong></p>
<p>如果是刷新某个子组件，则可以通过 v-if 指令实现。我们知道，当 v-if 的值发生变化时，组件都会被重新渲染一遍。因此，利用 v-if 指令的特性，可以达到强制刷新组件的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">comp</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;update&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">comp</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;reload()&quot;</span>&gt;</span>刷新comp组件<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> comp <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/views/comp.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;parentComp&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">update</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title function_">reload</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 移除组件</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">update</span> = <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">        <span class="hljs-comment">// 在组件移除后，重新渲染组件</span></span><br><span class="language-javascript">        <span class="hljs-comment">// this.$nextTick可实现在DOM 状态更新后，执行传入的方法。</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">update</span> = <span class="hljs-literal">true</span>;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="什么时候使用-vue-动画"><a href="#什么时候使用-vue-动画" class="headerlink" title="什么时候使用 vue 动画"></a>什么时候使用 vue 动画</h3><ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<h3 id="vue-动画有哪些类名"><a href="#vue-动画有哪些类名" class="headerlink" title="vue 动画有哪些类名"></a>vue 动画有哪些类名</h3><ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><img src="https://cn.vuejs.org/images/transition.png"></p>
<h3 id="有哪些自定义过渡类名"><a href="#有哪些自定义过渡类名" class="headerlink" title="有哪些自定义过渡类名"></a>有哪些自定义过渡类名</h3><ul>
<li><code>enter-class</code></li>
<li><code>enter-active-class</code></li>
<li><code>enter-to-class</code> (2.1.8+)</li>
<li><code>leave-class</code></li>
<li><code>leave-active-class</code></li>
<li><code>leave-to-class</code> (2.1.8+)</li>
</ul>
<h3 id="vue-中-mixins-配置选项是什么？有何作用"><a href="#vue-中-mixins-配置选项是什么？有何作用" class="headerlink" title="vue 中 mixins 配置选项是什么？有何作用"></a>vue 中 mixins 配置选项是什么？有何作用</h3><ul>
<li><p>mixins 是混入，用于实现复用组件所需要的配置选项，可以实现很多功能的复用。</p>
</li>
<li><p>文档地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/mixins.html">https://cn.vuejs.org/v2/guide/mixins.html</a></p>
</li>
<li><p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个混入对象</span><br><span class="hljs-keyword">var</span> myMixin = &#123;<br>  <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">hello</span>();<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">hello</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;hello from mixin!&#x27;</span>);<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">// 定义一个使用混入对象的组件</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Component</span> = <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">extend</span>(&#123;<br>  <span class="hljs-attr">mixins</span>: [myMixin],<br>&#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="mixin-混入对象和-Vuex-的区别："><a href="#mixin-混入对象和-Vuex-的区别：" class="headerlink" title="mixin 混入对象和 Vuex 的区别："></a>mixin 混入对象和 Vuex 的区别：</h4><ul>
<li>Vuex 是状态共享管理，所以 Vuex 中的所有变量和方法都是可以读取和更改并相互影响的；</li>
<li>mixin 可以定义公用的变量或方法，但是 mixin 中的数据是不共享的，也就是每个组件中的 mixin 实例都是不一样的，都是单独存在的个体，不存在相互影响的；</li>
<li>mixin 混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行 mixin 中的同名函数；（生命周期钩子函数、methods 等）</li>
<li>mixin 混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将 mixin 混入对象的同名对象进行覆盖；(watch、methods 中定义的方法等)</li>
</ul>
<h3 id="如何实现一个自定义指令"><a href="#如何实现一个自定义指令" class="headerlink" title="如何实现一个自定义指令"></a>如何实现一个自定义指令</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局注册指令</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;指令名&#x27;</span>, &#123;<br>  配置选项,<br>&#125;);<br><br><span class="hljs-comment">// 局部注册</span><br>&#123;<br>  <span class="hljs-attr">directives</span>: &#123;<br>    指令名: &#123;<br>      配置选项;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="自定义指令有何作用？-有哪些钩子"><a href="#自定义指令有何作用？-有哪些钩子" class="headerlink" title="自定义指令有何作用？ 有哪些钩子"></a>自定义指令有何作用？ 有哪些钩子</h3><ul>
<li><p>作用：当我们希望对原生的 DOM 节点，或者组件 都做 某一类型的操作的时候（如：页面已进入输入框就获取焦点；如输入框一旦加上某个指令就可以实现自动验证），我们就可以用自定义指令来开发我们想要的功能。</p>
</li>
<li><p>钩子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">inserted：被绑定元素插入父节点时调用 </span>(仅保证父节点存在，但不一定已被插入文档中)。<br>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前<br>我们会在稍后讨论渲染函数时介绍更多 VNodes 的细节。<br>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。<br>unbind：只调用一次，指令与元素解绑时调用。<br></code></pre></td></tr></table></figure>

<p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</p>
</li>
<li><p><code>binding</code>：一个对象，包含以下 property：</p>
<ul>
<li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
<li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><p><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</p>
</li>
<li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
</li>
</ul>
<h3 id="过滤器是什么？如何定义？如何使用？"><a href="#过滤器是什么？如何定义？如何使用？" class="headerlink" title="过滤器是什么？如何定义？如何使用？"></a>过滤器是什么？如何定义？如何使用？</h3><ul>
<li><p>是什么： 是对模板里面的数据进行某一类的操作，可以理解为模板的工具函数（如：直接在模板里面使用定义好的过滤器实现时间戳变格式化的时间；价格保留小数位等等处理）</p>
</li>
<li><p>如何定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局注册</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-string">&#x27;过滤器名&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">val,形参</span>)=&gt;</span>&#123;   <span class="hljs-comment">// val表示传入的值， 第二个参数开始才是传入的实参 这个函数一定要有返回值</span><br>	<span class="hljs-comment">// 处理</span><br>	<span class="hljs-keyword">return</span> 结果<br>&#125;)<br><br><br><span class="hljs-comment">// 局部注册</span><br>&#123;<br>  <span class="hljs-attr">filters</span>:&#123;<br>    过滤器名(val,形参)&#123;<br>      <span class="hljs-keyword">return</span> 结果<br>    &#125;,<br>    过滤器名<span class="hljs-number">2</span>(val,形参)&#123;<br>      <span class="hljs-keyword">return</span> 结果<br>    &#125;,<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>如何使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;&#123; 变量 | 过滤器 &#125;&#125;   <span class="hljs-comment">// 单个使用</span><br>&#123;&#123; 变量 | 过滤器<span class="hljs-number">1</span> | 过滤器<span class="hljs-number">2</span> | ... &#125;&#125;   <span class="hljs-comment">// 串联使用，下一个过滤器函数接收的是上一个过滤器处理的结果</span><br>&#123;&#123; 变量 | 过滤器(实参) &#125;&#125;   <span class="hljs-comment">// 过滤器传参</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-use-是什么-如何使用？"><a href="#Vue-use-是什么-如何使用？" class="headerlink" title="Vue.use 是什么? 如何使用？"></a>Vue.use 是什么? 如何使用？</h3><ul>
<li><p>是什么： vue.use 是 vue 的插件安装函数。调用 use 我们可以安装很多第三方的插件，如 vue-router,vuex, element-ui,vant 等等，当然最重要的是可以安装我们自己开发的插件。</p>
</li>
<li><p>开发插件</p>
<p>Vue.js 的插件应该暴露一个 <code>install</code> 方法。这个方法的第一个参数是 <code>Vue</code> 构造器，第二个参数是一个可选的选项对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">MyPlugin</span>.<span class="hljs-property">install</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">Vue, options</span>) &#123;<br>  <span class="hljs-comment">// 1. 添加全局方法或 property</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property">myGlobalMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 逻辑...</span><br>  &#125;<br><br>  <span class="hljs-comment">// 2. 添加全局资源</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;my-directive&#x27;</span>, &#123;<br>    <span class="hljs-title function_">bind</span> (el, binding, vnode, oldVnode) &#123;<br>      <span class="hljs-comment">// 逻辑...</span><br>    &#125;<br>    ...<br>  &#125;)<br><br>  <span class="hljs-comment">// 3. 注入组件选项</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">mixin</span>(&#123;<br>    <span class="hljs-attr">created</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 逻辑...</span><br>    &#125;<br>    ...<br>  &#125;)<br><br>  <span class="hljs-comment">// 4. 添加实例方法</span><br>  <span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$myMethod</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">methodOptions</span>) &#123;<br>    <span class="hljs-comment">// 逻辑...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用插件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">MyPlugin</span>, &#123; <span class="hljs-attr">someOption</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="vue-loader-是什么？使用它的用途有哪些？"><a href="#vue-loader-是什么？使用它的用途有哪些？" class="headerlink" title="vue-loader 是什么？使用它的用途有哪些？"></a>vue-loader 是什么？使用它的用途有哪些？</h3><p>解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。</p>
<p>用途：js 可以写 esstyle 样式可以 scss 或 less、template 可以加 jade 等</p>
<h3 id="聊聊你对-Vue-js-的-template-编译的理解？"><a href="#聊聊你对-Vue-js-的-template-编译的理解？" class="headerlink" title="聊聊你对 Vue.js 的 template 编译的理解？"></a>聊聊你对 Vue.js 的 template 编译的理解？</h3><p><strong>简而言之，就是先转化成 AST 树，再得到的 render 函数返回 VNode（Vue 的虚拟 DOM 节点）</strong></p>
<p>详情步骤：</p>
<p>首先，通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。</p>
<p>然后，AST 会经过 generate（将 AST 语法树转化成 render funtion 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有（标签名、子节点、文本等等）</p>
<h3 id="什么是-vue-生命周期？"><a href="#什么是-vue-生命周期？" class="headerlink" title="什么是 vue 生命周期？"></a>什么是 vue 生命周期？</h3><p>Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p>
<h3 id="vue-生命周期的作用是什么？"><a href="#vue-生命周期的作用是什么？" class="headerlink" title="vue 生命周期的作用是什么？"></a>vue 生命周期的作用是什么？</h3><p>它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。</p>
<h3 id="vue-生命周期总共有几个阶段？"><a href="#vue-生命周期总共有几个阶段？" class="headerlink" title="vue 生命周期总共有几个阶段？"></a>vue 生命周期总共有几个阶段？</h3><p>它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后</p>
<h3 id="第一次页面加载会触发哪几个钩子？"><a href="#第一次页面加载会触发哪几个钩子？" class="headerlink" title="第一次页面加载会触发哪几个钩子？"></a>第一次页面加载会触发哪几个钩子？</h3><p>第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子</p>
<h3 id="DOM-渲染在-哪个周期中就已经完成？"><a href="#DOM-渲染在-哪个周期中就已经完成？" class="headerlink" title="DOM 渲染在 哪个周期中就已经完成？"></a>DOM 渲染在 哪个周期中就已经完成？</h3><p>DOM 渲染在 mounted 中就已经完成了</p>
<h3 id="简单描述每个周期具体适合哪些场景？"><a href="#简单描述每个周期具体适合哪些场景？" class="headerlink" title="简单描述每个周期具体适合哪些场景？"></a>简单描述每个周期具体适合哪些场景？</h3><p>beforecreate : 可以在这加个 loading 事件，出现加载框效果</p>
<p>在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用</p>
<p>mounted : 挂载元素，获取到 DOM 节点</p>
<p>updated : 如果对数据统一处理，在这里写上相应函数</p>
<p>beforeDestroy : 可以做一个确认停止事件的确认框</p>
<p>nextTick : 更新数据后立即操作 dom</p>
<h3 id="vue-组件如何通信"><a href="#vue-组件如何通信" class="headerlink" title="vue 组件如何通信"></a>vue 组件如何通信</h3><ul>
<li>方式 1：父子通信<ul>
<li>父传子 ：自定义属性 props</li>
<li>子传父 ：自定义事件 <code>$emit</code></li>
</ul>
</li>
<li>方式 2：父子关系<ul>
<li>$parent,$root 等方式找到父组件或根节点去对应调用它的方法或者设置他的属性</li>
<li>$children,$refs 找到某个子组件直接调用他的方法或者设置他的属性</li>
</ul>
</li>
<li>方式 3： 祖先后代<ul>
<li>祖先组件定义 provide</li>
<li>所有的后代组件定义 inject 就可接收传递过来的数据</li>
</ul>
</li>
<li>方式 4： 任意两个组件（兄弟组件）<ul>
<li>通过事件主线： vue 本身就有 $on 和 $emit 方法。</li>
<li>A 组件中使用$on监听事件，B组件中通过$emit 触发事件</li>
</ul>
</li>
<li>方式 5： vuex</li>
<li>方式 6： 本地存储</li>
</ul>
<h3 id="说出-mount、-watch、-delete、-refs、-slots、-forceUpdate、-nextTick、-destroy-这些-API-方法或属性的的作用"><a href="#说出-mount、-watch、-delete、-refs、-slots、-forceUpdate、-nextTick、-destroy-这些-API-方法或属性的的作用" class="headerlink" title="说出$mount、$watch、$delete、$refs、$slots、$forceUpdate、$nextTick、$destroy 这些 API 方法或属性的的作用"></a>说出$mount、$watch、$delete、$refs、$slots、$forceUpdate、$nextTick、$destroy 这些 API 方法或属性的的作用</h3><ul>
<li><code>$mount</code> ：用于挂载 vue 实例到某个节点上面，功能类似 el 选项， 有了它可以不配置 el;</li>
<li><code>$watch</code>：用于监听数据的变化，功能类似内部配置选项 watch 一样的效果。</li>
<li><code>$delete</code>：用于删除 data 里面数据里面的对象的属性，可以实现响应式效果。 功能和<code>$set</code> 一致，只不过他是删除属性</li>
<li><code>$refs</code>：用于获取原生 DOM 节点，或者某个组件对象</li>
<li><code>$slot</code>： 用于获取当前组件传入的所有插槽内容</li>
<li><code>$forceUpdate</code>： 用于刷新当前组件或 vue 实例，它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</li>
<li><code>$nextTick</code>：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。【简单理解即使等到 DOM 渲染完成再做应该的逻辑操作】</li>
<li><code>$destroy()</code>：只是完全销毁一个实例。清理它与其它实例的连接，<strong>解绑它的全部指令及事件监听器。</strong></li>
</ul>
<h3 id="is-的用法（用于动态组件且基于-DOM-内模板的限制来工作。）"><a href="#is-的用法（用于动态组件且基于-DOM-内模板的限制来工作。）" class="headerlink" title="is 的用法（用于动态组件且基于 DOM 内模板的限制来工作。）"></a><strong>is 的用法（用于动态组件且基于 DOM 内模板的限制来工作。）</strong></h3><p><strong>is 用来动态切换组件，DOM 模板解析</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;table&gt;<br>  &#123;<span class="hljs-string">&#x27; &#x27;</span>&#125;<br>  &lt;tr is=<span class="hljs-string">&quot;my-row&quot;</span>&gt;&lt;/tr&gt;&#123;<span class="hljs-string">&#x27; &#x27;</span>&#125;<br>&lt;/table&gt;<br></code></pre></td></tr></table></figure>

<h3 id="vue-的两个核心是什么"><a href="#vue-的两个核心是什么" class="headerlink" title="vue 的两个核心是什么"></a>vue 的两个核心是什么</h3><p><strong>数据驱动、组件系统。</strong></p>
<blockquote>
<p>数据驱动:Object.defineProperty 和存储器属性: getter 和 setter（所以只兼容 IE9 及以上版本），可称为基于依赖收集的观测机制,核心是 VM，即 ViewModel，保证数据和视图的一致性。<br>组件系统:<a href="https://link.zhihu.com/?target=https://blog.csdn.net/tangxiujiang/article/details/79620542%23commentBox">点此查看</a></p>
</blockquote>
<h3 id="vue-的-render-函数式什么？如何使用"><a href="#vue-的-render-函数式什么？如何使用" class="headerlink" title="vue 的 render 函数式什么？如何使用"></a>vue 的 render 函数式什么？如何使用</h3><p>Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用<strong>渲染函数</strong>，它比模板更接近编译器。 <strong>无论 el 也好，template 最终都是通过 render 函数渲染，而且如果同时存在三者，render 函数权重最大！</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">render</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">createElement</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;标签名&#x27;</span>,&#123; 属性描述 &#125;,子元素)<br>&#125;<br><br><span class="hljs-comment">// createElement  表示创建虚拟元素</span><br><span class="hljs-comment">// createElement(&#x27;标签名&#x27;,&#123; 属性描述 &#125;,子元素)</span><br><br><br>属性描述包括：<br><span class="hljs-comment">// 与 `v-bind:class` 的 API 相同，</span><br>  <span class="hljs-comment">// 接受一个字符串、对象或字符串和对象组成的数组</span><br>  <span class="hljs-string">&#x27;class&#x27;</span>: &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-literal">false</span><br>  &#125;,<br>  <span class="hljs-comment">// 与 `v-bind:style` 的 API 相同，</span><br>  <span class="hljs-comment">// 接受一个字符串、对象，或对象组成的数组</span><br>  <span class="hljs-attr">style</span>: &#123;<br>    <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>    <span class="hljs-attr">fontSize</span>: <span class="hljs-string">&#x27;14px&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 普通的 HTML attribute</span><br>  <span class="hljs-attr">attrs</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;foo&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 组件 prop</span><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">myProp</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// DOM property</span><br>  <span class="hljs-attr">domProps</span>: &#123;<br>    <span class="hljs-attr">innerHTML</span>: <span class="hljs-string">&#x27;baz&#x27;</span><br>  &#125;,<br>  <span class="hljs-comment">// 事件监听器在 `on` 内，</span><br>  <span class="hljs-comment">// 但不再支持如 `v-on:keyup.enter` 这样的修饰器。</span><br>  <span class="hljs-comment">// 需要在处理函数中手动检查 keyCode。</span><br>  <span class="hljs-attr">on</span>: &#123;<br>    <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">clickHandler</span><br>  &#125;,<br>  <span class="hljs-comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用</span><br>  <span class="hljs-comment">// `vm.$emit` 触发的事件。</span><br>  <span class="hljs-attr">nativeOn</span>: &#123;<br>    <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">nativeClickHandler</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>案例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;box&#x27;</span>,&#123;<br>  <span class="hljs-attr">template</span>:<span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div class=&quot;width:200px;height:200px;background-color:red&quot;&gt;</span><br><span class="hljs-string">      &lt;h2 class=&#x27;title&#x27; id=&#x27;tit&#x27;&gt;我是标题&lt;/h2&gt;</span><br><span class="hljs-string">      &lt;p&gt;</span><br><span class="hljs-string">        &lt;button @click=&#x27;del&#x27;&gt;减少&lt;/button&gt;</span><br><span class="hljs-string">        &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br><span class="hljs-string">        &lt;button @click=&#x27;add(2)&#x27;&gt;增加&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/p&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">	`</span><br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;<br>  	<span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>:<span class="hljs-number">1</span><br>    &#125;<br>	&#125;,<br>  <span class="hljs-attr">methods</span>:&#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">val</span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>+=val<br>    &#125;,<br>    <span class="hljs-title function_">del</span>(<span class="hljs-params"></span>)&#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>--<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>通过 render 实现</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;box&#x27;</span>, &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-number">1</span>,<br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">add</span>(<span class="hljs-params">val</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> += val;<br>    &#125;,<br>    <span class="hljs-title function_">del</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>--;<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params">h</span>) &#123;<br>    <span class="hljs-comment">// 创建div，且返回</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<br>      <span class="hljs-string">&#x27;div&#x27;</span>,<br>      &#123;<br>        <span class="hljs-attr">style</span>: &#123;<br>          <span class="hljs-attr">width</span>: <span class="hljs-string">&#x27;200px&#x27;</span>,<br>          <span class="hljs-attr">height</span>: <span class="hljs-string">&#x27;200px&#x27;</span>,<br>          <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;red&#x27;</span>,<br>        &#125;,<br>      &#125;,<br>      [<br>        <span class="hljs-comment">// 创建h2</span><br>        <span class="hljs-title function_">h</span>(<br>          <span class="hljs-string">&#x27;h2&#x27;</span>,<br>          &#123;<br>            <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;title&#x27;</span>,<br>            <span class="hljs-attr">attrs</span>: &#123;<br>              <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;tit&#x27;</span>,<br>            &#125;,<br>          &#125;,<br>          <span class="hljs-string">&#x27;我是标题&#x27;</span><br>        ),<br>        <span class="hljs-comment">// 创建p</span><br>        <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;p&#x27;</span>, &#123;&#125;, [<br>          <span class="hljs-comment">// 创建button</span><br>          <span class="hljs-title function_">h</span>(<br>            <span class="hljs-string">&#x27;button&#x27;</span>,<br>            &#123;<br>              <span class="hljs-attr">on</span>: &#123;<br>                <span class="hljs-attr">click</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">del</span>,<br>              &#125;,<br>            &#125;,<br>            <span class="hljs-string">&#x27;减少&#x27;</span><br>          ),<br>          <span class="hljs-comment">// 创建span</span><br>          <span class="hljs-title function_">h</span>(<span class="hljs-string">&#x27;span&#x27;</span>, &#123;&#125;, <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>),<br>          <span class="hljs-comment">// 创建button</span><br>          <span class="hljs-title function_">h</span>(<br>            <span class="hljs-string">&#x27;button&#x27;</span>,<br>            &#123;<br>              <span class="hljs-attr">on</span>: &#123;<br>                <span class="hljs-attr">click</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>                  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">add</span>(<span class="hljs-number">2</span>);<br>                &#125;,<br>              &#125;,<br>            &#125;,<br>            <span class="hljs-string">&#x27;增加&#x27;</span><br>          ),<br>        ]),<br>      ]<br>    );<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/7508d2a114d3">https://www.jianshu.com/p/7508d2a114d3</a></strong></p>
<h3 id="使用-key-要什么要注意的吗？"><a href="#使用-key-要什么要注意的吗？" class="headerlink" title="使用 key 要什么要注意的吗？"></a>使用 key 要什么要注意的吗？</h3><ul>
<li><p>不要使用对象或数组之类的非基本类型值作为 key，请用字符串或数值类型的值；</p>
</li>
<li><p>不要使用数组的 index 作为 key 值，因为在删除数组某一项，index 也会随之变化，导致 key 变化，渲染会出错。</p>
</li>
</ul>
<p>例：在渲染<code>[a,b,c]</code>用 index 作为 key，那么在删除第二项的时候，index 就会从 0 1 2 变成 0 1（而不是 0 2)，随之第三项的 key 变成 1 了，就会误把第三项删除了。</p>
<h3 id="组件的-name-选项有什么作用？"><a href="#组件的-name-选项有什么作用？" class="headerlink" title="组件的 name 选项有什么作用？"></a>组件的 name 选项有什么作用？</h3><ul>
<li>递归组件时，组件调用自身使用；</li>
<li>用<code>is</code>特殊特性和<code>component</code>内置组件标签时使用；</li>
<li><code>keep-alive</code>内置组件标签中<code>include </code>和<code>exclude</code>属性中使用。</li>
</ul>
<h3 id="什么是递归组件？举个例子说明下？"><a href="#什么是递归组件？举个例子说明下？" class="headerlink" title="什么是递归组件？举个例子说明下？"></a>什么是递归组件？举个例子说明下？</h3><p>递归引用可以理解为组件调用自身，在开发多级菜单组件时就会用到，调用前要先设置组件的 name 选项， <strong>注意一定要配合 v-if 使用，避免形成死循环</strong>，用 element-vue 组件库中 NavMenu 导航菜单组件开发多级菜单为例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">el-submenu</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;menu.id&quot;</span> <span class="hljs-attr">popper-class</span>=<span class="hljs-string">&quot;layout-sider-submenu&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;menu.id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span> <span class="hljs-attr">:type</span>=<span class="hljs-string">&quot;menu.icon&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;menu.icon&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; menu.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(child, i) in menu.menus&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">side-menu-item</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;Array.isArray(child.menus) &amp;&amp; child.menus.length&quot;</span> <span class="hljs-attr">:menu</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">side-menu-item</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">el-menu-item</span> <span class="hljs-attr">:index</span>=<span class="hljs-string">&quot;child.id&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;child.id&quot;</span> <span class="hljs-attr">v-else</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Icon</span> <span class="hljs-attr">:type</span>=<span class="hljs-string">&quot;child.icon&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;child.icon&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; child.title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">el-menu-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">el-submenu</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;sideMenuItem&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">menu</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">default</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> &#123;&#125;;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="说下-attrs和-listeners的使用场景？"><a href="#说下-attrs和-listeners的使用场景？" class="headerlink" title="说下$attrs和$listeners的使用场景？"></a>说下<code>$attrs</code>和<code>$listeners</code>的使用场景？</h3><p><code>$attrs</code>: 包含了父作用域中（组件标签）不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 在创建基础组件时候经常使用，可以和组件选项<code>inheritAttrs:false</code>和配合使用在组件内部标签上用<code>v-bind=&quot;$attrs&quot;</code>将非 prop 特性绑定上去；</p>
<p><code>$listeners</code>: 包含了父作用域中（组件标签）的 (不含<code>.native</code>) v-on 事件监听器。 在组件上监听一些特定的事件，比如 focus 事件时，如果组件的根元素不是表单元素的，则监听不到，那么可以用<code>v-on=&quot;$listeners&quot;</code>绑定到表单元素标签上解决。</p>
<h3 id="EventBus-注册在全局上时，路由切换时会重复触发事件，如何解决呢？"><a href="#EventBus-注册在全局上时，路由切换时会重复触发事件，如何解决呢？" class="headerlink" title="EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢？"></a>EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢？</h3><p>在有使用<code>$on</code>的组件中要在<code>beforeDestroy</code>钩子函数中用<code>$off</code>销毁。</p>
<h3 id="Vue-怎么改变插入模板的分隔符？"><a href="#Vue-怎么改变插入模板的分隔符？" class="headerlink" title="Vue 怎么改变插入模板的分隔符？"></a>Vue 怎么改变插入模板的分隔符？</h3><p>用<code>delimiters</code>选项,其默认是<code>[&quot;&#123;&#123;", "&#125;&#125;&quot;]</code></p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 将分隔符变成ES6模板字符串的风格</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  delimiters: [<span class="hljs-string">&#x27;<span class="hljs-subst">$&#123;<span class="hljs-string">&#x27;, &#x27;</span>&#125;</span>&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="Vue-变量名如果以-、-开头的属性会发生什么问题？怎么访问到它们的值？"><a href="#Vue-变量名如果以-、-开头的属性会发生什么问题？怎么访问到它们的值？" class="headerlink" title="Vue 变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？"></a>Vue 变量名如果以<code>_</code>、<code>$</code>开头的属性会发生什么问题？怎么访问到它们的值？</h3><p>以 <code>_ </code>或 <code>$</code> 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突，你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>
<h3 id="怎么捕获-Vue-组件的错误信息？"><a href="#怎么捕获-Vue-组件的错误信息？" class="headerlink" title="怎么捕获 Vue 组件的错误信息？"></a>怎么捕获 Vue 组件的错误信息？</h3><ul>
<li><p><code>errorCaptured</code>是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收<code>error</code>、<code>vm</code>、<code>info</code>三个参数，<code>return false</code>后可以阻止错误继续向上抛出。</p>
</li>
<li><p><code>errorHandler</code>为全局钩子，使用<code>Vue.config.errorHandler</code>配置，接收参数与<code>errorCaptured</code>一致，2.6 后可捕捉<code>v-on</code>与<code>promise</code>链的错误，可用于统一错误处理与错误兜底。</p>
</li>
</ul>
<h3 id="Vue-项目中如何配置-favicon？"><a href="#Vue-项目中如何配置-favicon？" class="headerlink" title="Vue 项目中如何配置 favicon？"></a>Vue 项目中如何配置 favicon？</h3><ul>
<li>静态配置 <code>&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;</code>,</li>
</ul>
<p>其中<code>&lt;%= BASE_URL %&gt;</code>等同 vue.config.js 中<code>publicPath</code>的配置;</p>
<ul>
<li><p>动态配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;link <span class="hljs-attribute">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">&quot;&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> browserImg <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;images/kong.png&#x27;</span>; <span class="hljs-comment">//为favicon的默认图片</span><br><br><span class="hljs-keyword">const</span> imgurl = <span class="hljs-string">&#x27;后端传回来的favicon.ico的线上地址&#x27;</span>;<br><span class="hljs-keyword">let</span> link = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;link[type=&quot;image/png&quot;]&#x27;</span>);<br><span class="hljs-keyword">if</span> (imgurl) &#123;<br>  link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>, imgurl);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  link.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;href&#x27;</span>, browserImg);<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Vue-为什么要求组件模板只能有一个根元素？"><a href="#Vue-为什么要求组件模板只能有一个根元素？" class="headerlink" title="Vue 为什么要求组件模板只能有一个根元素？"></a>Vue 为什么要求组件模板只能有一个根元素？</h3><p>当前的 virtualDOM 差异和 diff 算法在很大程度上依赖于每个子组件总是只有一个根元素。</p>
<h3 id="说说你对单向数据流和双向数据流的理解"><a href="#说说你对单向数据流和双向数据流的理解" class="headerlink" title="说说你对单向数据流和双向数据流的理解"></a>说说你对单向数据流和双向数据流的理解</h3><p>单向数据流是指数据只能从父级向子级传递数据，子级不能改变父级向子级传递的数据。</p>
<p>双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。</p>
<p>比如用<code>v-model</code>、<code>.sync</code>来实现双向数据流。</p>
<h2 id="二、vue-router"><a href="#二、vue-router" class="headerlink" title="二、vue-router"></a>二、vue-router</h2><h3 id="vue-route-如何使用？"><a href="#vue-route-如何使用？" class="headerlink" title="vue-route 如何使用？"></a>vue-route 如何使用？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 【安装 】</span><br>npm i vue-router<br><span class="hljs-comment">// 【配置】</span><br><span class="hljs-comment">// src/router/index.js 创建配置文件</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Router</span>  <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue-router&quot;</span><br><span class="hljs-comment">// 安装</span><br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Router</span>)<br><span class="hljs-comment">// 定义路由映射</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/地址&quot;</span>,<span class="hljs-attr">component</span>:<span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;组件位置路径&#x27;</span>)<br>  &#125;<br>]<br><span class="hljs-comment">// 创建路由实例</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  routes,<br>&#125;)<br><span class="hljs-comment">// 暴露</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br><span class="hljs-comment">// 【注入vue实例】</span><br><span class="hljs-comment">// main.js中操作</span><br>...<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br>...<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  ...,<br>  router,  <span class="hljs-comment">// 一旦注入，所有组件中都有$router和$route; $router表示路由对象实例； $route表示当前页面路由信息</span><br>  ...<br>&#125;)<br><br><span class="hljs-comment">// 【定义路由出口】</span><br><span class="hljs-comment">// App.vue中操作</span><br>&lt;router-view&gt;&lt;/router-view&gt;<br><br><span class="hljs-comment">// 【使用router-link跳转】</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="何为命名路由？"><a href="#何为命名路由？" class="headerlink" title="何为命名路由？"></a>何为命名路由？</h3><ul>
<li><p>其实就是给路由取一个名字,增加一个 name 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 映射关系</span><br><span class="hljs-keyword">const</span> routes = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;名称&#x27;</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/地址&#x27;</span>, <span class="hljs-attr">component</span>: 组件 &#125;];<br></code></pre></td></tr></table></figure>

<p>定义了命名路由，那么就可以通过路由名称实现跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">// 原来写法<br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/地址&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>// 新写法<br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123;name:&#x27;名称&#x27;&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br>// 编程式导航 router.push(&#x27;/地址&#x27;) router.push(&#123;name:&#x27;名称&#x27;&#125;)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如何定义动态路由，获取动态参数"><a href="#如何定义动态路由，获取动态参数" class="headerlink" title="如何定义动态路由，获取动态参数"></a>如何定义动态路由，获取动态参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 映射关系</span><br><span class="hljs-keyword">const</span> routes = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;名称&#x27;</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/地址/:标识符&#x27;</span>, <span class="hljs-attr">component</span>: 组件 &#125;];<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/地址/数据&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;名称&#x27;, params: &#123; 标识符: 数据 &#125; &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br>// 编程式导航 router.push(&#x27;/地址/数据&#x27;) router.push(&#123;name:&#x27;名称&#x27;,params:&#123;标识符:数据&#125;&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>获取动态参数</strong></p>
<p><strong><code>this.$route.params.</code>标识符 得到 数据</strong></p>
<hr>
<p><strong>但是这里我们有更加高级的用法，使用 props 将组件解耦</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 映射关系</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;名称&#x27;</span>, <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/地址/:标识符&#x27;</span>, <span class="hljs-attr">component</span>: 组件, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-comment">// // 开启props传参，说白了将路由参数传递到组件的props中</span><br>];<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 组件中，下面是组件的配置选型 export default &#123; ..., props:[&#x27;标识符&#x27;] //</span><br>props定义和动态路由后面标识符一致的定义属性。 ... &#125; <span class="hljs-comment">// 组件中可以直接通过</span><br><span class="hljs-variable language_">this</span>.标识符 直接获得路由参数数据。<br></code></pre></td></tr></table></figure>

<p><strong>如案例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由配置</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">User</span>,<br>      <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// A页面</span><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/user/123&#x27;</span>)<br>或者<br>&lt;router-link to=<span class="hljs-string">&#x27;/user&#x27;</span>&gt;去user页面&lt;/router-link&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// User页面</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;id&#x27;</span>], <span class="hljs-comment">// this.id 就是动态路由数据值为 123</span><br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;</span>, <span class="hljs-comment">// 这里就是会渲染123</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="有哪些编程式导航方法"><a href="#有哪些编程式导航方法" class="headerlink" title="有哪些编程式导航方法"></a>有哪些编程式导航方法</h3><ul>
<li>编程式导航方法都存在 路由实例里面。 组件中可以使用<code>this.$router</code>访问，其他 JS 文件中可以通过导入路由实例调用<ul>
<li><code>this.$router.push(&#39;/地址&#39;)</code> 跳转到某个新地址，历史记录栈中增加一个</li>
<li><code>this.$router.replace(&#39;/地址&#39;)</code> 跳转到某个地址，新地址替换当前地址在历史记录中的位置</li>
<li><code>this.$router.go(数字)</code> 正数前进几步；负数后退几步；0 表示刷新</li>
<li><code>this.$router.back()</code> 后退</li>
<li><code>this.$router.forward()</code> 前进</li>
</ul>
</li>
</ul>
<h3 id="何为命名视图？如何使用"><a href="#何为命名视图？如何使用" class="headerlink" title="何为命名视图？如何使用"></a>何为命名视图？如何使用</h3><ul>
<li><p>所谓的命名视图的意思是默认情况下我们一个路由地址渲染一个组件到一个 router-view 里面去；而命名视图的目的是 <strong>可以实现一个路由地址，渲染多个组件到不同的 router-view 里去进行展示</strong></p>
</li>
<li><p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 映射关系</span><br><span class="hljs-keyword">const</span> routes = [<br>	&#123;<br>		<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;名称&#x27;</span> ,<br>		<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/地址&#x27;</span>,<br>		<span class="hljs-comment">//component:组件    //只能渲染一个组件</span><br>        <span class="hljs-attr">components</span>:&#123;<br>            <span class="hljs-attr">default</span>:组件X<br>            视图名<span class="hljs-attr">A</span>:组件A,<br>            视图名<span class="hljs-attr">B</span>:组件B<br>        &#125;<br>	&#125;<br>]<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-comment">&lt;!--默认视图，渲染组件X--&gt;</span><br>上面这句其实是：<br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;视图名A&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-comment">&lt;!--渲染组件A--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;视图名B&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-comment">&lt;!--渲染组件B--&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="何为嵌套路由？-如何使用？何时使用？"><a href="#何为嵌套路由？-如何使用？何时使用？" class="headerlink" title="何为嵌套路由？ 如何使用？何时使用？"></a>何为嵌套路由？ 如何使用？何时使用？</h3><ul>
<li><p>定义：所谓的嵌套路由，指的的是在一个路由组件里面还有会有 router-view 展示下一级的路由组件信息。</p>
</li>
<li><p>何时使用：我们开发一些特定功能模块的时候，包含有子模块页面，就可以采用嵌套路由。 如：用户中心是一个大模块页面，用户订单、用户资料、收货地址等等都会有侧边栏信息，诸如此类有共同模块布局，且内容不同的，则可以使用嵌套路由。</p>
<img src="/img/vue-interview/008.png" style="zoom:100%;" />
</li>
<li><p>如何使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 映射关系</span><br><span class="hljs-keyword">const</span> routes = [<br>	&#123;<br>		<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;名称&#x27;</span> ,<br>		<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/地址&#x27;</span>,<br>		<span class="hljs-attr">component</span>:组件<br> 		<span class="hljs-attr">children</span>:[   <span class="hljs-comment">// 子级路由会渲染上级路由的组件里面的router-view里面进行展示</span><br> 			&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;名称1&#x27;</span>, <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/地址/子地址1&quot;</span>,  <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址) &#125;,<br> 			&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;名称2&#x27;</span>, <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;/地址/子地址2&quot;</span>,  <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址) &#125;,<br>            <span class="hljs-comment">// 子级的地址也可以不加  /地址，  这样会自动拼接 上一级的前缀。 注意不能加 /</span><br> 			&#123; <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;名称3&#x27;</span>, <span class="hljs-attr">path</span>:<span class="hljs-string">&quot;子地址3&quot;</span>,  <span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址) &#125;<br>			<span class="hljs-comment">// 上述  path就单独写一个  子地址3  就表示   /地址/子地址3</span><br> 		]<br>	&#125;<br>]<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="怎么通过路由实现面包屑"><a href="#怎么通过路由实现面包屑" class="headerlink" title="怎么通过路由实现面包屑"></a>怎么通过路由实现面包屑</h3><ul>
<li><p>认识面包屑</p>
<p><img src="/img/vue-interview/009.png"></p>
</li>
<li><p>前后端分离实现面包屑有 2 中方式：</p>
<ul>
<li>方式 1： 每个页面直接写死</li>
<li>方式 2： 通过<code>$route.matched</code> 属性 去遍历 生成。</li>
</ul>
</li>
<li><p>方式 2 实现思路：</p>
<ul>
<li>要有面包屑一般肯定要是一个嵌套路由，否则一般就只能展示 2 级。</li>
<li>每个路由都要有 meta 元信息， 然后里面设置一个 tilte，设置为标题。</li>
<li>我们的<code>$route</code> 表示当前页面路由信息，如果是一个嵌套路由，那么<code>$route.matched</code> 属性是一个数组，里面的内容就是一个上上级到下一级的路由信息，我们可以通过遍历数组，取出每个里面的 path 地址和 meta 里面的 title 来进行设置即可。</li>
</ul>
</li>
</ul>
<h3 id="页面之间如何传参"><a href="#页面之间如何传参" class="headerlink" title="页面之间如何传参"></a>页面之间如何传参</h3><ul>
<li>本地存储，一个页面设置，一个页面读取</li>
<li>动态路由<ul>
<li>/地址/数据 【A 页面】</li>
<li><code>this.$route.params.</code>标识符 获取数据 【B 页面】</li>
</ul>
</li>
<li>query 传参<ul>
<li>/地址?属性名=值 【A 页面】</li>
<li><code>this.$route.query.</code>属性名 【B 页面】</li>
</ul>
</li>
<li>hash 传参<ul>
<li>/地址#属性名=值 【A 页面】</li>
<li><code>this.$route.hash</code> 然后再处理得到信息 【B 页面】</li>
</ul>
</li>
<li>vue 存储和读取</li>
</ul>
<h3 id="vue-router-有哪几种导航钩子？"><a href="#vue-router-有哪几种导航钩子？" class="headerlink" title="vue-router 有哪几种导航钩子？"></a>vue-router 有哪几种导航钩子？</h3><p>三种</p>
<p>第一种是全局导航钩子：</p>
<ul>
<li><code>router.beforeEach( (to,from,next)=&gt;&#123; ... &#125; )</code></li>
<li><code>router.afterEach((to, from) =&gt; &#123; ... &#125;)</code></li>
</ul>
<p>第二种：组件内的钩子</p>
<ul>
<li><code>beforeRouteEnter(to, from, next) &#123; ... &#125;</code></li>
<li><code>beforeRouteUpdate (to, from, next) &#123;...&#125;</code></li>
<li><code>beforeRouteLeave (to, from, next) &#123;...&#125;</code></li>
</ul>
<p>第三种：单独路由独享组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/foo&#x27;</span>,<br>      <span class="hljs-attr">component</span>: <span class="hljs-title class_">Foo</span>,<br>      <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 配置在路由映射里面</span><br>        <span class="hljs-comment">// ...</span><br>      &#125;,<br>    &#125;,<br>  ],<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="route和-router-的区别"><a href="#route和-router-的区别" class="headerlink" title="$route和$router 的区别"></a>$route和$router 的区别</h3><ul>
<li><code>$route</code> 是“<strong>路由信息</strong>对象”<ul>
<li>path 路径地址</li>
<li>params 动态路由数据</li>
<li>hash hash 数据</li>
<li>query search 数据</li>
<li>fullPath 完整地址</li>
<li>matched 路由匹配 （可用于制作面包屑）</li>
<li>name 路由名称</li>
</ul>
</li>
<li><code>$router</code> 是“<strong>路由实例</strong>”对象包括了路由的跳转方法，钩子函数等<ul>
<li>push/replace/go/back/forward</li>
<li>beforeEach/afterEach/…</li>
<li>addRoutes 方法，增加映射</li>
</ul>
</li>
</ul>
<h3 id="路由元信息是什么？有何作用？"><a href="#路由元信息是什么？有何作用？" class="headerlink" title="路由元信息是什么？有何作用？"></a>路由元信息是什么？有何作用？</h3><ul>
<li><p>设置每个路由映对象的时候，可以增加一个 meta 属性，里面可以自定义相关数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由映射</span><br>&#123;<br>	<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/地址&#x27;</span>,<br>	<span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址),<br>	<span class="hljs-attr">meta</span>:&#123;<br>	 	属性名:<span class="hljs-string">&quot;属性值&quot;</span>,<br>	 	....<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>组件中读取： <strong><code>this.$route.meta.属性名</code></strong></p>
</li>
<li><p>作用：</p>
<ul>
<li>可以通过这个设置标题，在拦截器里面进行设置；</li>
<li>meta 里面放入权限验证字段，判断是否有权限访问页面</li>
<li>…</li>
</ul>
</li>
</ul>
<h3 id="如何实现页面的过渡效果"><a href="#如何实现页面的过渡效果" class="headerlink" title="如何实现页面的过渡效果"></a>如何实现页面的过渡效果</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="如何实现路由重定向"><a href="#如何实现路由重定向" class="headerlink" title="如何实现路由重定向"></a>如何实现路由重定向</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由映射</span><br>&#123;<br>	<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/地址A&#x27;</span>,<br>	<span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址),<br>	<span class="hljs-attr">redirect</span>:<span class="hljs-string">&#x27;/地址B&#x27;</span>    <span class="hljs-comment">// 访问地址A的时候将会跳转到地址B</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="路由懒加载是什么？-如何实现？为什么要懒加载？"><a href="#路由懒加载是什么？-如何实现？为什么要懒加载？" class="headerlink" title="路由懒加载是什么？ 如何实现？为什么要懒加载？"></a>路由懒加载是什么？ 如何实现？为什么要懒加载？</h3><ul>
<li><p>为什么： 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然<strong>后当路由被访问的时候才加载对应组件，这样就更加高效了。</strong></p>
</li>
<li><p>是什么：<strong>路由被访问的时候才加载对应组件</strong></p>
</li>
<li><p>如何实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由映射</span><br>&#123;<br>	<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;/地址A&#x27;</span>,<br>	<span class="hljs-attr">component</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">import</span>(组件地址)   <span class="hljs-comment">// 懒加载</span><br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="导航钩子有何作用？"><a href="#导航钩子有何作用？" class="headerlink" title="导航钩子有何作用？"></a>导航钩子有何作用？</h3><ul>
<li>导航钩子类似中间件的味道，对导航的发生过程进行拦截，满足条件才可以继续向下走，否则路由就会被挂起来。 所以我们很多时候需要注意是否需要在导航守卫里面调用 next</li>
<li>全局前置守卫：（<code>router.beforeEach((to, from, next) =&gt; &#123; ... &#125;</code>）<ul>
<li>权限判断、标题设置、进度条开始 等，需要所有路由都做的事情</li>
</ul>
</li>
<li>全局守后置守卫：（<code>router.afterEach((to, from) =&gt; &#123;...&#125;</code>）<ul>
<li>进度条结束等</li>
</ul>
</li>
<li>路由独享守卫：（ <code>beforeEnter: (to, from, next) =&gt; &#123; ... &#125;</code>）<ul>
<li>权限判断、针对某一个路由要做的事情都放在这里。</li>
</ul>
</li>
<li>局部前置守卫: （<code>beforeRouteEnter (to, from, next) &#123; ... &#125;</code>）<ul>
<li>进入页面之前要做的事情，注意这里不能使用 this，因为组件还没有初始化</li>
</ul>
</li>
<li>局部更新守卫： （<code>beforeRouteUpdate (to, from, next) &#123; ... &#125;</code>）<ul>
<li>同路由跳转同路由的更新监测，<strong>如详情页跳转到详情页，可以放在这里监听</strong></li>
</ul>
</li>
<li>局部后置守卫： （<code>beforeRouteLeave (to, from, next) &#123; ... &#125;</code>）<ul>
<li>某个页面要消失的时候做的事情，如判断是否要离开，是否保存了数据等。</li>
</ul>
</li>
</ul>
<h3 id="如何实现激活导航"><a href="#如何实现激活导航" class="headerlink" title="如何实现激活导航"></a>如何实现激活导航</h3><ul>
<li><p>默认如果<code>router-link</code>组件的地址和当前路由地址一致，会加上<code>router-link-active</code>的 class 名（这是模糊匹配）或者 <code>router-link-exact-active</code>的 class 名（这是严格匹配）</p>
</li>
<li><p>修改激活 class 名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由中配置</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>	<span class="hljs-attr">linkActiveClass</span>:<span class="hljs-string">&#x27;class名&#x27;</span>,      <span class="hljs-comment">// 非严格模式下的激活class名</span><br>	<span class="hljs-attr">linkExactActiveClass</span>:<span class="hljs-string">&#x27;class名&#x27;</span>, <span class="hljs-comment">// 严格模式的激活的时候class名</span><br>	<span class="hljs-attr">routes</span>:[...]   <span class="hljs-comment">// 映射</span><br>&#125;)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="有哪些路由模式？-实现的具体原理是什么？"><a href="#有哪些路由模式？-实现的具体原理是什么？" class="headerlink" title="有哪些路由模式？ 实现的具体原理是什么？"></a>有哪些路由模式？ 实现的具体原理是什么？</h3><ul>
<li>路由模式 2 中：<ul>
<li>history 模式 原理： html5 的 <code>history</code> 里面的 api， 如 <code>pushState</code>,<code>replaceState</code> 这 2 个函数可以替换网页中的 url，但是页面不会重新加载</li>
<li>hash 模式 原理： 监听 window 的 <code>hashchange</code> 事件，展示不同组件</li>
<li>监听 popstate，<code>pushState</code>和<code>replaceState</code>不会触发<code>popState</code>事件，只有浏览器的返回按钮，<code>go</code>、<code>back</code>函数会触发</li>
</ul>
</li>
</ul>
<h3 id="history-模式路由要注意什么？"><a href="#history-模式路由要注意什么？" class="headerlink" title="history 模式路由要注意什么？"></a>history 模式路由要注意什么？</h3><ul>
<li><p>如果不想要很丑的 hash，我们可以用路由的 <strong>history 模式</strong>，这种模式充分利用 <code>history.pushState</code> API 来完成 URL 跳转而无须重新加载页面。</p>
</li>
<li><p>注意点：不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <code>http://oursite.com/user/id</code> 就会返回 404，这就不好看了。</p>
<p>所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 <code>index.html</code> 页面，这个页面就是你 app 依赖的页面</p>
</li>
<li><p><strong>简而言之： history 模式需要后台配置，否则会和真正的服务器端路由地址冲突。</strong></p>
</li>
</ul>
<h3 id="addRoutes-方法是什么？有何作用？"><a href="#addRoutes-方法是什么？有何作用？" class="headerlink" title="addRoutes 方法是什么？有何作用？"></a>addRoutes 方法是什么？有何作用？</h3><ul>
<li><p>是什么：动态添加更多的路由规则。参数必须是一个符合 <code>routes</code> 选项要求的数组。</p>
</li>
<li><p>作用： 可以实现根据需求动态加载路由配置映射关系数据信息，我们一般在<strong>管理系统中，通过这个方法来实现 按需加载路由映射，从而实现不同的角色看到不同的菜单。</strong></p>
</li>
</ul>
<h3 id="base-配置项的作用"><a href="#base-配置项的作用" class="headerlink" title="base 配置项的作用"></a>base 配置项的作用</h3><ul>
<li><p>配置路由地址的基准前缀地址，增加这个选项之后所有的路由地址会全部自动增加上这个前缀，但是我们写<code>router-link</code> 的时候不需要加这个前缀。</p>
</li>
<li><p>使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 路由中配置</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>	<span class="hljs-attr">base</span>:<span class="hljs-string">&quot;/前缀地址&quot;</span><br>	<span class="hljs-attr">routes</span>:[...]   <span class="hljs-comment">// 映射</span><br>&#125;)<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如何处理滚动行为"><a href="#如何处理滚动行为" class="headerlink" title="如何处理滚动行为"></a>如何处理滚动行为</h3><ul>
<li><p><strong>history 模式下</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>	...,<br>     <span class="hljs-comment">// savedPosition 这个参数当且仅当导航 (通过浏览器的 前进/后退 按钮触发) 时才可用  效果和 router.go() 或 router.back()</span><br>	<span class="hljs-title function_">scrollBehavior</span> (to, <span class="hljs-keyword">from</span>, savedPosition) &#123;<br>      <span class="hljs-comment">// 返回savedPosition 其实就是 当用户点击 返回的话，保持之前游览的高度</span><br>      <span class="hljs-keyword">if</span> (savedPosition) &#123;<br>        <span class="hljs-keyword">return</span> savedPosition<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> &#125;<br>      &#125;<br>    &#125;,<br>    ...<br>&#125;)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：scrollBehavior 属性仅在 history 模式下才可以使用。</p>
</blockquote>
</li>
<li><p><strong>hash 模式下</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 直接使用window的scroll方法滚动回顶部</span><br>  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="路由里面有哪些常用组件"><a href="#路由里面有哪些常用组件" class="headerlink" title="路由里面有哪些常用组件"></a>路由里面有哪些常用组件</h3><ul>
<li><p><code>router-link</code></p>
</li>
<li><p><code>router-view</code></p>
</li>
</ul>
<h3 id="路由里面详情页跳转详情页，组件不重新创建如何处理？"><a href="#路由里面详情页跳转详情页，组件不重新创建如何处理？" class="headerlink" title="路由里面详情页跳转详情页，组件不重新创建如何处理？"></a>路由里面详情页跳转详情页，组件不重新创建如何处理？</h3><ul>
<li>我们的<code>vue-router</code>同路由跳转到同路由，组件是不会更新的。 如：文章详情路由<code>/article/11</code> 页面里面有个链接跳转到<code>/article/22</code> 这篇文章，其实就是同路由组件跳转。这个时候文章详情组件是不会再次被创建的，所以我们不能把获取数据请求的方法写在 <code>created</code>或者 <code>mounted</code>里面或者在里面去调用，因为组件不会被再次创建，如果写在生命周期里面去调用，从而导致跳转到<code>/article/22</code>的时候无法请求数据，</li>
<li>如何解决：<ul>
<li>方式 1：使用 <code>beforeRouteUpdate</code>，因为<code>/article/11</code>跳转到<code>/article/22</code> 这个跳转属于同路由组件更新，<code>beforeRouteUpdate</code>会被触发</li>
<li>方式 2： 使用<code>watch</code>去监听<code>$route</code>的变化，在监听的函数里面去发送请求。</li>
</ul>
</li>
</ul>
<h3 id="如何实现页面加载进度条"><a href="#如何实现页面加载进度条" class="headerlink" title="如何实现页面加载进度条"></a>如何实现页面加载进度条</h3><p><strong>核心使用：<code>nprogress</code>插件</strong></p>
<ul>
<li>第一步， 安装</li>
</ul>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save nprogress</span><br></code></pre></td></tr></table></figure>

<ul>
<li>第二步， main.js 中引入插件</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">NProgress</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nprogress&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;nprogress/nprogress.css&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>第三步，在 main.js 文件配置插件的功能</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">configure</span>(&#123;<br>  <span class="hljs-attr">easing</span>: <span class="hljs-string">&#x27;ease&#x27;</span>, <span class="hljs-comment">// 动画方式</span><br>  <span class="hljs-attr">speed</span>: <span class="hljs-number">500</span>, <span class="hljs-comment">// 递增进度条的速度</span><br>  <span class="hljs-attr">showSpinner</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 是否显示加载ico</span><br>  <span class="hljs-attr">trickleSpeed</span>: <span class="hljs-number">200</span>, <span class="hljs-comment">// 自动递增间隔</span><br>  <span class="hljs-attr">minimum</span>: <span class="hljs-number">0.3</span>, <span class="hljs-comment">// 初始化时的最小百分比</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>第四步，监听路由跳转，进入页面执行插件动画。</p>
<p>路由跳转中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br><span class="hljs-comment">// 导航全局前置守卫</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 每次切换页面时，调用进度条</span><br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">start</span>();<br><br>  <span class="hljs-comment">// 这个一定要加，没有next()页面不会跳转的。这部分还不清楚的去翻一下官网就明白了</span><br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>跳转结束了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// router.js</span><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在即将进入新的页面组件前，关闭掉进度条</span><br>  <span class="hljs-title class_">NProgress</span>.<span class="hljs-title function_">done</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="如何实现刷新页面"><a href="#如何实现刷新页面" class="headerlink" title="如何实现刷新页面"></a>如何实现刷新页面</h3><ul>
<li><strong>实现思路有 3 种</strong></li>
<li>方式 1：<ul>
<li>通过给<code>router-view</code>添加<code>v-if</code>指令，控制组件重新渲染，从而实现刷新。</li>
</ul>
</li>
<li>方式 2：<ul>
<li>采用<code>window.reload()</code>，或者<code>router.go(0)</code>刷新时，整个浏览器进行了重新加载，闪烁，体验不好</li>
</ul>
</li>
<li>方式 3：<ul>
<li>为了实现刷新页面，可以先跳转到一个空页面，然后马上跳回来，从而实现这个功能</li>
</ul>
</li>
</ul>
<hr>
<p><strong>方式 1 实现方式</strong></p>
<p><strong>provide / inject 组合</strong></p>
<p>作用：允许一个祖先组件向其所有子孙后代注入一个依赖，<strong>不论组件层次有多深</strong>，并在起上下游关系成立的时间里始终生效。</p>
<p><strong><u>App.vue: 声明 reload 方法，控制 router-view 的显示或隐藏，从而控制页面的再次加载</u></strong></p>
<img src="/img/vue-interview/010.png"  />

<p><strong>某个组件中：</strong>在页面注入 App.vue 组件提供（provide）的 reload 依赖，在逻辑完成之后（删除或添加…）,直接 this.reload()调用，即可刷新当前页面。</p>
<p><img src="/img/vue-interview/011.png"></p>
<p><strong>需要理解 provide/inject 的使用</strong>，不熟悉看文档地址：<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#provide-inject">https://cn.vuejs.org/v2/api/#provide-inject</a></p>
<hr>
<p><strong>方式 3 的实现方法</strong></p>
<p><strong>一、原理</strong></p>
<p><img src="/img/vue-interview/012.png"></p>
<p>如上图所示，我们需要为要刷新的页面 A 编写一个自动跳回的空页面，当用户操作了 A 页面后，A 页面先跳转到空页面，然后空页面马上跳回 A 页面，这时候 vue 会去重新加载 A 页面。这种方法可以变相实现自我刷新，缺点是当需要刷新的页面较多时，空页面也会随之变多。</p>
<p><strong>二、当前页面事件监听</strong></p>
<p><img src="/img/vue-interview/013.png"></p>
<p>如上图所示，我们定义了 refreshPage 方法，这个方法是对特定事件的回调，在这个方法会处理业务逻辑，然后在最后使用 vue 的 router 跳转到一个空页面，这个空页面路由路径是/user/back，这个路径是随便取的，大家可以选择自己的路径</p>
<p><strong>三、空页面的编写</strong></p>
<p><img src="/img/vue-interview/014.png"></p>
<p>如上图所示，在空页面中立即执行路由，跳回原来的页面，这时候原来的页面会进行重新加载，从而实现了刷新。这里的/user/index 就是跳回原来页面的路由路径，大家需要根据自己的项目情况写。</p>
<p><strong>四、注意事项</strong></p>
<p>本文所使用的方法，其实是一种 hack 方法，在极端情况下，比如网络极端恶劣，那么可能出现跳到空页面后跳不会来，或者干脆跳不到空页面的情况，大家需要根据自己的项目情况酌情选择。</p>
<h3 id="如何使用路由实现标签页"><a href="#如何使用路由实现标签页" class="headerlink" title="如何使用路由实现标签页"></a>如何使用路由实现标签页</h3><p><img src="/img/vue-interview/007.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag-list&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 循环这个li --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;$route.fullPath === item.path ? &#x27;on&#x27; : &#x27;&#x27;&quot;</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;item.path&quot;</span>&gt;</span> &#123;&#123; item.name &#125;&#125; <span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">i</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;del(item, index)&quot;</span>&gt;</span>X<span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delOther&quot;</span>&gt;</span>关闭其他<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;delAll&quot;</span>&gt;</span>关闭所有<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;TagsList&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 从本地存储读取是否有！</span></span><br><span class="language-javascript">      <span class="hljs-keyword">let</span> list = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;taglist&#x27;</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">list</span>: list ? <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(list) : [], <span class="hljs-comment">// 菜单地址池</span></span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">watch</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 监听$route的变化，从而实现增加标签页信息</span></span><br><span class="language-javascript">      <span class="hljs-attr">$route</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 一开始就要做一次监听</span></span><br><span class="language-javascript">        <span class="hljs-title function_">handler</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 判断是否已经有</span></span><br><span class="language-javascript">          <span class="hljs-keyword">const</span> hasPath = <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">some</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val.<span class="hljs-property">path</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">fullPath</span>);</span><br><span class="language-javascript">          <span class="hljs-comment">// 如果没有就写入</span></span><br><span class="language-javascript">          !hasPath &amp;&amp;</span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">              <span class="hljs-attr">name</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>,</span><br><span class="language-javascript">              <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">fullPath</span>,</span><br><span class="language-javascript">            &#125;);</span><br><span class="language-javascript">          <span class="hljs-comment">// 写入本地存储持久化</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;taglist&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>));</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">// 删除单个标签页</span></span><br><span class="language-javascript">      <span class="hljs-title function_">del</span>(<span class="hljs-params">val, index</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">//删除的元素，删除元素的下标</span></span><br><span class="language-javascript">        <span class="hljs-comment">// 删除的是否为激活元素</span></span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (val.<span class="hljs-property">path</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">fullPath</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 是激活</span></span><br><span class="language-javascript">          <span class="hljs-comment">// 跳转到index-1的那个路由地址去！ 左边激活</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除对应元素！</span></span><br><span class="language-javascript">          <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-property">length</span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 还有值！</span></span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">              <span class="hljs-comment">// 删除第是第一个，说明右边还有，那么就向后走，但是其实还是index下标这个，因为数组已经发生变化了</span></span><br><span class="language-javascript">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[index].<span class="hljs-property">path</span>);</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">              <span class="hljs-comment">// 删除的不是第一个（说明左边还有），那么就展示左边的一个</span></span><br><span class="language-javascript">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>[index - <span class="hljs-number">1</span>].<span class="hljs-property">path</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">          &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">// 最一个元素，跳转到制定地址去</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/welcome&#x27;</span>);</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">          <span class="hljs-comment">// 不是激活</span></span><br><span class="language-javascript">          <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>.<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-comment">// 持久化存储</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;taglist&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>));</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// 删除其他标签页</span></span><br><span class="language-javascript">      <span class="hljs-title function_">delOther</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 直接赋值为当前页面元素</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = [&#123; <span class="hljs-attr">name</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">title</span>, <span class="hljs-attr">path</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">fullPath</span> &#125;];</span><br><span class="language-javascript">        <span class="hljs-comment">// 持久化存储</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;taglist&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>));</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      <span class="hljs-comment">// 删除所有标签</span></span><br><span class="language-javascript">      <span class="hljs-title function_">delAll</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = [];</span><br><span class="language-javascript">        <span class="hljs-comment">// 持久化存储</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;taglist&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span>));</span><br><span class="language-javascript">        <span class="hljs-comment">// 跳转地址</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/welcome&#x27;</span>);</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="language-javascript">思路：</span></span><br><span class="hljs-comment"><span class="language-javascript">    有一个数组，用于存储打开过的标签信息</span></span><br><span class="hljs-comment"><span class="language-javascript">        // 数组格式： [&#123; name:&#x27;名称&#x27;,path:&#x27;/地址&#x27; &#125;,...]</span></span><br><span class="hljs-comment"><span class="language-javascript">    增加：</span></span><br><span class="hljs-comment"><span class="language-javascript">        // 用watch监听$route的变化</span></span><br><span class="hljs-comment"><span class="language-javascript">            // 有变化，插入到数组中去（判断一下数组中是否已经存在）</span></span><br><span class="hljs-comment"><span class="language-javascript">	删除：</span></span><br><span class="hljs-comment"><span class="language-javascript">		删除所有： 直接赋值为空数组，然后跳转到默认地址</span></span><br><span class="hljs-comment"><span class="language-javascript">		删除其他： 直接赋值为一个元素，就是当前路由的信息</span></span><br><span class="hljs-comment"><span class="language-javascript">		删除单个：</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 是否为激活</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 不是激活项 直接删除</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 是激活项：</span></span><br><span class="hljs-comment"><span class="language-javascript">    //  首先删除元素</span></span><br><span class="hljs-comment"><span class="language-javascript">    //  删除完之后数组是否还有长度：</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 没有长度，说明删除的是最后一个元素且还是激活项，那么跳转到默认地址</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 有长度，就判断删除的元素下标是否为0，也就是判断是否为首位</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 如果是0，【删完后还有长度，且删除的那个是首位，说明右边还有内容】，所以展示右边的内容。而右边那个元素的下标就是index</span></span><br><span class="hljs-comment"><span class="language-javascript">    // 如果不是0 【删完后还有长度，且删除的不是首位，说明左边还有内容】，所以展示左边的内容，以此类推，直到左边没有了，就会去判断右边是否还有。</span></span><br><span class="hljs-comment"><span class="language-javascript">*/</span></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#aaa</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">    <span class="hljs-attribute">list-style</span>: none;</span><br><span class="language-css">    <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">    <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: relative;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">text-decoration</span>: none;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: inherit;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">i</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">position</span>: absolute;</span><br><span class="language-css">    <span class="hljs-attribute">right</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">top</span>: <span class="hljs-number">5px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">display</span>: inline-block;</span><br><span class="language-css">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">    <span class="hljs-attribute">line-height</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">font-style</span>: normal;</span><br><span class="language-css">    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">    <span class="hljs-attribute">cursor</span>: pointer;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">i</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.on</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: blue;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.tag-list</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.on</span> <span class="hljs-selector-tag">i</span><span class="hljs-selector-pseudo">:hover</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="language-css">    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="说一下路由实现的原理"><a href="#说一下路由实现的原理" class="headerlink" title="说一下路由实现的原理"></a>说一下路由实现的原理</h3><ul>
<li>hash 模式：<strong>监听 window 的 hashchange 事件，从而实现更换展示不同的组件</strong></li>
<li>history 模式： <u>从 HTML5 开始，<strong>History interface</strong> 提供了 2 个新的方法：<strong>pushState()**、</strong>replaceState()** 使得我们可以对浏览器历史记录栈进行修改</u></li>
<li>参考文档地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaosirs/p/10606266.html">https://www.cnblogs.com/gaosirs/p/10606266.html</a></li>
<li>vue-router 原理文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/derivation/article/details/105085951">https://blog.csdn.net/derivation/article/details/105085951</a></li>
</ul>
<h3 id="完整的-vue-router-导航解析流程"><a href="#完整的-vue-router-导航解析流程" class="headerlink" title="完整的 vue-router 导航解析流程"></a>完整的 vue-router 导航解析流程</h3><blockquote>
<p>1.导航被触发； 2.在失活的组件里调用 beforeRouteLeave 守卫； 3.调用全局 beforeEach 守卫； 4.在复用组件里调用 beforeRouteUpdate 守卫； 5.调用路由配置里的 beforeEnter 守卫； 6.解析异步路由组件； 7.在被激活的组件里调用 beforeRouteEnter 守卫； 8.调用全局 beforeResolve 守卫； 9.导航被确认；<br>10..调用全局的 afterEach 钩子；<br>11.DOM 更新； 12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</p>
</blockquote>
<h3 id="切换路由时，需要保存草稿的功能，怎么实现呢？"><a href="#切换路由时，需要保存草稿的功能，怎么实现呢？" class="headerlink" title="切换路由时，需要保存草稿的功能，怎么实现呢？"></a>切换路由时，需要保存草稿的功能，怎么实现呢？</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">:include</span>=<span class="hljs-string">&quot;include&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中 include 可以是个数组，数组内容为路由的 name 选项的值。</p>
<h3 id="说说你对-router-link-的了解"><a href="#说说你对-router-link-的了解" class="headerlink" title="说说你对 router-link 的了解"></a>说说你对 router-link 的了解</h3><p><code>&lt;router-link&gt;</code>是 Vue-Router 的内置组件，在具有路由功能的应用中作为声明式的导航使用。</p>
<p><code>&lt;router-link&gt;</code>有 8 个 props，其作用是：</p>
<ul>
<li><p>to：必填，表示目标路由的链接。当被点击后，内部会立刻把<code>to</code>的值传到<code>router.push()</code>，所以这个值可以是一个字符串或者是描述目标位置的对象。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#x27;home&#x27;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;home&#x27; &#125;&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; path: &#x27;user&#x27;, query: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>注意 path 存在时 params 不起作用，只能用 query</p>
</li>
<li><p><code>replace</code>：默认值为 false，若设置的话，当点击时，会调用<code>router.replace()</code>而不是<code>router.push()</code>，于是导航后不会留下 history 记录。</p>
</li>
<li><p><code>append</code>：设置 append 属性后，则在当前 (相对) 路径前添加基路径。</p>
</li>
<li><p><code>tag</code>：让<code>&lt;router-link&gt;</code>渲染成<code>tag</code>设置的标签，如<code>tag:&#39;li</code>,渲染结果为<code>&lt;li&gt;foo&lt;/li&gt;</code>。</p>
</li>
<li><p><code>active-class</code>：默认值为<code>router-link-active</code>,设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。</p>
</li>
<li><p><code>exact-active-class</code>：默认值为<code>router-link-exact-active</code>,设置链接被精确匹配的时候应该激活的 class。默认值可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。</p>
</li>
<li><pre><code>exact
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br>：是否精确匹配，默认为 false。<br><br>```html<br><span class="hljs-comment">&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">exact</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>event</code>：声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组，默认是<code>click</code>。</p>
</li>
</ul>
<h3 id="Vue-路由怎么跳转打开新窗口？"><a href="#Vue-路由怎么跳转打开新窗口？" class="headerlink" title="Vue 路由怎么跳转打开新窗口？"></a>Vue 路由怎么跳转打开新窗口？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">path</span>: xxx, <span class="hljs-comment">//路由地址</span><br>  <span class="hljs-attr">query</span>: &#123;<br>    <span class="hljs-attr">mid</span>: data.<span class="hljs-property">id</span>, <span class="hljs-comment">//可以带参数</span><br>  &#125;,<br>&#125;;<br><span class="hljs-keyword">const</span> &#123; href &#125; = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$router</span>.<span class="hljs-title function_">resolve</span>(obj);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(href, <span class="hljs-string">&#x27;_blank&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h2 id="三、vuex"><a href="#三、vuex" class="headerlink" title="三、vuex"></a>三、vuex</h2><h3 id="vuex-和本地存储的区别"><a href="#vuex-和本地存储的区别" class="headerlink" title="vuex 和本地存储的区别"></a>vuex 和本地存储的区别</h3><ul>
<li><p>vuex 刷新就丢失，本地存储一直在</p>
</li>
<li><p>vuex 它可以实时更新，本地存储不能</p>
</li>
</ul>
<h3 id="什么是-Vuex？"><a href="#什么是-Vuex？" class="headerlink" title="什么是 Vuex？"></a>什么是 Vuex？</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交 mutation，例<code>this.$store.commit(&#39;SET_VIDEO_PAUSE&#39;, video_pause)</code>，SET_VIDEO_PAUSE 为 mutations 属性中定义的方法。</p>
<h3 id="Vuex-解决了什么问题？"><a href="#Vuex-解决了什么问题？" class="headerlink" title="Vuex 解决了什么问题？"></a>Vuex 解决了什么问题？</h3><ul>
<li><p>多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。</p>
</li>
<li><p>来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。</p>
</li>
</ul>
<h3 id="怎么引用-Vuex？"><a href="#怎么引用-Vuex？" class="headerlink" title="怎么引用 Vuex？"></a>怎么引用 Vuex？</h3><ul>
<li><p>先安装依赖<code>nnpm install vuex --save</code></p>
</li>
<li><p>在项目目录 src 中建立 store 文件夹</p>
</li>
<li><p>在 store 文件夹下新建 index.js 文件,写入</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>);<br><span class="hljs-comment">//不是在生产环境debug为true</span><br><span class="hljs-keyword">const</span> debug = process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> !== <span class="hljs-string">&#x27;production&#x27;</span>;<br><span class="hljs-comment">//创建Vuex实例对象</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">strict</span>: debug, <span class="hljs-comment">//在不是生产环境下都开启严格模式</span><br>  <span class="hljs-attr">state</span>: &#123;&#125;,<br>  <span class="hljs-attr">getters</span>: &#123;&#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;&#125;,<br>  <span class="hljs-attr">actions</span>: &#123;&#125;,<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br>复制代码;<br></code></pre></td></tr></table></figure>

<ul>
<li>然后再 main.js 文件中引入 Vuex,这么写</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">store</span>: store, <span class="hljs-comment">// 一旦挂载，组件中this.$store就可以得到仓库实例</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">App</span>),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-的-5-个核心属性是什么？"><a href="#Vuex-的-5-个核心属性是什么？" class="headerlink" title="Vuex 的 5 个核心属性是什么？"></a>Vuex 的 5 个核心属性是什么？</h3><p>分别是 state、getters、mutations、actions、modules 。</p>
<h3 id="Vuex-中状态储存在哪里，怎么改变它？"><a href="#Vuex-中状态储存在哪里，怎么改变它？" class="headerlink" title="Vuex 中状态储存在哪里，怎么改变它？"></a>Vuex 中状态储存在哪里，怎么改变它？</h3><p>存储在 state 中，改变 Vuex 中的状态的唯一途径就是显式地提交 (commit) mutation。</p>
<h3 id="Vuex-中状态是对象时，使用时要注意什么？"><a href="#Vuex-中状态是对象时，使用时要注意什么？" class="headerlink" title="Vuex 中状态是对象时，使用时要注意什么？"></a>Vuex 中状态是对象时，使用时要注意什么？</h3><p>因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变 state 里面的状态，是不允许，所以先用深度克隆复制对象，再修改。</p>
<h3 id="怎么在组件中批量使用-Vuex-的-state-状态？"><a href="#怎么在组件中批量使用-Vuex-的-state-状态？" class="headerlink" title="怎么在组件中批量使用 Vuex 的 state 状态？"></a>怎么在组件中批量使用 Vuex 的 state 状态？</h3><p>使用 mapState 辅助函数, 利用对象展开运算符将 state 混入 computed 对象中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapState</span>([<span class="hljs-string">&#x27;price&#x27;</span>, <span class="hljs-string">&#x27;number&#x27;</span>]),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-中要从-state-派生一些状态出来，且多个组件使用它，该怎么做，？"><a href="#Vuex-中要从-state-派生一些状态出来，且多个组件使用它，该怎么做，？" class="headerlink" title="Vuex 中要从 state 派生一些状态出来，且多个组件使用它，该怎么做，？"></a>Vuex 中要从 state 派生一些状态出来，且多个组件使用它，该怎么做，？</h3><p>使用 getter 属性，相当 Vue 中的计算属性 computed，只有原状态改变派生状态才会改变。</p>
<p>getter 接收两个参数，第一个是 state，第二个是 getters(可以用来访问其他 getter)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">number</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">discount</span>: <span class="hljs-number">0.7</span>,<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">total</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">price</span> * state.<span class="hljs-property">number</span>;<br>    &#125;,<br>    <span class="hljs-attr">discountTotal</span>: <span class="hljs-function">(<span class="hljs-params">state, getters</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">discount</span> * getters.<span class="hljs-property">total</span>;<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>然后在组件中可以用计算属性 computed 通过<code>this.$store.getters.total</code>这样来访问这些派生转态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">total</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">total</span><br>    &#125;,<br>    <span class="hljs-title function_">discountTotal</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">discountTotal</span><br>    &#125;<br>    <span class="hljs-comment">// 或者直接计算属性，上述代码可以简写为</span><br>	...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="怎么通过-getter-来实现在组件内可以通过特定条件来获取-state-的状态？"><a href="#怎么通过-getter-来实现在组件内可以通过特定条件来获取-state-的状态？" class="headerlink" title="怎么通过 getter 来实现在组件内可以通过特定条件来获取 state 的状态？"></a>怎么通过 getter 来实现在组件内可以通过特定条件来获取 state 的状态？</h3><p>通过让 getter 返回一个函数，来实现给 getter 传参。然后通过参数来进行判断从而获取 state 中满足要求的状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">todos</span>: [<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span> &#125;,<br>    ],<br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">getTodoById</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> state.<span class="hljs-property">todos</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">todo</span> =&gt;</span> todo.<span class="hljs-property">id</span> === id);<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>然后在组件中可以用计算属性 computed 通过<code>this.$store.getters.getTodoById(2)</code>这样来访问这些派生转态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-title function_">getTodoById</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">getTodoById</span><br>    &#125;,<br>&#125;<br><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getTodoById</span>(<span class="hljs-number">2</span>).<span class="hljs-property">done</span>)<span class="hljs-comment">//false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="怎么在组件中批量使用-Vuex-的-getter-属性"><a href="#怎么在组件中批量使用-Vuex-的-getter-属性" class="headerlink" title="怎么在组件中批量使用 Vuex 的 getter 属性"></a>怎么在组件中批量使用 Vuex 的 getter 属性</h3><p>使用 mapGetters 辅助函数, 利用对象展开运算符将 getter 混入 computed 对象中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;total&#x27;</span>, <span class="hljs-string">&#x27;discountTotal&#x27;</span>]),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="怎么在组件中批量给-Vuex-的-getter-属性取别名并使用"><a href="#怎么在组件中批量给-Vuex-的-getter-属性取别名并使用" class="headerlink" title="怎么在组件中批量给 Vuex 的 getter 属性取别名并使用"></a>怎么在组件中批量给 Vuex 的 getter 属性取别名并使用</h3><p>使用 mapGetters 辅助函数, 利用对象展开运算符将 getter 混入 computed 对象中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    ...<span class="hljs-title function_">mapGetters</span>(&#123;<br>      <span class="hljs-attr">myTotal</span>: <span class="hljs-string">&#x27;total&#x27;</span>,<br>      <span class="hljs-attr">myDiscountTotal</span>: <span class="hljs-string">&#x27;discountTotal&#x27;</span>,<br>    &#125;),<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="在-Vuex-的-state-中有个状态-number-表示货物数量，在组件怎么改变它。"><a href="#在-Vuex-的-state-中有个状态-number-表示货物数量，在组件怎么改变它。" class="headerlink" title="在 Vuex 的 state 中有个状态 number 表示货物数量，在组件怎么改变它。"></a>在 Vuex 的 state 中有个状态 number 表示货物数量，在组件怎么改变它。</h3><p>首先要在 mutations 中注册一个 mutation</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">number</span>: <span class="hljs-number">10</span>,<br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">SET_NUMBER</span>(<span class="hljs-params">state, data</span>) &#123;<br>      state.<span class="hljs-property">number</span> = data;<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在组件中使用<code>this.$store.commit</code>提交 mutation，改变 number</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<h3 id="在-Vuex-中使用-mutation-要注意什么。"><a href="#在-Vuex-中使用-mutation-要注意什么。" class="headerlink" title="在 Vuex 中使用 mutation 要注意什么。"></a>在 Vuex 中使用 mutation 要注意什么。</h3><p>mutation 必须是同步函数</p>
<h3 id="在组件中多次提交同一个-mutation，怎么写使用更方便。"><a href="#在组件中多次提交同一个-mutation，怎么写使用更方便。" class="headerlink" title="在组件中多次提交同一个 mutation，怎么写使用更方便。"></a>在组件中多次提交同一个 mutation，怎么写使用更方便。</h3><p>使用 mapMutations 辅助函数,在组件中这么使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapMutations</span>(&#123;<br>        <span class="hljs-attr">setNumber</span>:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h3 id="Vuex-中-action-和-mutation-有什么区别？"><a href="#Vuex-中-action-和-mutation-有什么区别？" class="headerlink" title="Vuex 中 action 和 mutation 有什么区别？"></a>Vuex 中 action 和 mutation 有什么区别？</h3><ul>
<li><p>action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。</p>
</li>
<li><p>action 可以包含任意异步操作。mutation 只能是同步操作。</p>
</li>
<li><p>提交方式不同，action 是用<code>this.$store.dispatch(&#39;ACTION_NAME&#39;,data)</code>来提交。mutation 是用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code>来提交。</p>
</li>
<li><p>接收参数不同，mutation 第一个参数是 state，而 action 第一个参数是 context，其包含了</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  state, <span class="hljs-comment">// 等同于 `store.state`，若在模块中则为局部状态</span><br>    rootState, <span class="hljs-comment">// 等同于 `store.state`，只存在于模块中</span><br>    commit, <span class="hljs-comment">// 等同于 `store.commit`</span><br>    dispatch, <span class="hljs-comment">// 等同于 `store.dispatch`</span><br>    getters, <span class="hljs-comment">// 等同于 `store.getters`</span><br>    rootGetters; <span class="hljs-comment">// 等同于 `store.getters`，只存在于模块中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-中-action-和-mutation-有什么相同点？"><a href="#Vuex-中-action-和-mutation-有什么相同点？" class="headerlink" title="Vuex 中 action 和 mutation 有什么相同点？"></a>Vuex 中 action 和 mutation 有什么相同点？</h3><p>第二参数都可以接收外部提交时传来的参数。 <code>this.$store.dispatch(&#39;ACTION_NAME&#39;,data)</code>和<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h3 id="在组件中多次提交同一个-action，怎么写使用更方便。"><a href="#在组件中多次提交同一个-action，怎么写使用更方便。" class="headerlink" title="在组件中多次提交同一个 action，怎么写使用更方便。"></a>在组件中多次提交同一个 action，怎么写使用更方便。</h3><p>使用 mapActions 辅助函数,在组件中这么使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">methods</span>:&#123;<br>    ...<span class="hljs-title function_">mapActions</span>(&#123;<br>        <span class="hljs-attr">setNumber</span>:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.dispatch(&#39;SET_NUMBER&#39;,10)</code></p>
<h3 id="Vuex-中-action-通常是异步的，那么如何知道-action-什么时候结束呢？"><a href="#Vuex-中-action-通常是异步的，那么如何知道-action-什么时候结束呢？" class="headerlink" title="Vuex 中 action 通常是异步的，那么如何知道 action 什么时候结束呢？"></a>Vuex 中 action 通常是异步的，那么如何知道 action 什么时候结束呢？</h3><p>在 action 函数中返回 Promise，然后再提交时候用 then 处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">actions</span>:&#123;<br>    <span class="hljs-title function_">SET_NUMBER_A</span>(<span class="hljs-params">&#123;commit&#125;,data</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span>&#123;<br>            <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>                <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<span class="hljs-number">10</span>);<br>                <span class="hljs-title function_">resolve</span>();<br>            &#125;,<span class="hljs-number">2000</span>)<br>        &#125;)<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;SET_NUMBER_A&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-中有两个-action，分别是-actionA-和-actionB，其内都是异步操作，在-actionB-要提交-actionA，需在-actionA-处理结束再处理其它操作，怎么实现？"><a href="#Vuex-中有两个-action，分别是-actionA-和-actionB，其内都是异步操作，在-actionB-要提交-actionA，需在-actionA-处理结束再处理其它操作，怎么实现？" class="headerlink" title="Vuex 中有两个 action，分别是 actionA 和 actionB，其内都是异步操作，在 actionB 要提交 actionA，需在 actionA 处理结束再处理其它操作，怎么实现？"></a>Vuex 中有两个 action，分别是 actionA 和 actionB，其内都是异步操作，在 actionB 要提交 actionA，需在 actionA 处理结束再处理其它操作，怎么实现？</h3><p>利用 ES6 的<code>async</code>和<code>await</code>来实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">actions</span>:&#123;<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">actionA</span>(<span class="hljs-params">&#123;commit&#125;</span>)&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;,<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">actionB</span>(<span class="hljs-params">&#123;dispatch&#125;</span>)&#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-title function_">dispatch</span> (<span class="hljs-string">&#x27;actionA&#x27;</span>)<span class="hljs-comment">//等待actionA完成</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="有用过-Vuex-模块吗，为什么要使用，怎么使用。"><a href="#有用过-Vuex-模块吗，为什么要使用，怎么使用。" class="headerlink" title="有用过 Vuex 模块吗，为什么要使用，怎么使用。"></a>有用过 Vuex 模块吗，为什么要使用，怎么使用。</h3><p>有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。</p>
<p>在 module 文件新建 moduleA.js 和 moduleB.js 文件。在文件中写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> state = &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">const</span> getters = &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">const</span> mutations = &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">const</span> actions = &#123;<br>  <span class="hljs-comment">//...</span><br>&#125;;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  state,<br>  getters,<br>  mutations,<br>  actions,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>然后再 index.js 引入模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vuex</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Vuex</span>);<br><span class="hljs-keyword">import</span> moduleA <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module/moduleA&#x27;</span>;<br><span class="hljs-keyword">import</span> moduleB <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./module/moduleB&#x27;</span>;<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    moduleA,<br>    moduleB,<br>  &#125;,<br>&#125;);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure>

<h3 id="在模块中，getter-和-mutation-接收的第一个参数-state，是全局的还是模块的？"><a href="#在模块中，getter-和-mutation-接收的第一个参数-state，是全局的还是模块的？" class="headerlink" title="在模块中，getter 和 mutation 接收的第一个参数 state，是全局的还是模块的？"></a>在模块中，getter 和 mutation 接收的第一个参数 state，是全局的还是模块的？</h3><p>第一个参数 state 是模块的 state，也就是局部的 state。</p>
<h3 id="在模块中，getter-和-mutation-和-action-中怎么访问全局的-state-和-getter？"><a href="#在模块中，getter-和-mutation-和-action-中怎么访问全局的-state-和-getter？" class="headerlink" title="在模块中，getter 和 mutation 和 action 中怎么访问全局的 state 和 getter？"></a>在模块中，getter 和 mutation 和 action 中怎么访问全局的 state 和 getter？</h3><ul>
<li><p>在 getter 中可以通过第三个参数 rootState 访问到全局的 state,可以通过第四个参数 rootGetters 访问到全局的 getter。</p>
</li>
<li><p>在 mutation 中不可以访问全局的 satat 和 getter，只能访问到局部的 state。</p>
</li>
<li><p>在 action 中第一个参数 context 中的<code>context.rootState</code>访问到全局的 state，<code>context.rootGetters</code>访问到全局的 getter。</p>
</li>
</ul>
<h3 id="在组件中怎么访问-Vuex-模块中的-getter-和-state-怎么提交-mutation-和-action？"><a href="#在组件中怎么访问-Vuex-模块中的-getter-和-state-怎么提交-mutation-和-action？" class="headerlink" title="在组件中怎么访问 Vuex 模块中的 getter 和 state,怎么提交 mutation 和 action？"></a>在组件中怎么访问 Vuex 模块中的 getter 和 state,怎么提交 mutation 和 action？</h3><ul>
<li><p>直接通过<code>this.$store.getters.xxx</code>和<code>this.$store.模块名.xxx</code>来访问模块中的 getter 和 state。</p>
</li>
<li><p>直接通过<code>this.$store.commit(&#39;mutationA&#39;,data)</code>提交模块中的 mutation。</p>
</li>
<li><p>直接通过<code>this.$store.dispatch(&#39;actionA&#39;,data)</code>提交模块中的 action。</p>
</li>
<li><p><strong>以上是没有命名空间的，如果有命名空间那么就是下面这样</strong></p>
</li>
<li><p>直接通过<code>this.$store.getters[&#39;模块名/xxx&#39;]</code>和<code>this.$store.模块名.xxx</code>来访问模块中的 getter 和 state。</p>
</li>
<li><p>直接通过<code>this.$store.commit(&#39;模块名/mutationA&#39;,data)</code>提交模块中的 mutation。</p>
</li>
<li><p>直接通过<code>this.$store.dispatch(&#39;模块名/actionA&#39;,data)</code>提交模块中的 action。</p>
</li>
</ul>
<h3 id="用过-Vuex-模块的命名空间吗？为什么使用，怎么使用。"><a href="#用过-Vuex-模块的命名空间吗？为什么使用，怎么使用。" class="headerlink" title="用过 Vuex 模块的命名空间吗？为什么使用，怎么使用。"></a>用过 Vuex 模块的命名空间吗？为什么使用，怎么使用。</h3><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间，如果多个模块中 action、mutation 的命名是一样的，那么提交 mutation、action 时，将会触发所有模块中命名相同的 mutation、action。</p>
<p>这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加<code>namespaced: true</code> 的方式使其成为带命名空间的模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">namespaced</span>: <span class="hljs-literal">true</span>,<br>  state,<br>  getters,<br>  mutations,<br>  actions,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="怎么在带命名空间的模块内提交全局的-mutation-和-action？"><a href="#怎么在带命名空间的模块内提交全局的-mutation-和-action？" class="headerlink" title="怎么在带命名空间的模块内提交全局的 mutation 和 action？"></a>怎么在带命名空间的模块内提交全局的 mutation 和 action？</h3><p>将<code> &#123; root: true &#125;</code> 作为第三参数传给 dispatch 或 commit 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;actionA&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;mutationA&#x27;</span>, <span class="hljs-literal">null</span>, &#123; <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span> &#125;);<br></code></pre></td></tr></table></figure>

<h3 id="怎么在带命名空间的模块内注册全局的-action？"><a href="#怎么在带命名空间的模块内注册全局的-action？" class="headerlink" title="怎么在带命名空间的模块内注册全局的 action？"></a>怎么在带命名空间的模块内注册全局的 action？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-attr">actionA</span>: &#123;<br>        <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 带上root为true表示就是根的action了</span><br>        <span class="hljs-title function_">handler</span> (context, data) &#123; ... &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="组件中怎么提交-modules-中的带命名空间的-moduleA-中的-mutationA？"><a href="#组件中怎么提交-modules-中的带命名空间的-moduleA-中的-mutationA？" class="headerlink" title="组件中怎么提交 modules 中的带命名空间的 moduleA 中的 mutationA？"></a>组件中怎么提交 modules 中的带命名空间的 moduleA 中的 mutationA？</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;moduleA/mutationA&#x27;</span>, data);<br></code></pre></td></tr></table></figure>

<h3 id="怎么使用-mapState，mapGetters，mapActions-和-mapMutations-这些函数来绑定带命名空间的模块？"><a href="#怎么使用-mapState，mapGetters，mapActions-和-mapMutations-这些函数来绑定带命名空间的模块？" class="headerlink" title="怎么使用 mapState，mapGetters，mapActions 和 mapMutations 这些函数来绑定带命名空间的模块？"></a>怎么使用 mapState，mapGetters，mapActions 和 mapMutations 这些函数来绑定带命名空间的模块？</h3><p><strong>使用<code>createNamespacedHelpers</code>创建基于某个命名空间辅助函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createNamespacedHelpers &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">const</span> &#123; mapState, mapActions,mapGetters,mapMutations &#125; = <span class="hljs-title function_">createNamespacedHelpers</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>);<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-comment">// 在 `module/moduleA` 中查找</span><br>        ...<span class="hljs-title function_">mapState</span>(&#123;<br>            <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">a</span>,<br>            <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">b</span><br>        &#125;),<br>        ...<span class="hljs-title function_">mapGetters</span>([<span class="hljs-string">&#x27;getterA&#x27;</span>,<span class="hljs-string">&#x27;getterB&#x27;</span>])<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-comment">// 在 `module/moduleA` 中查找</span><br>        ...<span class="hljs-title function_">mapActions</span>([<br>            <span class="hljs-string">&#x27;actionA&#x27;</span>,<br>            <span class="hljs-string">&#x27;actionB&#x27;</span><br>        ])，<br>        ...<span class="hljs-title function_">mapMutations</span>([<br>        	<span class="hljs-string">&#x27;mutationA&#x27;</span>,<br>        	<span class="hljs-string">&#x27;mutationB&#x27;</span><br>        ])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如果不使用<code>createNamespacedHelpers</code>就需要注意，不能直接用数组语去获取</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapState, mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">computed</span>: &#123;<br>        <span class="hljs-comment">// 在 `module/moduleA` 中查找</span><br>        ...<span class="hljs-title function_">mapState</span>(&#123;<br>            <span class="hljs-attr">a</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.模块名.<span class="hljs-property">a</span>,<br>            <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.模块名.<span class="hljs-property">b</span><br>        &#125;),<br>        ...<span class="hljs-title function_">mapGetters</span>(&#123;<br>            <span class="hljs-attr">gettersA</span>:<span class="hljs-string">&#x27;模块名/gettersA&#x27;</span><br>            <span class="hljs-attr">gettersB</span>:<span class="hljs-string">&#x27;模块名/gettersB&#x27;</span><br>        &#125;)<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>        <span class="hljs-comment">// 在 `module/moduleA` 中查找</span><br>        ...<span class="hljs-title function_">mapActions</span>(&#123;<br>            <span class="hljs-attr">actionA</span>:<span class="hljs-string">&#x27;模块名/actionA&#x27;</span>,<br>            <span class="hljs-attr">actionB</span>:<span class="hljs-string">&#x27;模块名/actionB&#x27;</span><br>        &#125;),<br>        ...<span class="hljs-title function_">mapMutations</span>(&#123;<br>            <span class="hljs-attr">mutationA</span>:<span class="hljs-string">&#x27;模块名/mutationA&#x27;</span>,<br>            <span class="hljs-attr">mutationB</span>:<span class="hljs-string">&#x27;模块名/mutationB&#x27;</span><br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-插件有用过吗？怎么用简单介绍一下？"><a href="#Vuex-插件有用过吗？怎么用简单介绍一下？" class="headerlink" title="Vuex 插件有用过吗？怎么用简单介绍一下？"></a>Vuex 插件有用过吗？怎么用简单介绍一下？</h3><p>Vuex 插件就是一个函数，它接收 store 作为唯一参数。在 Vuex.Store 构造器选项 plugins 引入。 在 store/plugin.js 文件中写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPlugin</span>(<span class="hljs-params">param</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后在 store/index.js 文件中写入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> createPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./plugin.js&#x27;</span>;<br><span class="hljs-keyword">const</span> myPlugin = <span class="hljs-title function_">createPlugin</span>();<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [myPlugin],<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="在-Vuex-插件中怎么监听组件中提交-mutation-和-action？"><a href="#在-Vuex-插件中怎么监听组件中提交-mutation-和-action？" class="headerlink" title="在 Vuex 插件中怎么监听组件中提交 mutation 和 action？"></a>在 Vuex 插件中怎么监听组件中提交 mutation 和 action？</h3><ul>
<li>用 Vuex.Store 的实例方法<code>subscribe</code>监听组件中提交 mutation</li>
<li>用 Vuex.Store 的实例方法<code>subscribeAction</code>监听组件中提交 action 在 store/plugin.js 文件中写入</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">createPlugin</span>(<span class="hljs-params">param</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">store</span> =&gt;</span> &#123;<br>    store.<span class="hljs-title function_">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">mutation, state</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mutation.<span class="hljs-property">type</span>); <span class="hljs-comment">//是那个mutation</span><br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(mutation.<span class="hljs-property">payload</span>);<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state);<br>    &#125;);<br>    <span class="hljs-comment">// store.subscribeAction((action, state) =&gt; &#123;</span><br>    <span class="hljs-comment">//     console.log(action.type)//是那个action</span><br>    <span class="hljs-comment">//     console.log(action.payload)//提交action的参数</span><br>    <span class="hljs-comment">// &#125;)</span><br>    store.<span class="hljs-title function_">subscribeAction</span>(&#123;<br>      <span class="hljs-attr">before</span>: <span class="hljs-function">(<span class="hljs-params">action, state</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//提交action之前</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`before action <span class="hljs-subst">$&#123;action.type&#125;</span>`</span>);<br>      &#125;,<br>      <span class="hljs-attr">after</span>: <span class="hljs-function">(<span class="hljs-params">action, state</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">//提交action之后</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`after action <span class="hljs-subst">$&#123;action.type&#125;</span>`</span>);<br>      &#125;,<br>    &#125;);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> createPlugin <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./plugin.js&#x27;</span>;<br><span class="hljs-keyword">const</span> myPlugin = <span class="hljs-title function_">createPlugin</span>();<br><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">plugins</span>: [myPlugin],<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="在-v-model-上怎么用-Vuex-中-state-的值？"><a href="#在-v-model-上怎么用-Vuex-中-state-的值？" class="headerlink" title="在 v-model 上怎么用 Vuex 中 state 的值？"></a>在 v-model 上怎么用 Vuex 中 state 的值？</h3><p>需要通过 computed 计算属性来转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&lt;input v-model=<span class="hljs-string">&quot;message&quot;</span>&gt;<br><span class="hljs-comment">// ...</span><br><span class="hljs-attr">computed</span>: &#123;<br>    <span class="hljs-attr">message</span>: &#123;<br>        <span class="hljs-title function_">get</span> () &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">message</span><br>        &#125;,<br>        <span class="hljs-title function_">set</span> (value) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;updateMessage&#x27;</span>, value)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Vuex-的严格模式是什么-有什么作用-怎么开启？"><a href="#Vuex-的严格模式是什么-有什么作用-怎么开启？" class="headerlink" title="Vuex 的严格模式是什么,有什么作用,怎么开启？"></a>Vuex 的严格模式是什么,有什么作用,怎么开启？</h3><p>在严格模式下，<strong>无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。</strong>这能保证所有的状态变更都能被调试工具跟踪到。（有效防止了直接赋值 state 里面的内容进行修改）</p>
<p>在 Vuex.Store 构造器选项中开启,如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vuex</span>.<span class="hljs-title class_">Store</span>(&#123;<br>  <span class="hljs-attr">strict</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="为什么不推荐直接赋值修改-state"><a href="#为什么不推荐直接赋值修改-state" class="headerlink" title="为什么不推荐直接赋值修改 state"></a>为什么不推荐直接赋值修改 state</h3><p>组件里直接修改 state 也是生效的,但是不推荐这种直接修改 state 的方式，<strong>因为这样不能使用 vuex 的浏览器插件来跟踪状态的变化，不利于调试。如果是严格模式下，直接会抛出错误。</strong></p>
<h2 id="四、axios"><a href="#四、axios" class="headerlink" title="四、axios"></a>四、axios</h2><h3 id="axios-是什么"><a href="#axios-是什么" class="headerlink" title="axios 是什么"></a>axios 是什么</h3><ol>
<li><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库，</p>
</li>
<li><p>react/vue 官方都推荐使用 axios 发 ajax 请求</p>
</li>
</ol>
<h3 id="axios-特点"><a href="#axios-特点" class="headerlink" title="axios 特点"></a>axios 特点</h3><ol>
<li><p>基于 promise 的异步 ajax 请求库，支持 promise 所有的 API</p>
</li>
<li><p>浏览器端/node 端都可以使用，浏览器中创建 XMLHttpRequests</p>
</li>
<li><p>支持请求／响应拦截器</p>
</li>
<li><p>支持请求取消</p>
</li>
<li><p>可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类型的数据</p>
</li>
<li><p>批量发送多个请求</p>
</li>
<li><p>安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。</p>
</li>
</ol>
<h3 id="axios-常用语法"><a href="#axios-常用语法" class="headerlink" title="axios 常用语法"></a>axios 常用语法</h3><ul>
<li><p><strong>axios(config): 通用/最本质的发任意类型请求的方式</strong></p>
</li>
<li><p><strong>axios(url[, config]): 可以只指定 url 发 get 请求</strong></p>
</li>
<li><p><strong>axios.request(config): 等同于 axios(config)</strong></p>
</li>
<li><p><strong>axios.get(url[, config]): 发 get 请求</strong></p>
</li>
<li><p><strong>axios.delete(url[, config]): 发 delete 请求</strong></p>
</li>
<li><p><strong>axios.post(url[, data, config]): 发 post 请求</strong></p>
</li>
<li><p><strong>axios.put(url[, data, config]): 发 put 请求</strong></p>
</li>
<li><p>axios.defaults.xxx: 请求的默认全局配置</p>
</li>
<li><p>axios.interceptors.request.use(): 添加请求拦截器</p>
</li>
<li><p>axios.interceptors.response.use(): 添加响应拦截器</p>
</li>
<li><p>axios.create([config]): 创建一个新的 axios(它没有下面的功能)</p>
</li>
<li><p>axios.Cancel(): 用于创建取消请求的错误对象</p>
</li>
<li><p>axios.CancelToken(): 用于创建取消请求的 token 对象</p>
</li>
<li><p>axios.isCancel(): 是否是一个取消请求的错误</p>
</li>
<li><p><strong>axios.all(promises): 用于批量执行多个异步请求</strong></p>
</li>
<li><p>axios.spread(): 用来指定接收所有成功数据的回调函数的方法</p>
</li>
</ul>
<h3 id="axios-为什么既能在浏览器环境运行又能在服务器-node-环境运行？"><a href="#axios-为什么既能在浏览器环境运行又能在服务器-node-环境运行？" class="headerlink" title="axios 为什么既能在浏览器环境运行又能在服务器(node)环境运行？"></a>axios 为什么既能在浏览器环境运行又能在服务器(node)环境运行？</h3><p>axios 在浏览器端使用<code>XMLHttpRequest</code>对象发送 ajax 请求；在 node 环境使用<code>http</code>对象发送 ajax 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> defaults.<span class="hljs-property">adapter</span> = <span class="hljs-title function_">getDefaultAdapter</span>();<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getDefaultAdapter</span> (<span class="hljs-params"></span>) &#123;<br>	<span class="hljs-keyword">var</span> adapter;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">XMLHttpRequest</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    	<span class="hljs-comment">// 浏览器环境</span><br>        adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./adapter/xhr&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> process !== <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    	<span class="hljs-comment">// node环境</span><br>        adapter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./adapter/http&#x27;</span>);<br>    &#125;<br>   <span class="hljs-keyword">return</span> adapter;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面几行代码，可以看出：XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能；process 对象是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。原来作者是通过判断 XMLHttpRequest 和 process 这两个全局变量来判断程序的运行环境的，从而在不同的环境提供不同的 http 请求模块，实现客户端和服务端程序的兼容。</p>
<h3 id="axios-相比原生-ajax-的优点"><a href="#axios-相比原生-ajax-的优点" class="headerlink" title="axios 相比原生 ajax 的优点"></a>axios 相比原生 ajax 的优点</h3><p>ajax 的缺点</p>
<ul>
<li>本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮</li>
<li>基于原生的 XHR 开发，XHR 本身的架构不清晰。</li>
<li>JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打包的方案又不能享受 CDN 服务）</li>
<li>不符合关注分离（Separation of Concerns）的原则</li>
<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
<h3 id="说下你了解的-axios-相关配置属性？"><a href="#说下你了解的-axios-相关配置属性？" class="headerlink" title="说下你了解的 axios 相关配置属性？"></a>说下你了解的 axios 相关配置属性？</h3><ul>
<li><p><code>url</code>是用于请求的服务器 URL</p>
</li>
<li><p><code>method</code>是创建请求时使用的方法,默认是 get</p>
</li>
<li><p><code>baseURL</code>将自动加在<code>url</code>前面，除非<code>url</code>是一个绝对 URL。它可以通过设置一个<code>baseURL</code>便于为 axios 实例的方法传递相对 URL</p>
</li>
<li><p><code>transformRequest</code>允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法</p>
</li>
<li><p><code>headers</code>是即将被发送的自定义请求头<br>headers:{‘X-Requested-With’:’XMLHttpRequest’},</p>
</li>
<li><p><code>params</code>是即将与请求一起发送的 URL 参数，必须是一个无格式对象(plainobject)或 URLSearchParams 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">params</span>: &#123;<br>  <span class="hljs-attr">ID</span>: <span class="hljs-number">12345</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>auth</code>表示应该使用 HTTP 基础验证，并提供凭据<br>这将设置一个<code>Authorization</code>头，覆写掉现有的任意使用<code>headers</code>设置的自定义<code>Authorization</code>头</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">auth</span>:&#123;<br><span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;janedoe&#x27;</span>,<br><span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;s00pers3cret&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>‘proxy’定义代理服务器的主机名称和端口，这里的<code>auth</code>表示 HTTP 基础验证应当用于连接代理，并提供凭据<br>这将会设置一个<code>Proxy-Authorization</code>头，覆写掉已有的通过使用<code>header</code>设置的自定义<code>Proxy-Authorization</code>头。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-attr">proxy</span>:&#123;<br>    <span class="hljs-attr">host</span>:<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>    <span class="hljs-attr">port</span>:<span class="hljs-number">9000</span>,<br>    <span class="hljs-attr">auth</span>::&#123;<br>        <span class="hljs-attr">username</span>:<span class="hljs-string">&#x27;mikeymike&#x27;</span>,<br>        <span class="hljs-attr">password</span>:<span class="hljs-string">&#x27;rapunz3l&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="什么是-axios-拦截器"><a href="#什么是-axios-拦截器" class="headerlink" title="什么是 axios 拦截器"></a>什么是 axios 拦截器</h3><ul>
<li><p>什么是拦截器： 在我们实际发送请求到我们的服务器之前进行拦截处理；在我们的服务器端正式返回数据给具体请求方法前进行拦截。</p>
</li>
<li><p>效果图</p>
<img src="/img/vue-interview/019.jpg" style="zoom:50%;" />
</li>
<li><p>请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上 token，统一做了处理如果以后要改也非常容易。</p>
</li>
<li><p>响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页等。</p>
</li>
</ul>
<h3 id="拦截器如何使用"><a href="#拦截器如何使用" class="headerlink" title="拦截器如何使用"></a>拦截器如何使用</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 添加请求拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-comment">// 在发送请求之前做些什么</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 对响应数据做点什么</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<h3 id="如何创建一个-axios-实例"><a href="#如何创建一个-axios-实例" class="headerlink" title="如何创建一个 axios 实例"></a>如何创建一个 axios 实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> $axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>  配置信息,<br>&#125;);<br><span class="hljs-comment">// 注意创建的axios实例对象是没有all方法的。</span><br></code></pre></td></tr></table></figure>

<h3 id="axios-处理-token-过期后如何继续之前的请求"><a href="#axios-处理-token-过期后如何继续之前的请求" class="headerlink" title="axios 处理 token 过期后如何继续之前的请求"></a>axios 处理 token 过期后如何继续之前的请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 封装 axios 请求模块</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/store&#x27;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router&#x27;</span>;<br><br><span class="hljs-comment">// axios.create 方法：复制一个 axios</span><br><span class="hljs-keyword">const</span> request = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://xxxx.cn/&#x27;</span>, <span class="hljs-comment">// 基础路径</span><br>&#125;);<br><br><span class="hljs-comment">// 请求拦截器  【携带token】</span><br>request.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-keyword">const</span> user = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>;<br>    <span class="hljs-keyword">if</span> (user) &#123;<br>      config.<span class="hljs-property">headers</span>.<span class="hljs-property">Authorization</span> = <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;user.token&#125;</span>`</span>;<br>    &#125;<br>    <span class="hljs-comment">// Do something before request is sent</span><br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Do something with request error</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 响应拦截器</span><br>request.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-comment">// 响应成功进入第1个函数</span><br>  <span class="hljs-comment">// 该函数的参数是响应对象</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// Any status code that lie within the range of 2xx cause this function to trigger</span><br>    <span class="hljs-comment">// Do something with response data</span><br>    <span class="hljs-keyword">return</span> response;<br>  &#125;,<br>  <span class="hljs-comment">// 响应失败进入第2个函数，该函数的参数是错误对象</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// Any status codes that falls outside the range of 2xx cause this function to trigger</span><br>    <span class="hljs-comment">// Do something with response error</span><br>    <span class="hljs-comment">// 如果响应码是 401 ，则请求获取新的 token</span><br><br>    <span class="hljs-comment">// 响应拦截器中的 error 就是那个响应的错误对象</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">dir</span>(error);<br>    <span class="hljs-keyword">if</span> (error.<span class="hljs-property">response</span> &amp;&amp; error.<span class="hljs-property">response</span>.<span class="hljs-property">status</span> === <span class="hljs-number">401</span>) &#123;<br>      <span class="hljs-comment">// 校验是否有 refresh_token</span><br>      <span class="hljs-keyword">const</span> user = store.<span class="hljs-property">state</span>.<span class="hljs-property">user</span>;<br><br>      <span class="hljs-keyword">if</span> (!user || !user.<span class="hljs-property">refresh_token</span>) &#123;<br>        router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br><br>        <span class="hljs-comment">// 代码不要往后执行了</span><br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      <span class="hljs-comment">// 如果有refresh_token，则请求获取新的 token</span><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">axios</span>(&#123;<br>          <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>          <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://xxxx/authorizations&#x27;</span>, <span class="hljs-comment">// 更新token的地址</span><br>          <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-title class_">Authorization</span>: <span class="hljs-string">`Bearer <span class="hljs-subst">$&#123;user.refresh_token&#125;</span>`</span>,<br>          &#125;,<br>        &#125;);<br><br>        <span class="hljs-comment">// 如果获取成功，则把新的 token 更新到容器中</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;刷新 token  成功&#x27;</span>, res);<br>        store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;setUser&#x27;</span>, &#123;<br>          <span class="hljs-attr">token</span>: res.<span class="hljs-property">data</span>.<span class="hljs-property">data</span>.<span class="hljs-property">token</span>, <span class="hljs-comment">// 最新获取的可用 token</span><br>          <span class="hljs-attr">refresh_token</span>: user.<span class="hljs-property">refresh_token</span>, <span class="hljs-comment">// 还是原来的 refresh_token</span><br>        &#125;);<br><br>        <span class="hljs-comment">// 把之前失败的用户请求继续发出去</span><br>        <span class="hljs-comment">// config 是一个对象，其中包含本次失败请求相关的那些配置信息，例如 url、method 都有</span><br>        <span class="hljs-comment">// return 把 request 的请求结果继续返回给发请求的具体位置</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(error.<span class="hljs-property">config</span>); <span class="hljs-comment">// 【核心：继续之前的上一次请求】</span><br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-comment">// 如果获取失败，直接跳转 登录页</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求刷线 token 失败&#x27;</span>, err);<br>        router.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> request;<br></code></pre></td></tr></table></figure>

<h3 id="vue-中如何使用-axios"><a href="#vue-中如何使用-axios" class="headerlink" title="vue 中如何使用 axios"></a>vue 中如何使用 axios</h3><ul>
<li>安装 axios <code>npm i axios -S</code></li>
</ul>
<p>vue 中使用 axios 一般主要是 2 中方法</p>
<ul>
<li><p><strong>方法 1：直接将 axios 或者 axios 的实例挂载到 vue 的原型上面，这样在所有的组件里面都可以直接使用；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// main.js中</span><br><br>此处很多其他代码...,<br><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>  <span class="hljs-comment">// 导入</span><br><span class="hljs-keyword">const</span> $axios = axios.<span class="hljs-title function_">create</span>(&#123; <span class="hljs-comment">// 创建axios实例</span><br>    <span class="hljs-attr">baseUrl</span>:<span class="hljs-string">&quot;基准地址&quot;</span>,<br>    <span class="hljs-attr">timeout</span>:<span class="hljs-number">3000</span><br>&#125;)<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$axios</span> = $axios  <span class="hljs-comment">// 挂载到vue原型上面</span><br><br>此处很多其他代码...,<br></code></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 任意组件中  通过this.$axios 直接获取实例然后调用即可</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$axios</span>.<span class="hljs-property">get</span>/<span class="hljs-title function_">post</span>(...)<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>方法 2：封装单独的 axios，且将所有的数据请求独立到 api 目录，然后将请求方法传递到页面使用，实际工作里面这种用的最多</strong></p>
<ul>
<li><p><strong>创建一个 axios 实例，配置基本信息，和拦截器 放在<code>utils/http.js</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;<br><br><span class="hljs-comment">// 创建一个axios实例</span><br><span class="hljs-keyword">let</span> $axios = axios.<span class="hljs-title function_">create</span>(&#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;http://122.51.249.55:3000/index.php/Api/&#x27;</span>, <span class="hljs-comment">// 基准前缀地址！</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 请求时长！</span><br>&#125;);<br><br><span class="hljs-comment">// 添加请求拦截器</span><br>$axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">config</span>) &#123;<br>    <span class="hljs-keyword">return</span> config;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对请求错误做些什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 添加响应拦截器</span><br>$axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) &#123;<br>    <span class="hljs-comment">// 对数据进行处理</span><br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">data</span>.<span class="hljs-property">status</span> == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>.<span class="hljs-property">result</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">alert</span>(response.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// 对响应错误做点什么</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>);<br><br><span class="hljs-comment">// 暴露axios实例！</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> $axios;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>创建<code>api/index.js</code> 文件，文件里面的为请求数据的方法，返回 promise 对象，可以让模板里面直接读取数据</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 导入axios实例</span><br><span class="hljs-keyword">import</span> $axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/http&#x27;</span>;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>; <span class="hljs-comment">// 因为axios实例没有all方法，所以还是要导入axios</span><br><br><span class="hljs-comment">// 获取首页相关数据</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getIndex</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> p1 = $axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/Index/favourite&#x27;</span>);<br>  <span class="hljs-keyword">let</span> p2 = $axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/Index/home&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">all</span>([p1, p2]); <span class="hljs-comment">// 返回promise对象</span><br>&#125;<br><span class="hljs-comment">// 获取商品列表</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getList</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> $axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;Good/list&#x27;</span>, &#123; <span class="hljs-attr">params</span>: data &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>在组件中调用封装的业务请求方法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; getIndex, getList &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/common/request&#x27;</span>; <span class="hljs-comment">// 导入数据请求方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// 要加上async 修饰符</span><br>  <span class="hljs-keyword">async</span> <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">indexdata</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getIndex</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">list</span> = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getList</span>(&#123; <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">10</span> &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;数据请求出错&#x27;</span>);<br>    &#125;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="五、vue-cli"><a href="#五、vue-cli" class="headerlink" title="五、vue-cli"></a>五、vue-cli</h2><h3 id="vue-等单页面应用及其优缺点"><a href="#vue-等单页面应用及其优缺点" class="headerlink" title="vue 等单页面应用及其优缺点"></a><strong>vue 等单页面应用及其优缺点</strong></h3><p><strong>缺点：</strong></p>
<blockquote>
<p>不支持低版本的浏览器，最低只支持到 IE9；<br>不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；<br>第一次加载首页耗时相对长一些；<br>不可以使用浏览器的导航按钮需要自行实现前进、后退。</p>
</blockquote>
<p><strong>优点：</strong></p>
<blockquote>
<p>无刷新体验,提升了用户体验；<br>前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；<br>API 共享，同一套后端程序代码不用修改就可以用于 Web 界面、手机、平板等多种客户端<br>用户体验好、快，内容的改变不需要重新加载整个页面。</p>
</blockquote>
<h3 id="vue-cli-如何安装-2-x-版本模板"><a href="#vue-cli-如何安装-2-x-版本模板" class="headerlink" title="vue-cli 如何安装 2.x 版本模板"></a>vue-cli 如何安装 2.x 版本模板</h3><ul>
<li><p>查看 vue-cli 版本号</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">vue -V<br>或者<br>vue <span class="hljs-comment">--version</span><br><br>如果是vue不是内部活外部命令说明根本没有装脚手架<br></code></pre></td></tr></table></figure>
</li>
<li><p>安装 vue-cli 最新脚手架</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span>  i  @vue<span class="hljs-regexp">/cli -g   /</span>/ 全局安装脚手架<br></code></pre></td></tr></table></figure>
</li>
<li><p>新脚手架创建项目</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">vue <span class="hljs-keyword">create</span> 项目名<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>如何用新脚手架拉取老脚手架模板</strong></p>
<p><strong>安装</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">npm install -g @vue/cli-init<br></code></pre></td></tr></table></figure>

<p><strong>初始化项目</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue-cli 2.x 初始化项目命令</span><br>vue init webpack 项目名<br></code></pre></td></tr></table></figure>

<p><strong>启动项目</strong></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">npm run dev<br>npm start<br><br><span class="hljs-comment">// 打包</span><br>npm run build<br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="vue-cli2-x-如何配置-less"><a href="#vue-cli2-x-如何配置-less" class="headerlink" title="vue-cli2.x 如何配置 less"></a>vue-cli2.x 如何配置 less</h3><p>安装模块</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">npm install less@<span class="hljs-number">3.9</span> less-loader@<span class="hljs-number">5.0</span><span class="hljs-number">.0</span> --save-dev    <span class="hljs-comment">// 注意版本号，这里写的版本号实测过没有问题，版本太高可能编译出错</span><br></code></pre></td></tr></table></figure>

<h3 id="vue-cli2-x-如何配置跨域"><a href="#vue-cli2-x-如何配置跨域" class="headerlink" title="vue-cli2.x 如何配置跨域"></a>vue-cli2.x 如何配置跨域</h3><p>然后<code>config/index.js</code>里</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"> <span class="hljs-attr">dev</span>: &#123;<br>  ...,<br>  <span class="hljs-attr">proxyTable</span>: &#123;<br>    <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;  <span class="hljs-comment">//使用&quot;/api&quot;来代替</span><br>      <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://xxxx:xx/xx&#x27;</span>, <span class="hljs-comment">//接口域名</span><br>      <span class="hljs-attr">changeOrigin</span>:<span class="hljs-literal">true</span>, <span class="hljs-comment">//改变源</span><br>      <span class="hljs-attr">pathRewrite</span>: &#123;<br>        <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//路径重写</span><br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="vue-cli2-x-如何进行打包配置"><a href="#vue-cli2-x-如何进行打包配置" class="headerlink" title="vue-cli2.x 如何进行打包配置"></a>vue-cli2.x 如何进行打包配置</h3><ul>
<li><p>默认打包出来的 index.html 和静态资源文件是绝对路径关系，很多时候需要使用相对路径关系，方便部署！</p>
</li>
<li><p>操作</p>
<ul>
<li><p><strong>config/index.js</strong></p>
<img src="/img/vue-interview/016.jpg" style="zoom:50;" />
</li>
<li><p><strong>build/webpack.prod.conf.js</strong></p>
<img src="/img/vue-interview/017.jpg" style="zoom:50;" />
</li>
<li><p><strong>build/utils.js</strong></p>
<img src="/img/vue-interview/018.jpg" style="zoom:50;" />

</li>
</ul>
</li>
</ul>
<h2 id="六、SSR"><a href="#六、SSR" class="headerlink" title="六、SSR"></a>六、SSR</h2><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h3 id="vue-常用-UI-库有哪些"><a href="#vue-常用-UI-库有哪些" class="headerlink" title="vue 常用 UI 库有哪些"></a>vue 常用 UI 库有哪些</h3><h3 id="vue-常用插件"><a href="#vue-常用插件" class="headerlink" title="vue 常用插件"></a>vue 常用插件</h3><h3 id="vue-项目如何实现权限管理"><a href="#vue-项目如何实现权限管理" class="headerlink" title="vue 项目如何实现权限管理"></a>vue 项目如何实现权限管理</h3><ul>
<li>权限管理是基于 RBAC 完成的， 就是不同用户会有不同的角色，每个角色会有不同的菜单信息，从而决定了我们的用户能看到不同的菜单页面。</li>
<li>权限前后端都要做：后端是做接口访问权限，保证数据安全；前端做权限是保证用户访问到不同的页面，操作不同的功能。</li>
<li>前端如何做：<ul>
<li><strong>最核心的是让不同的用户有不同的路由映射表，也就觉得了他可以看到不同的页面，且不能访问他没有路由映射的页面。</strong></li>
<li>代码逻辑：<ul>
<li>登录成功之后，获取到 token，跳转到系统首页</li>
<li>导航守卫里面判断是否有角色信息，<ul>
<li>如果没有就拉取用户信息，获取用户资料，</li>
<li>结束之后再去请求该用户所对应的的角色的 菜单（路由）列表信息。</li>
<li>有时候可能需要处理成路由映射的格式，</li>
<li>处理完成之后，通过 <strong>router.addRoutes</strong>方法添加到路由映射表里面。</li>
<li>这样就决定了不同的用户有不同的映射表，访问不同的页面。</li>
</ul>
</li>
<li><strong>如果是节点级别的权限管理，后端返回该用户所对应角色的所有可以操作的节点标识符，我们通过自定义指令实现判断这些标识符所对应的按钮是否可以显示。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="说说你对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#说说你对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="说说你对 SPA 单页面的理解，它的优缺点分别是什么？"></a>说说你对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>是一种只需要将单个页面加载到服务器之中的 web 应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个 index.html 文件，它所需的 js，css 等会在显示时统一加载，部分页面按需加载。url 地址变化时不会向服务器在请求页面，通过路由才实现页面切换。</p>
<p>优点：</p>
<ul>
<li>良好的交互体验，用户不需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示流畅；</li>
<li>良好的前后端工作分离模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>SEO 难度较高，由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</p>
</li>
<li><p>首屏加载过慢（初次加载耗时多）</p>
</li>
</ul>
<h3 id="SPA-单页面的实现方式有哪些？"><a href="#SPA-单页面的实现方式有哪些？" class="headerlink" title="SPA 单页面的实现方式有哪些？"></a>SPA 单页面的实现方式有哪些？</h3><ul>
<li><p>在 hash 模式中，在 window 上监听 <code>hashchange(onhashChange)</code> 事件（地址栏中 hash 变化触发）驱动界面变化；</p>
</li>
<li><p>在 history 模式中，在 window 上监听 <code>popstate(onpopstate)</code> 事件（浏览器的前进或后退按钮的点击触发）驱动界面变化，监听 a 链接点击事件用 <code>history.pushState</code>、<code>history.replaceState</code> 方法驱动界面变化；<code>pushState</code>、<code>replaceState</code>不会触发 <code>popState</code> 事件</p>
</li>
<li><p>直接在界面用显示隐藏事件驱动界面变化。</p>
</li>
</ul>
<h3 id="Vue-如何优化首页加载速度"><a href="#Vue-如何优化首页加载速度" class="headerlink" title="Vue 如何优化首页加载速度"></a>Vue 如何优化首页加载速度</h3><p><strong>减少请求的次数</strong></p>
<ul>
<li>1.请求合并：将同一时间需要的 js 合并，目的是节省 dns 查找的时间</li>
<li>2.按需加载<ul>
<li>1.单页应用下的按照路由的需要加载</li>
<li>2.缓存</li>
</ul>
</li>
<li>3.css sprite base64 iconfont</li>
<li>4.cdn 托管</li>
<li>5.延迟加载：图片的延迟加载：（就是先不设置 img 的 src 属性，等合适的时机（比如滚动、滑动、出现在视窗内等）再把图片真实 url 放到 img 的 src 属性上。） js 的延迟加载：</li>
</ul>
<p><strong>减少量</strong></p>
<ul>
<li><p>1.精简代码（tree-shaking）</p>
<ul>
<li><p>(1)去除无用的代码</p>
</li>
<li><p>(2)规范些代码的方式</p>
</li>
<li><p>(3)外部 cdn 的引入</p>
</li>
</ul>
</li>
<li><p>2.懒加载 —路由的懒加载</p>
</li>
<li><p>3.压缩 —</p>
<ul>
<li>（1）webpack 压缩 UglifyJsPlugin</li>
<li>（2）gzip 压缩</li>
<li>(3)图片压缩、JPG 优化</li>
</ul>
</li>
<li><p>4.缓存 http 代码：—浏览器的强缓存（max-age Etag）和协商(弱)缓存（last-modified）</p>
</li>
<li><p>5.第三方组件—第三方组件作为外部依赖使用，会被打爆进业务代码。</p>
</li>
<li><p>6.按需加载 —</p>
<ul>
<li>（1）第三方库和工具的按需加载，如 echarts</li>
<li>（2）选择更优的工具 day.js 代替 moment</li>
<li>（3）可用代码拆分（Code-splitting）只传送用户需要的代码</li>
</ul>
</li>
</ul>
<p><strong>减少内存的消耗</strong></p>
<ul>
<li>1.减少全局变量；</li>
<li>2.减少全局组件；</li>
<li>3.减少 dom 操作， 减少 DOM 访问，使用事件代理<ol>
<li>css 样式放在页面前面</li>
<li>延迟 js 加载</li>
<li>避免 CSS 表达式，避免@import</li>
</ol>
</li>
</ul>

    

    

    
    <div class="declare"> 
      <ul class="post-copyright">
        <li>
          <strong>本文作者：</strong>
          luckyship
        </li>
        <li>
          <strong>本文链接：</strong>
          <a href="https://luckyship.github.io/2021/09/12/2021-09-12-vue-knowledge/" title="Vue你了解哪些" target="_blank">https://luckyship.github.io/2021/09/12/2021-09-12-vue-knowledge/</a>
        </li>
        
        <li>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus/blob/master/LICENSE" rel="external nofollow" target="_blank">MIT</a> 许可协议。转载请注明出处！
        </li>
        
      </ul>
    </div>
    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">javascript</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">vue</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/review//" class="article-tag-list-link color2">review</a>
        		</li>
      		
		</ul>
	</div>


    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=https://luckyship.github.io/2021/09/12/2021-09-12-vue-knowledge/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
    <a href="/2021/09/20/2021-09-20-web-framed-diff/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          前端3大框架原理比较分析
        
      </div>
    </a>
  
  
    <a href="/2021/09/12/2021-09-12-diff-calculate/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">diff算法</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>







  <section id="comments" style="margin:10px;padding:10px;background:#fff;">
    <div id="vcomment" class="comment"></div>
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<script src="/js/valine.js" async></script>
<script async>
  var notify = 'true' == true ? true : false;
  var verify = 'false' == true ? true : false;
  window.onload = function () {
    new Valine({
      el: '.comment',
      notify: notify,
      verify: verify,
      app_id: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      app_key: 'fstd3ABXC89jc5VDSe6ANGV6',
      placeholder: 'Just go go',
      avatar: 'mm',
    });
  };
</script>

  </section>










          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020-2025 <a href="https://luckyship.github.io/" target="_blank">luckyship</a>
    	</div>
      	<div class="footer-right">
			
			
      		GitHub:<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank">hexo-theme-yilia-plus</a> by Litten
      	</div>
    </div>
  </div>

  
	<script async src="/lib/busuanzi.pure.js"></script>
	
  
  
	
	<span id="busuanzi_container_site_pv" style="display:none">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	        <span class="post-meta-divider" >|</span>
	</span>
  	<span id="busuanzi_container_site_uv" style='display:none'>
  		本站访客数<span id="busuanzi_value_site_uv"></span>人
  	</span>
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>




<!--  -->

<script>
  /* 标签页标题切换 */
  var originTitle = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function () {
    if (document.hidden) {
      document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
      titleTime = setTimeout(function () {
        document.title = originTitle;
      }, 2000);
    }
  });
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">搜索</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mongo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">ruby</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">dataTable</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">network</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">base</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">rails</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">kubernetes</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">centos</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">debian</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ubuntu</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">nodejs</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jquery</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">es6</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">npm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">video</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nginx</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">+ vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angular</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">sass</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">less</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angualr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">typescript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">react</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">regexp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">vscode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">regex</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">review</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">tool</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">flutter</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">unicode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">sql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">postgresql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">vite</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">go</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
            <a q-attr="href:path|urlformat">
              <p class="search-content" q-show="matchContent.val">
                <span q-text="matchContent.pre"></span><span class="red" q-text="matchContent.val"></span><span q-text="matchContent.next"></span>
              </p>
            </a>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
        
          
  	  		<div class="aboutme-wrap" id="aboutme">前端攻城狮<br>记录分享自己工作、学习中学到的知识</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script
  type="text/javascript"
  src="/plugins/activate-power-mode/activate-power-mode.js"
></script>
<script>
  document.addEventListener('DOMContentLoaded',function(){
    POWERMODE.colorful = true; // make power mode colorful
    POWERMODE.shake = false; // turn off shake
    document.body.addEventListener('input', POWERMODE);
  });
</script>


  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
  
</body>

</html>

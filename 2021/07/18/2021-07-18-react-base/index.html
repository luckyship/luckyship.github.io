<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <script src="/js/av-min.js"></script>

  <script>
    AV.init({
      appId: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      appKey: 'fstd3ABXC89jc5VDSe6ANGV6',
      serverURLs: {
        push: "https://leancloud.cn",
        stats: "https://leancloud.cn",
        engine: "https://leancloud.cn",
        api: "https://leancloud.cn",
      },
    });
  </script>
  <script async src="/main/js/slider.66b399.js"></script><script async src="/main/js/main.a76a5f.js"></script><script async src="/main/js/mobile.57dfe3.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GWM1JLMFWH"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GWM1JLMFWH")</script>

  <link rel="dns-prefetch" href="https://luckyship.github.io">
  <title>react基础知识 | luckyship</title>
  <meta name="generator" content="hexo-theme-luckyship">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="React 的响应式原理React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新真实 DOM。虚拟DOM 作为一种缓存机制优化了 UI 渲染减少昂贵的 DOM 变化的数量。  开发者只需关注状态转移（数据），当状态发生变化">
<meta property="og:type" content="article">
<meta property="og:title" content="react基础知识">
<meta property="og:url" content="https://luckyship.github.io/2021/07/18/2021-07-18-react-base/index.html">
<meta property="og:site_name" content="luckyship">
<meta property="og:description" content="React 的响应式原理React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新真实 DOM。虚拟DOM 作为一种缓存机制优化了 UI 渲染减少昂贵的 DOM 变化的数量。  开发者只需关注状态转移（数据），当状态发生变化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://cdn.mydearest.cn/blog/images/patch.png">
<meta property="og:image" content="http://cdn.mydearest.cn/blog/images/ssr.png">
<meta property="article:published_time" content="2021-07-18T14:28:03.000Z">
<meta property="article:modified_time" content="2025-08-02T05:46:04.176Z">
<meta property="article:author" content="luckyship">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://cdn.mydearest.cn/blog/images/patch.png">
  
    <link rel="alternative" href="/atom.xml" title="luckyship" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/main/css/index.a76a5f.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script async src="/lib/clickLove.js"></script>
  
  

<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();

</script>



  

</head>


<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #4d4d4d;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/head.jpg" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">luckyship</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" >主页</a></li>
			
				<li><a href="/archives" >归档</a></li>
			
				<li><a href="/comment/" >留言板</a></li>
			
				<li><a href="/website/" >知识库</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">搜索</a>
				
			
				
					<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
				
			
            </nav>

		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" rel="noopener" href="https://github.com/luckyship" title="GitHub" ><i class="icon-github"></i></a>
				
					<a class="gitee" target="_blank" rel="noopener" href="https://gitee.com/luckyship" title="gitee" ><i class="icon-gitee"></i></a>
				
					<a class="blog" target="_blank" rel="noopener" href="https://juejin.cn/user/730534951787662/posts" title="blog" ><i class="icon-blog"></i></a>
				
					<a class="csdn" target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38319625" title="CSDN" ><i class="icon-csdn"></i></a>
				
			</div>
		
		</nav>

		
		  <nav>
			
  <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">React 的响应式原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-React-%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9"><span class="toc-number">2.</span> <span class="toc-text">使用 React 有何优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%95%E7%A4%BA%E7%BB%84%E4%BB%B6-Presentational-component-%E5%92%8C%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6-Container-component-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">3.</span> <span class="toc-text">展示组件(Presentational component)和容器组件(Container component)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-Class-component-%E5%92%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6-Functional-component-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">4.</span> <span class="toc-text">类组件(Class component)和函数式组件(Functional component)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84-%E7%8A%B6%E6%80%81-state-%E5%92%8C%E5%B1%9E%E6%80%A7-props-%E4%B9%8B%E9%97%B4%E6%9C%89%E4%BD%95%E4%B8%8D%E5%90%8C"><span class="toc-number">5.</span> <span class="toc-text">(组件的)状态(state)和属性(props)之间有何不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%87%BA-%E7%BB%84%E4%BB%B6-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">6.</span> <span class="toc-text">指出(组件)生命周期方法的不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E8%AF%A5%E5%9C%A8-React-%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%95%E5%A4%84%E5%8F%91%E8%B5%B7-Ajax-%E8%AF%B7%E6%B1%82"><span class="toc-number">7.</span> <span class="toc-text">应该在 React 组件的何处发起 Ajax 请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6-controlled-component"><span class="toc-number">8.</span> <span class="toc-text">何为受控组件(controlled component)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-React-%E4%B8%AD%EF%BC%8Crefs-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.</span> <span class="toc-text">在 React 中，refs 的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-ref-%E6%96%B9%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">三种 ref 方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-higher-order-component"><span class="toc-number">11.</span> <span class="toc-text">何为高阶组件(higher order component)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E5%B1%9E%E6%80%A7-render-props"><span class="toc-number">12.</span> <span class="toc-text">渲染属性(render props)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-arrow-functions-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">13.</span> <span class="toc-text">使用箭头函数(arrow functions)的优点是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E4%BC%A0%E9%80%92%E7%BB%99-setState-%E7%9A%84%E5%8F%82%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-callback-%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.</span> <span class="toc-text">为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%BB%91%E5%AE%9A-this-%EF%BC%8C%E8%BF%98%E6%9C%89%E5%85%B6%E5%AE%83%E6%96%B9%E5%BC%8F%E5%90%97"><span class="toc-number">15.</span> <span class="toc-text">除了在构造函数中绑定 this ，还有其它方式吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%98%BB%E6%AD%A2%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93"><span class="toc-number">16.</span> <span class="toc-text">怎么阻止组件的渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-%E4%B8%8E-vue-%E6%95%B0%E7%BB%84%E4%B8%AD-key-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">17.</span> <span class="toc-text">react 与 vue 数组中 key 的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD-%E8%B0%83%E7%94%A8-super-props-%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">18.</span> <span class="toc-text">(在构造函数中)调用 super(props) 的目的是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-JSX"><span class="toc-number">19.</span> <span class="toc-text">何为 JSX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%94%A8-React-createElement-%E9%87%8D%E5%86%99%E4%B8%8B%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">20.</span> <span class="toc-text">怎么用 React.createElement 重写下面的代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-Children"><span class="toc-number">21.</span> <span class="toc-text">何为 Children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-React-%E4%B8%AD%EF%BC%8C%E4%BD%95%E4%B8%BA-state"><span class="toc-number">22.</span> <span class="toc-text">在 React 中，何为 state</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%A0%E4%B8%BA%E4%BD%95%E6%8E%92%E6%96%A5-create-react-app"><span class="toc-number">23.</span> <span class="toc-text">你为何排斥 create-react-app</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-redux"><span class="toc-number">24.</span> <span class="toc-text">何为 redux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Redux-%E4%B8%AD%EF%BC%8C%E4%BD%95%E4%B8%BA-store"><span class="toc-number">25.</span> <span class="toc-text">在 Redux 中，何为 store</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-action"><span class="toc-number">26.</span> <span class="toc-text">何为 action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA-reducer"><span class="toc-number">27.</span> <span class="toc-text">何为 reducer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redux-Thunk-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">28.</span> <span class="toc-text">Redux Thunk 的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E7%BA%AF%E5%87%BD%E6%95%B0-pure-function"><span class="toc-number">29.</span> <span class="toc-text">何为纯函数(pure function)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%AD%E9%97%B4%E4%BB%B6%EF%BC%8C%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">30.</span> <span class="toc-text">redux 有哪些中间件，作用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%A1%B9%E7%9B%AE"><span class="toc-number">31.</span> <span class="toc-text">示例项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-dom-%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9-%E6%98%AF%E7%94%A8-JS-%E5%AF%B9%E8%B1%A1%E6%9D%A5%E6%A8%A1%E6%8B%9F%E7%9C%9F%E5%AE%9E-DOM-%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="toc-number">32.</span> <span class="toc-text">虚拟 dom(虚拟节点)是用 JS 对象来模拟真实 DOM 中的节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F-dom"><span class="toc-number">33.</span> <span class="toc-text">为什么使用虚拟 dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-dom-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">34.</span> <span class="toc-text">虚拟 dom 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#diff-%E7%AE%97%E6%B3%95"><span class="toc-number">35.</span> <span class="toc-text">diff 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setState-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">36.</span> <span class="toc-text">setState 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">37.</span> <span class="toc-text">替换的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-html-%E6%96%87%E6%9C%AC"><span class="toc-number">38.</span> <span class="toc-text">插入 html 文本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%89%88%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">39.</span> <span class="toc-text">15 版本的生命周期如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">40.</span> <span class="toc-text">16 版本生命周期如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">41.</span> <span class="toc-text">事件机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-react-%E4%BA%8B%E4%BB%B6%E8%A6%81%E8%87%AA%E5%B7%B1%E7%BB%91%E5%AE%9A-this"><span class="toc-number">42.</span> <span class="toc-text">为什么 react 事件要自己绑定 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-%E5%92%8C%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%B7%B7%E7%94%A8%E5%90%97"><span class="toc-number">43.</span> <span class="toc-text">react 和原生事件的执行顺序是什么，可以混用吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-dom-%E6%AF%94%E6%99%AE%E9%80%9A-dom-%E6%9B%B4%E5%BF%AB%E5%90%97"><span class="toc-number">44.</span> <span class="toc-text">虚拟 dom 比普通 dom 更快吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-dom-%E4%B8%AD%E7%9A%84-typeof-%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">45.</span> <span class="toc-text">虚拟 dom 中的$$typeof 属性的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOC-%E5%9C%A8%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E9%99%85%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">46.</span> <span class="toc-text">HOC 在业务场景中有哪些实际的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOC-%E5%92%8C-mixin-%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">47.</span> <span class="toc-text">HOC 和 mixin 的异同点是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF-react-%E6%8F%90%E4%BE%9B%E7%9A%84-api-hoc-%E5%92%8C-render-props-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">47.1.</span> <span class="toc-text">hooks 有哪些优势(react 提供的 api, hoc 和 render props 开发模式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fiber"><span class="toc-number">48.</span> <span class="toc-text">Fiber</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E4%BA%86%E5%8F%98%E5%8A%A8"><span class="toc-number">49.</span> <span class="toc-text">为什么生命周期有了变动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSR"><span class="toc-number">50.</span> <span class="toc-text">SSR</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">50.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-react-%E6%B2%A1%E6%9C%89%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A"><span class="toc-number">51.</span> <span class="toc-text">为什么 react 没有双向绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-number">52.</span> <span class="toc-text">单向数据流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-%E5%92%8C-vue-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">53.</span> <span class="toc-text">react 和 vue 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-%E4%B8%AD%EF%BC%8CcloneElement-%E4%B8%8E-createElement-%E5%90%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">54.</span> <span class="toc-text">React 中，cloneElement 与 createElement 各是什么，有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Portal-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">55.</span> <span class="toc-text">React Portal 有哪些使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">56.</span> <span class="toc-text">路由传参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#create-react-app-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-number">57.</span> <span class="toc-text">create-react-app 配置文件修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-diff-%E5%92%8C-vue-diff-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">58.</span> <span class="toc-text">react diff 和 vue diff 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-StrictMode-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-number">59.</span> <span class="toc-text">react StrictMode 严格模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react-%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6"><span class="toc-number">60.</span> <span class="toc-text">react 事件的合成机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-gt-%E9%87%8D"><span class="toc-number">61.</span> <span class="toc-text">redux 存在的问题 &#x3D;&gt; 重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-UI-%E5%BA%93"><span class="toc-number">62.</span> <span class="toc-text">常用 UI 库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6"><span class="toc-number">63.</span> <span class="toc-text">常用组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number"></span> <span class="toc-text">参考</span></a>
  </div>


		  </nav>
		
	</header>
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
      <a class="forkMe" style="position:absolute;z-index:999;top:0;right:0.5em;"
        href="https://github.com/luckyship/myblog" target="_blank">
        <img src="/img/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/img/head.jpg" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">luckyship</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/luckyship" title="GitHub"><i class="icon-github"></i></a>
			        
						<a class="gitee" target="_blank" href="https://gitee.com/luckyship" title="gitee"><i class="icon-gitee"></i></a>
			        
						<a class="blog" target="_blank" href="https://juejin.cn/user/730534951787662/posts" title="blog"><i class="icon-blog"></i></a>
			        
						<a class="csdn" target="_blank" href="https://blog.csdn.net/sinat_38319625" title="CSDN"><i class="icon-csdn"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/archives">归档</a></li>
		        
					<li style="width: 25%"><a href="/comment/">留言板</a></li>
		        
					<li style="width: 25%"><a href="/website/">知识库</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-2021-07-18-react-base" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      react基础知识
    </h1>
  


  
   
<span id="busuanzi_container_page_pv" style="display: none" class="archive-article-date">
  <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
</span>


<a href="/2021/07/18/2021-07-18-react-base/" class="archive-article-date">
  <!-- <time datetime="2021-07-18T14:28:03.000Z" title="发布时间" itemprop="datePublished"><i class="icon-calendar icon"></i>2021-07-18</time>
        <time datetime="2025-08-02T05:46:04.176Z" title="最后更新" itemprop="datePublished">
                <svg t="1614416122145" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="535" width="16" height="16"><path d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z" p-id="536" fill="#999999"></path><path d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z" p-id="537" fill="#999999"></path></svg>
                2025-08-02</time> -->

  
  <time datetime="2025-08-02T05:46:04.176Z" title="最后更新" itemprop="datePublished">
    <svg
      t="1614416122145"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="535"
      width="16"
      height="16"
    >
      <path
        d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z"
        p-id="536"
        fill="#999999"
      ></path>
      <path
        d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z"
        p-id="537"
        fill="#999999"
      ></path>
    </svg>
    <span >
      2021-07-18
      <span style="font-size: 10px"> (更新于2025-08-02)
    </span>
  </time>
  
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">10.3k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">39分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h3 id="React-的响应式原理"><a href="#React-的响应式原理" class="headerlink" title="React 的响应式原理"></a>React 的响应式原理</h3><p>React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 <code>diff</code> 的结果来更新真实 DOM。虚拟<br>DOM 作为一种缓存机制优化了 UI 渲染减少昂贵的 DOM 变化的数量。</p>
<ol>
<li>开发者只需关注状态转移（数据），当状态发生变化，React 框架会自动根据新的状态重新构建 UI。</li>
<li>React 框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过 Diff 算法，计算出树中变化的部分，然后只更新变化的部分（DOM 操作），从而避免整棵树重构，提高性能。状态变化后<br>React 框架并不会立即去计算并渲染 DOM 树的变化部分，相反，React 会在 DOM 的基础上建立一个抽象层，即虚拟 DOM 树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟 DOM，最后再批量同步到真实 DOM<br>中，而不是每次改变都去操作一下 DOM。</li>
</ol>
<p>为什么不能每次改变都直接去操作 DOM 树？<br>这是因为在浏览器中每一次 DOM 操作都有可能引起浏览器的重绘或回流：</p>
<ul>
<li>如果 DOM 只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。</li>
<li>如果 DOM 树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。<br>而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对 DOM 进行操作，这会带来性能问题，而批量操作只会触发一次 DOM 更新。<span id="more"></span>

</li>
</ul>
<h3 id="使用-React-有何优点"><a href="#使用-React-有何优点" class="headerlink" title="使用 React 有何优点"></a>使用 React 有何优点</h3><ul>
<li>只需查看 <code>render</code> 函数就会很容易知道一个组件是如何被渲染的</li>
<li>JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的</li>
<li>支持服务端渲染，这可以改进 SEO 和性能</li>
<li>易于测试</li>
<li>React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用</li>
</ul>
<h3 id="展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>展示组件(Presentational component)和容器组件(Container component)之间有何不同</h3><p>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</p>
<p>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 <code>Flux actions</code> ，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</p>
<h3 id="类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>类组件(Class component)和函数式组件(Functional component)之间有何不同</h3><ul>
<li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 <code>store</code> 并维持状态</li>
<li>当组件仅是接收 <code>props</code>，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件</li>
</ul>
<h3 id="组件的-状态-state-和属性-props-之间有何不同"><a href="#组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="(组件的)状态(state)和属性(props)之间有何不同"></a>(组件的)状态(state)和属性(props)之间有何不同</h3><p><code>State</code> 是一种数据结构，用于组件挂载时所需数据的默认值。 <code>State</code> 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</p>
<p><code>Props</code> (properties 的简写)则是组件的配置。 <code>props</code> 由父组件传递给子组件，并且就子组件而言， <code>props</code> 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</p>
<h3 id="指出-组件-生命周期方法的不同"><a href="#指出-组件-生命周期方法的不同" class="headerlink" title="指出(组件)生命周期方法的不同"></a>指出(组件)生命周期方法的不同</h3><ul>
<li><code>componentWillMount</code> – 多用于根组件中的应用程序配置</li>
<li><code>componentDidMount</code> – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成</li>
<li><code>componentWillReceiveProps</code> – 这个周期函数作用于特定的 prop 改变导致的 state 转换</li>
<li><code>shouldComponentUpdate</code> – 如果你担心组件过度渲染，<code>shouldComponentUpdate</code> 是一个改善性能的地方，因为如果组件接收了新的 <code>prop</code>， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染</li>
<li><code>componentWillUpdate</code> – 很少使用。它可以用于代替组件的 <code>componentWillReceiveProps</code> 和 <code>shouldComponentUpdate</code>(但不能访问之前的 props)</li>
<li><code>componentDidUpdate</code> – 常用于更新 DOM，响应 prop 或 state 的改变</li>
<li><code>componentWillUnmount</code> – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器</li>
</ul>
<h3 id="应该在-React-组件的何处发起-Ajax-请求"><a href="#应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="应该在 React 组件的何处发起 Ajax 请求"></a>应该在 React 组件的何处发起 Ajax 请求</h3><p>在 React 组件中，应该在 <code>componentDidMount</code> 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 <code>componentDidMount</code> 中发起网络请求将保证这有一个组件可以更新了。</p>
<h3 id="何为受控组件-controlled-component"><a href="#何为受控组件-controlled-component" class="headerlink" title="何为受控组件(controlled component)"></a>何为受控组件(controlled component)</h3><p>在 HTML 中，类似 <code>&lt;input&gt;</code> , <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code> 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 <code>onChange</code> 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p>
<h3 id="在-React-中，refs-的作用是什么"><a href="#在-React-中，refs-的作用是什么" class="headerlink" title="在 React 中，refs 的作用是什么"></a>在 React 中，refs 的作用是什么</h3><p>Refs 可以用于获取一个 DOM 节点或者 React 组件(组件实例)的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。</p>
<h3 id="三种-ref-方式"><a href="#三种-ref-方式" class="headerlink" title="三种 ref 方式"></a>三种 ref 方式</h3><ol>
<li>string 类型绑定<br>类似于 vue 中的 ref 绑定方式，可以通过 this.refs. 绑定的 ref 的名字获取到节点 dom，注意的是这种方式已经不被最新版的 react 推荐使用，有可能会在未来版本中遗弃。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">focus = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">refs</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-title function_">focus</span>()<br>  &#125; &lt;input ref = <span class="hljs-string">&quot;inputRef&quot;</span> /&gt;<br><br>  <span class="hljs-comment">// 获取子组件的div</span><br>  <span class="hljs-comment">// 父组件</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">myRef</span> = <span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">this.state.myDiv</span></span></span><br><span class="hljs-tag"><span class="language-xml">  &#125;/&gt;</span></span><br><span class="hljs-comment">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">  <span class="hljs-attr">this.props.myRef</span></span></span><br><span class="hljs-tag"><span class="language-xml">&#125; &gt;</span> 我是子组件 <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>react.CreateRef()<br>通过在 class 中使用 React.createRef()方法创建一些变量，可以将这些变量绑定到标签的 ref 中，该变量的 current 则指向绑定的标签 dom。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">inputRef = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createRef</span>()<br>focus = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125; &lt;<br>  input ref = &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span><br>  &#125;<br>/&gt;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>函数形式<br>在 class 中声明函数，在函数中绑定 ref 使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">inputRef = <span class="hljs-literal">null</span><br>focus = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span>.<span class="hljs-title function_">focus</span>()<br>  &#125; &lt;<br>  input ref = &#123;<br>    <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">inputRef</span> = el<br>  &#125;<br>/&gt;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>useRef(实例属性)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">UseRefDemo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span> <span class="hljs-keyword">as</span> any)<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFocusInput</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>()<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> ( &lt;div&gt;<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span> = <span class="hljs-string">&#123;</span></span></span><br><span class="hljs-tag"><span class="language-xml">      <span class="hljs-attr">inputRef</span></span></span><br><span class="hljs-tag"><span class="language-xml">    &#125;</span></span><br><span class="hljs-tag"><span class="language-xml">    /&gt;</span></span> &lt;<br>    button onClick = &#123;<br>      handleFocusInput<br>    &#125; &gt; click focus &lt; /button&gt; &lt;<br>    /div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>forwardRef(获取组件内的引用)</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 子组件</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Child</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> ( &lt;<br>      div ref = &#123;<br>        ref<br>      &#125; &gt; &#123;<br>        props.<span class="hljs-property">txt</span><br>      &#125; &lt; /div&gt;<br>    )<br>  &#125;)<br><br>  <span class="hljs-comment">// 父组件</span><br>  &lt;<br>  <span class="hljs-title class_">Child</span> ref = &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">myDiv</span><br>  &#125;<br>txt = <span class="hljs-string">&quot;parent props txt&quot;</span> / &gt;<br></code></pre></td></tr></table></figure>

<p>注意: react 并不推荐过度使用 ref，如果能通过 state 做到的事情，就不应该使用 refs 在你的 app 中“让事情发生”。过度使用 ref 并不符合数据驱动的思想。</p>
<h3 id="何为高阶组件-higher-order-component"><a href="#何为高阶组件-higher-order-component" class="headerlink" title="何为高阶组件(higher order component)"></a>何为高阶组件(higher order component)</h3><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 <code>connect</code> 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。<br>装饰器@decoration<br>优点:</p>
<ul>
<li>逻辑复用</li>
<li>不影响被包裹组件的逻辑</li>
</ul>
<p>缺点:</p>
<ul>
<li>传递的 props 和包裹组件的 props 发生重名会覆盖</li>
<li>组件嵌套导致层级过深</li>
</ul>
<h3 id="渲染属性-render-props"><a href="#渲染属性-render-props" class="headerlink" title="渲染属性(render props)"></a>渲染属性(render props)</h3><p>Render prop 是一个告知组件需要渲染什么内容的函数 prop<br>优点:</p>
<ul>
<li>逻辑复用</li>
<li>数据共享</li>
</ul>
<p>缺点:</p>
<ul>
<li>嵌套</li>
<li>无法在 return 语句外访问数据</li>
</ul>
<h3 id="使用箭头函数-arrow-functions-的优点是什么"><a href="#使用箭头函数-arrow-functions-的优点是什么" class="headerlink" title="使用箭头函数(arrow functions)的优点是什么"></a>使用箭头函数(arrow functions)的优点是什么</h3><ul>
<li>作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 <code>this</code> 值(在构造函数中是新对象；在严格模式下，函数调用中的 <code>this</code> 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 <code>this</code> 值。</li>
<li>简单：箭头函数易于阅读和书写</li>
<li>清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 <code>this</code> 的值</li>
</ul>
<h3 id="为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h3><p>因为 <code>this.props</code> 和 <code>this.state</code> 的更新可能是异步的，不能依赖它们的值去计算下一个 state。setState 在生命周期里是异步的，第二个参数是组件重新渲染完成后的回调。</p>
<h3 id="除了在构造函数中绑定-this-，还有其它方式吗"><a href="#除了在构造函数中绑定-this-，还有其它方式吗" class="headerlink" title="除了在构造函数中绑定 this ，还有其它方式吗"></a>除了在构造函数中绑定 <code>this</code> ，还有其它方式吗</h3><p>在 constructor 里使用 bind。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<h3 id="怎么阻止组件的渲染"><a href="#怎么阻止组件的渲染" class="headerlink" title="怎么阻止组件的渲染"></a>怎么阻止组件的渲染</h3><p>在组件的 <code>render</code> 方法中返回 <code>null</code> 并不会影响触发组件的生命周期方法</p>
<h3 id="react-与-vue-数组中-key-的作用是什么"><a href="#react-与-vue-数组中-key-的作用是什么" class="headerlink" title="react 与 vue 数组中 key 的作用是什么"></a>react 与 vue 数组中 key 的作用是什么</h3><p>diff 算法需要比对虚拟 dom 的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode 会首先判断 key 和标签名是否一致，如果一致再去判断子节点一致，使用 key 可以帮助 diff 算法提升判断的速度，在页面<br>重新渲染时更快消耗更少。</p>
<h3 id="在构造函数中-调用-super-props-的目的是什么"><a href="#在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="(在构造函数中)调用 super(props) 的目的是什么"></a>(在构造函数中)调用 super(props) 的目的是什么</h3><p>在 <code>super()</code> 被调用之前，子类是不能使用 <code>this</code> 的，在 ES2015 中，子类必须在 <code>constructor</code> 中调用 <code>super()</code> 。传递 <code>props</code> 给 <code>super()</code> 的原因则是便于(在子类中)能在 <code>constructor</code> 访问 <code>this.props</code> 。</p>
<h3 id="何为-JSX"><a href="#何为-JSX" class="headerlink" title="何为 JSX"></a>何为 JSX</h3><p>JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 <code>if</code> 语句和 <code>for</code> 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。</p>
<p>缺点：b&amp;&amp; 强转成 boolean 类型 否则如果 b=0 渲染出 0</p>
<h3 id="怎么用-React-createElement-重写下面的代码"><a href="#怎么用-React-createElement-重写下面的代码" class="headerlink" title="怎么用 React.createElement 重写下面的代码"></a>怎么用 React.createElement 重写下面的代码</h3><p>Question：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;greeting&quot;</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br></code></pre></td></tr></table></figure>

<p>Answer：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> element = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(<br>  <span class="hljs-string">&#x27;h1&#x27;</span>,<br>  &#123;<br>    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;greeting&#x27;</span>,<br>  &#125;,<br>  <span class="hljs-string">&#x27;Hello, world!&#x27;</span><br>);<br></code></pre></td></tr></table></figure>

<h3 id="何为-Children"><a href="#何为-Children" class="headerlink" title="何为 Children"></a>何为 <code>Children</code></h3><p>在 JSX 表达式中，一个开始标签(比如 <code>&lt;a&gt;</code> )和一个关闭标签(比如 <code>&lt;/a&gt;</code> )之间的内容会作为一个特殊的属性 <code>props.children</code> 被自动传递给包含着它的组件。</p>
<p>这个属性有许多可用的方法，包括 <code>React. Children.map</code> ， <code>React. Children.forEach</code> ， <code>React. Children.count</code> ， <code>React. Children.only</code> ， <code>React. Children.toArray</code> 。</p>
<h3 id="在-React-中，何为-state"><a href="#在-React-中，何为-state" class="headerlink" title="在 React 中，何为 state"></a>在 React 中，何为 state</h3><p>State 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。</p>
<h3 id="你为何排斥-create-react-app"><a href="#你为何排斥-create-react-app" class="headerlink" title="你为何排斥 create-react-app"></a>你为何排斥 create-react-app</h3><p>在你排斥之前，你并不能去配置 webpack 或 babel presets。</p>
<h3 id="何为-redux"><a href="#何为-redux" class="headerlink" title="何为 redux"></a>何为 redux</h3><p>Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。</p>
<h3 id="在-Redux-中，何为-store"><a href="#在-Redux-中，何为-store" class="headerlink" title="在 Redux 中，何为 store"></a>在 Redux 中，何为 store</h3><p>Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：</p>
<ul>
<li>允许通过 <code>getState()</code> 访问 state</li>
<li>运行通过 <code>dispatch(action)</code> 改变 state</li>
<li>通过 <code>subscribe(listener)</code> 注册 listeners</li>
<li>通过 <code>subscribe(listener)</code> 返回的函数处理 listeners 的注销</li>
</ul>
<h3 id="何为-action"><a href="#何为-action" class="headerlink" title="何为 action"></a>何为 action</h3><p>Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。</p>
<h3 id="何为-reducer"><a href="#何为-reducer" class="headerlink" title="何为 reducer"></a>何为 reducer</h3><p>一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。</p>
<h3 id="Redux-Thunk-的作用是什么"><a href="#Redux-Thunk-的作用是什么" class="headerlink" title="Redux Thunk 的作用是什么"></a>Redux Thunk 的作用是什么</h3><p>Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。</p>
<h3 id="何为纯函数-pure-function"><a href="#何为纯函数-pure-function" class="headerlink" title="何为纯函数(pure function)"></a>何为纯函数(pure function)</h3><p>一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。</p>
<ul>
<li>同输入同输出</li>
<li>无副作用(函数内部的操作不会对外部产生影响(如修改全局变量的值、修改 dom 节点等))</li>
</ul>
<h3 id="redux-有哪些中间件，作用？"><a href="#redux-有哪些中间件，作用？" class="headerlink" title="redux 有哪些中间件，作用？"></a>redux 有哪些中间件，作用？</h3><p>中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。</p>
<p>redux-logger：提供日志输出</p>
<p>redux-thunk：处理异步操作</p>
<p>redux-promise：处理异步操作，actionCreator 的返回值是 promise</p>
<h3 id="示例项目"><a href="#示例项目" class="headerlink" title="示例项目"></a>示例项目</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/Pau1fitz/react-spotify">React Spotify</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/andrewngu/sound-redux">React Soundcloud</a></li>
</ul>
<h3 id="虚拟-dom-虚拟节点-是用-JS-对象来模拟真实-DOM-中的节点"><a href="#虚拟-dom-虚拟节点-是用-JS-对象来模拟真实-DOM-中的节点" class="headerlink" title="虚拟 dom(虚拟节点)是用 JS 对象来模拟真实 DOM 中的节点"></a>虚拟 dom(虚拟节点)是用 JS 对象来模拟真实 DOM 中的节点</h3><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。插入新组件有了 key 可以帮助 react 找到映射。</p>
<ul>
<li>真实的元素节点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;wrap&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>Hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>vnode</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">attrs</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;wrap&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">children</span>: [&#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;p&#x27;</span>,<br>    <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;Hello world!&#x27;</span>,<br>    <span class="hljs-attr">attrs</span>: &#123;<br>      <span class="hljs-attr">class</span>: <span class="hljs-string">&#x27;title&#x27;</span>,<br>    &#125;<br>  &#125;]<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么使用虚拟-dom"><a href="#为什么使用虚拟-dom" class="headerlink" title="为什么使用虚拟 dom"></a>为什么使用虚拟 dom</h3><p>起初我们在使用 JS/JQuery 时，不可避免的会大量操作 DOM，而 DOM 的变化又会引发回流或重绘，从而降低页面渲染性能。那么怎样来减少对 DOM 的操作呢？此时虚拟 DOM<br>应用而生，所以虚拟 DOM 出现的主要目的就是 <code>为了减少频繁操作DOM而引起回流重绘所引发的性能问题的</code></p>
<h3 id="虚拟-dom-的作用"><a href="#虚拟-dom-的作用" class="headerlink" title="虚拟 dom 的作用"></a>虚拟 dom 的作用</h3><p>兼容性好。因为 Vnode 本质是 JS 对象，所以不管 Node 还是浏览器环境，都可以操作；<br>减少了对 Dom 的操作。页面中的数据和状态变化，都通过 Vnode 对比，只需要在比对完之后更新 DOM，不需要频繁操作，提高了页面性能。</p>
<p>每个 setState 重新渲染整个子树标记为 dirty。 如果要压缩性能，请尽可能调用 setState，并使用 shouldComponentUpdate 来防止重新渲染大型子树。把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的 key 属性，方便比较。pureComponent(浅比较)+immutable 替换成 preact</p>
<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><blockquote>
<p>一开始会根据真实 DOM 生成虚拟 DOM，当虚拟 DOM 某个节点的数据改变后会生成一个新的 Vnode，然后 VNode 和 oldVnode 对比，把不同的地方修改在真实 DOM 上，最后再使得 oldVnode 的值为 Vnode。</p>
</blockquote>
<p><code>diff过程就是调用patch函数，比较新老节点，一边比较一边给真实DOM打补丁(patch)；</code></p>
<p><img src="http://cdn.mydearest.cn/blog/images/patch.png" alt="patch"></p>
<p>把树形结构按照层级分解，只比较同级元素。</p>
<p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
<p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
<p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
<p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
<p>diff 的只是 html tag，并没有 diff 数据。</p>
<h3 id="setState-的理解"><a href="#setState-的理解" class="headerlink" title="setState 的理解"></a>setState 的理解</h3><ul>
<li><p>setState 只在<code>合成事件</code>和<code>钩子函数(除了componentDidUpdate)</code>中是“异步”的，在原生事件和 setTimeout 中都是同步的。</p>
</li>
<li><p>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。</p>
</li>
<li><p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。</p>
</li>
<li><p>异步与同步: setState 并不是单纯的异步或同步，这其实与调用时的环境相关:</p>
<ul>
<li><p>在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState 是”异步”的；</p>
<ul>
<li>原因: 因为在 setState 的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入 dirtyComponents 队列中等待执行；否则，开始执行 batchedUpdates 队列更新；</li>
</ul>
</li>
<li><p>在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而 componentDidUpdate 是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；<br>在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中；</p>
<ul>
<li>问题: 无法在 setState 后马上从 this.state 上获取更新后的值。</li>
<li>解决: 如果需要马上同步去获取新值，setState 其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值；</li>
</ul>
</li>
<li><p>在 原生事件 和 setTimeout 中，setState 是同步的，可以马上获取更新后的值；</p>
<ul>
<li>原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步；</li>
</ul>
</li>
</ul>
</li>
<li><p>批量更新</p>
<ul>
<li>在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是<code>合并状态(Object.assign)</code>。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新；</li>
</ul>
</li>
<li><p>函数式</p>
<ul>
<li>由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)；</li>
<li>使用函数式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被顺序调用；</li>
</ul>
</li>
<li><p>注意点</p>
<ul>
<li>当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法:<ul>
<li>将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中；</li>
<li>在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="替换的属性"><a href="#替换的属性" class="headerlink" title="替换的属性"></a>替换的属性</h3><ul>
<li>class/className for/htmlFor</li>
</ul>
<h3 id="插入-html-文本"><a href="#插入-html-文本" class="headerlink" title="插入 html 文本"></a>插入 html 文本</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">dangerouslySetInnerHTML = &#123;<br>  &#123;<br>    <span class="hljs-attr">__html</span>: content<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-版本的生命周期如下："><a href="#15-版本的生命周期如下：" class="headerlink" title="15 版本的生命周期如下："></a>15 版本的生命周期如下：</h3><ol>
<li>初始化阶段</li>
</ol>
<ul>
<li>constructor</li>
<li>getDefaultProps</li>
<li>getInitialState</li>
</ul>
<ol start="2">
<li>挂载阶段</li>
</ol>
<ul>
<li>componentWillMount</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<ol start="3">
<li>更新阶段<br>props：</li>
</ol>
<ul>
<li>componentWillReceiveProps</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate<br>state：</li>
<li>shouldComponentUpdate</li>
<li>componentWillUpdate</li>
<li>render</li>
<li>componentDidUpdate</li>
</ul>
<ol start="4">
<li>卸载阶段</li>
</ol>
<ul>
<li>componentWillUnmount</li>
</ul>
<h3 id="16-版本生命周期如下："><a href="#16-版本生命周期如下：" class="headerlink" title="16 版本生命周期如下："></a>16 版本生命周期如下：</h3><ol>
<li>初始化阶段</li>
</ol>
<ul>
<li>constructor</li>
<li>getDefaultProps</li>
<li>getInitialState</li>
</ul>
<ol start="2">
<li>挂载阶段</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">组件实例化。<br>组件的props发生变化。<br>父组件重新渲染。<br><span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>() 不会触发<span class="hljs-title function_">getDerivedStateFromProps</span>()， 但是<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">forceUpdate</span>() 会。<br></code></pre></td></tr></table></figure>

<ul>
<li>getDerivedStateFromProps: 传入 nextProps 和 prevState，根据需要将 props 映射到 state，否则返回 null</li>
<li>render</li>
<li>componentDidMount</li>
</ul>
<ol start="3">
<li>更新阶段</li>
</ol>
<ul>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>render</li>
<li>getSnapshotBeforeUpdate：render 之后 dom 渲染之前会发生，返回一个值作为 componentDidUpdate 的第三个参数使用</li>
<li>componentDidUpdate</li>
</ul>
<ol start="4">
<li>卸载阶段</li>
</ol>
<ul>
<li>componentWillUnmount</li>
</ul>
<ol start="5">
<li>错误处理</li>
</ol>
<ul>
<li>componentDidCatch</li>
</ul>
<h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><p>react 事件并没有绑定到真实的 dom 节点上，而是通过事件代理，在最外层的 document 上对事件进行统一分发。</p>
<h3 id="为什么-react-事件要自己绑定-this"><a href="#为什么-react-事件要自己绑定-this" class="headerlink" title="为什么 react 事件要自己绑定 this"></a>为什么 react 事件要自己绑定 this</h3><p>在 react 中事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this 是不准确的，所以我们需要手动将当前组件绑定到 this 上。</p>
<h3 id="react-和原生事件的执行顺序是什么，可以混用吗"><a href="#react-和原生事件的执行顺序是什么，可以混用吗" class="headerlink" title="react 和原生事件的执行顺序是什么，可以混用吗"></a>react 和原生事件的执行顺序是什么，可以混用吗</h3><p>react 的所有事件都通过 document 进行统一分发，当真实 dom 触发事件后冒泡到 document 后才会对 react 事件进行处理</p>
<p>所以原生事件会先执行，然后执行 react 合成事件，最后执行真正在 document 上挂载的事件两者最好不要混用，原生事件中如果执行了 stopPropagation 方法，则会导致其他 react 事件失效。</p>
<h3 id="虚拟-dom-比普通-dom-更快吗"><a href="#虚拟-dom-比普通-dom-更快吗" class="headerlink" title="虚拟 dom 比普通 dom 更快吗"></a>虚拟 dom 比普通 dom 更快吗</h3><p>首次渲染时 vdom 不具有任何优势甚至要进行更多的计算，消耗更多的内存。</p>
<p>vdom 的优势在于 react 的 diff 算法和批处理策略，react 在页面更新之前，提前计算好了如何进行更新和渲染 dom。vdom 主要是能在重复渲染时帮助我们计算如何实现更高效的更新，而不是说它比 dom 操作快。</p>
<h3 id="虚拟-dom-中的-typeof-属性的作用是什么"><a href="#虚拟-dom-中的-typeof-属性的作用是什么" class="headerlink" title="虚拟 dom 中的$$typeof 属性的作用是什么"></a>虚拟 dom 中的$$typeof 属性的作用是什么</h3><p>它被赋值为 REACT_ELEMENT_TYPE，是一个 symbol 类型的变量，这个变量可以防止 XSS。react 渲染时会把没有$$typeof标识以及规则校验不通过的组件全都过滤掉。当你的环境不支持Symbol时，$$typeof 被赋值为 0xeac7，为什么采用 0xeac7？</p>
<blockquote>
<p>0xeac7 看起来有点像 React。</p>
</blockquote>
<h3 id="HOC-在业务场景中有哪些实际的应用"><a href="#HOC-在业务场景中有哪些实际的应用" class="headerlink" title="HOC 在业务场景中有哪些实际的应用"></a>HOC 在业务场景中有哪些实际的应用</h3><ul>
<li>组合渲染(属性代理)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 更改 props</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxyHoc</span>(<span class="hljs-params">Comp</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> newProps = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tayde&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>,<br>      &#125;;<br>      <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comp</span> &#123;<span class="hljs-attr">...this.props</span>&#125; &#123;<span class="hljs-attr">...newProps</span>&#125; /&gt;</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>很方便将 <code>Input</code> 组件转化为受控组件</p>
<ul>
<li>条件渲染</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 反向继承传递过来的组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withLoading</span>(<span class="hljs-params">Comp</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Comp</span> &#123;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">isLoading</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Loading</span> /&gt;</span></span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>();<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>操作 props</li>
<li>获取 refs</li>
<li>操作 state<br>可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。</li>
<li>渲染劫持</li>
</ul>
<p>实际应用场景：</p>
<ul>
<li>日志打点</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 性能监控埋点</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">withTiming</span>(<span class="hljs-params">Comp</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Comp</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">start</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">super</span>.<span class="hljs-property">componentDidMount</span> &amp;&amp; <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">componentDidMount</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">end</span> = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;WrappedComponent.name&#125;</span> 组件渲染时间为 <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.end - <span class="hljs-variable language_">this</span>.start&#125;</span> ms`</span>);<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">render</span>();<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>权限控制</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">withAdminAuth</span>(<span class="hljs-params">WrappedComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">React</span>.<span class="hljs-property">Component</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>      <span class="hljs-variable language_">super</span>(props);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123;<br>        <span class="hljs-attr">isAdmin</span>: <span class="hljs-literal">false</span>,<br>      &#125;;<br>    &#125;<br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">componentWillMount</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> currentRole = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getCurrentUserRole</span>();<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>        <span class="hljs-attr">isAdmin</span>: currentRole === <span class="hljs-string">&#x27;Admin&#x27;</span>,<br>      &#125;);<br>    &#125;<br>    <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">isAdmin</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Comp</span> &#123;<span class="hljs-attr">...this.props</span>&#125; /&gt;</span></span>;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 您没有权限查看该页面， 请联系管理员！ <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>双向绑定</li>
<li>表单校验</li>
<li>代码复用</li>
</ul>
<h3 id="HOC-和-mixin-的异同点是什么"><a href="#HOC-和-mixin-的异同点是什么" class="headerlink" title="HOC 和 mixin 的异同点是什么"></a>HOC 和 mixin 的异同点是什么</h3><ul>
<li><p>mixin 可能会互相依赖，互相耦合，不利于代码维护</p>
</li>
<li><p>不同的 mixin 中的方法可能会相互冲突</p>
</li>
<li><p>mixin 非常多的时候组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性</p>
</li>
<li><p>而 HOC 的出现则可以解决这些问题</p>
</li>
</ul>
<ul>
<li>hoc 是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合</li>
<li>高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些情况</li>
<li>高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担</li>
</ul>
<h4 id="hooks-有哪些优势-react-提供的-api-hoc-和-render-props-开发模式"><a href="#hooks-有哪些优势-react-提供的-api-hoc-和-render-props-开发模式" class="headerlink" title="hooks 有哪些优势(react 提供的 api, hoc 和 render props 开发模式)"></a>hooks 有哪些优势(react 提供的 api, hoc 和 render props 开发模式)</h4><ul>
<li><p>组件逻辑越来越复杂(componentDidMount, componentDidUpdate)<br>尤其是生命周期函数中常常包含一些不相关的逻辑，完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。</p>
</li>
<li><p>组件之间复用状态逻辑很难，避免地狱嵌套<br>hook 和 mixin 在用法上有一定的相似之处，但是 mixin 引入的逻辑状态是可以互相覆盖的，而多个 hooks 之间互不影响，hoc 也可能带来一定冲突，比如 props 覆盖等等，使用 hooks 则可以避免这些问题。大量使用 hoc 让我们的代码变得嵌套层级非常深，使用 hooks 我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。</p>
</li>
<li><p>让组件变得更加容易理解 class 组件 this 钩子函数<br>相比函数，编写一个 class 可能需要更多的知识，hooks 让你可以在 class 之外使用更多的 react 的新特性</p>
</li>
</ul>
<p>后续中展示组件需要改造成类组件需要有自己的状态管理和生命周期方法将复用逻辑提升到代码顶部。</p>
<h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><blockquote>
<p>Fiber 核心是实现了一个基于优先级和 requestIdleCallback 的循环任务调度算法</p>
</blockquote>
<ul>
<li>reconciliation 阶段可以把任务拆分成多个小任务</li>
<li>reconciliation 阶段可随时中止或恢复任务</li>
<li>可以根据优先级不同来选择优先执行任务</li>
</ul>
<blockquote>
<p>在任务队列中选出高优先级的 fiber node 执行，调用 requestIdleCallback 获取所剩时间，若执行时间超过了 deathLine，或者突然插入更高优先级的任务，则执行中断，保存当前结果，修改 tag 标记一下，设置为 pending 状态，迅速收尾并再调用一个 requestIdleCallback，等主线程释放出来再继续</p>
</blockquote>
<p>恢复任务执行时，检查 tag 是被中断的任务，会接着继续做任务或者重做</p>
<p>在 v16 之前，reconciliation 简单说就是一个自顶向下递归算法，产出需要对当前 DOM 进行更新或替换的操作列表，一旦开始，会持续占用主线程，中断操作却不容易实现。当 JS 长时间执行（如大量计算等），会阻塞<br>样式计算、绘制等工作，出现页面脱帧现象。所以，v16 进行了一次重写，迎来了代号为 Fiber 的异步渲染架构。</p>
<p>React 的核心流程可以分为两个部分:</p>
<ul>
<li><p>reconciliation (调度算法，也可称为 render diff 阶段):</p>
<ul>
<li>更新 state 与 props；</li>
<li>调用生命周期钩子；</li>
<li>生成 virtual dom；<ul>
<li>这里应该称为 Fiber Tree 更为符合；</li>
</ul>
</li>
<li>通过新旧 vdom 进行 diff 算法，获取 vdom change；</li>
<li>确定是否需要重新渲染</li>
</ul>
</li>
<li><p>commit(操作 dom 阶段):</p>
<ul>
<li>如需要，则操作 dom 节点更新；</li>
</ul>
</li>
<li><p>问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。</p>
</li>
<li><p>解决方案: 解决同步阻塞的方法，通常有两种: 异步与任务分割。而 React Fiber 便是为了实现任务分割而诞生的。</p>
<ul>
<li>在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的<code>单链表树遍历算法</code>。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。</li>
<li>这里我理解为是一种<code>任务分割调度算法</code>，主要是将原先同步更新渲染的任务分割成一个个独立的<code>小任务单位</code>，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Fiber</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">instance</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = instance;<br>    <span class="hljs-comment">// 指向第一个 child 节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">child</span> = child;<br>    <span class="hljs-comment">// 指向父节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">return</span> = parent;<br>    <span class="hljs-comment">// 指向第一个兄弟节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sibling</span> = previous;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。<br>当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。</p>
</blockquote>
<ul>
<li>任务优先级(7 种)</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-title class_">NoWork</span>: <span class="hljs-number">0</span>, <span class="hljs-comment">// No work is pending.</span><br>  <span class="hljs-title class_">SynchronousPriority</span>: <span class="hljs-number">1</span>, <span class="hljs-comment">// 文本输入框</span><br>  <span class="hljs-title class_">TaskPriority</span>: <span class="hljs-number">2</span>, <span class="hljs-comment">// 当前调度正执行的任务</span><br>  <span class="hljs-title class_">AnimationPriority</span>: <span class="hljs-number">3</span>, <span class="hljs-comment">// 动画过渡</span><br>  <span class="hljs-title class_">HighPriority</span>: <span class="hljs-number">4</span>, <span class="hljs-comment">// 用户交互反馈</span><br>  <span class="hljs-title class_">LowPriority</span>: <span class="hljs-number">5</span>, <span class="hljs-comment">// 数据的更新</span><br>  <span class="hljs-title class_">OffscreenPriority</span>: <span class="hljs-number">6</span>, <span class="hljs-comment">// 预估未来需要显示的任务</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="为什么生命周期有了变动"><a href="#为什么生命周期有了变动" class="headerlink" title="为什么生命周期有了变动"></a>为什么生命周期有了变动</h3><p>在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 <code>多次调用</code> 的情况，产生一些意外错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-comment">// 替换 `componentWillReceiveProps` ，</span><br>  <span class="hljs-comment">// 初始化和 update 时被调用</span><br>  <span class="hljs-comment">// 静态函数，无法使用 this</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 判断是否需要更新组件</span><br>  <span class="hljs-comment">// 可以用于组件性能优化</span><br>  <span class="hljs-title function_">shouldComponentUpdate</span>(<span class="hljs-params">nextProps, nextState</span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 组件被挂载后触发</span><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 替换 componentWillUpdate</span><br>  <span class="hljs-comment">// 可以在更新之前获取最新 dom 数据</span><br>  <span class="hljs-title function_">getSnapshotBeforeUpdate</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 组件更新后调用</span><br>  <span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 组件即将销毁</span><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 组件已销毁</span><br>  <span class="hljs-title function_">componentDidUnMount</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>  <span class="hljs-comment">// 错误边界捕获全局异常</span><br>  <span class="hljs-title function_">componentDidCatch</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在 constructor 初始化 state；</li>
<li>在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件；</li>
<li>在 componentDidMount 中进行数据的请求，而不是在 componentWillMount；</li>
<li>需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)；<ul>
<li>旧 props 需要自己存储，以便比较；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">public <span class="hljs-keyword">static</span> <span class="hljs-title function_">getDerivedStateFromProps</span>(<span class="hljs-params">nextProps, prevState</span>) &#123;<br>  <span class="hljs-comment">// 当新 props 中的 data 发生变化时，同步更新到 state 上</span><br>  <span class="hljs-keyword">if</span> (nextProps.<span class="hljs-property">data</span> !== prevState.<span class="hljs-property">data</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">data</span>: nextProps.<span class="hljs-property">data</span><br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>可以在 componentDidUpdate 监听 props 或者 state 的变化，例如:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">componentDidUpdate</span>(<span class="hljs-params">prevProps</span>) &#123;<br>  <span class="hljs-comment">// 当 id 发生变化时，重新获取数据</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">id</span> !== prevProps.<span class="hljs-property">id</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">fetchData</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">id</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>在 componentDidUpdate 使用 setState 时，必须加条件，否则将进入死循环；</li>
<li>getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前；</li>
<li>shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。</li>
</ul>
<p>废弃的原因主要是因为 react 在 16 版本重构了调度算法，新的调度可能会导致一些生命周期被反复调用，所以在 16 中就不建议使用了，而改在其他时机中暴露出其<br>他生命周期钩子用来替代。</p>
<h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><p>SSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。<br>前后端分离: 前端与服务端隔离，前端动态获取数据，渲染页面。</p>
<ul>
<li>痛点:<ul>
<li>首屏渲染性能瓶颈:</li>
<li>空白延迟: HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。</li>
<li>SEO 问题: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。<ul>
<li>虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><ul>
<li>Node 服务: 让前后端运行同一套代码成为可能。</li>
<li>Virtual Dom: 让前端代码脱离浏览器运行。</li>
</ul>
<p><img src="http://cdn.mydearest.cn/blog/images/ssr.png" alt="ssr"></p>
<h3 id="为什么-react-没有双向绑定"><a href="#为什么-react-没有双向绑定" class="headerlink" title="为什么 react 没有双向绑定"></a>为什么 react 没有双向绑定</h3><p>React 的设计思想是单向数据流，我觉得可以这样理解为什么没有双向数据绑定：</p>
<p>首先，React 是纯粹的 View 层；然后，对于 React 来说双向数据绑定是什么需求? – 明显是业务需求。因为单向数据流已经满足了 View 层渲染的要求并且更易测试与控制（来自 Props 或 State），更加的清晰可控，所以在纯粹的 React 中怎么会需要双向数据绑定这种功能呢。</p>
<p>如果需要解决双向数据绑定问题，可以借助第三方库如 Ant Design 的 rc-form 之类，你也可以存在 State 里甚至是 Redux 里，根据需求来吧。所以 React 没有双向数据绑定不是功能的缺失或冲突问题，而是 React 只关注解决纯粹的问题： View 层。</p>
<h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><p>单向数据流是指数据的流向只能由父组件通过 props 将数据传递给子组件，不能由子组件向父组件传递数据，要想实现数据的双向绑定，只能由子组件接收父组件 props 传过来的方法去改变父组件的数据，而不是直接将<br>子组件的数据传递给父组件。</p>
<h3 id="react-和-vue-的对比"><a href="#react-和-vue-的对比" class="headerlink" title="react 和 vue 的对比"></a>react 和 vue 的对比</h3><p>react 函数式思想 纯组件传入状态和逻辑，所以单项数据流结合 immutable setState 触发重新 render 单项数据流设计成不可变数据 purecomponent 对 shouldconponentupdate 是否触发重新渲染。不可变数据返回新的 state，计算虚拟 dom 的差异。数据流 props/callback，context</p>
<p>vue 响应式的思想 监听数据的变化 初始化时对数据的每一个属性添加 watcher 基于数据可变 数据变化时触发 watcher 回调 更新虚拟 dom。可变数据直接修改，setter 能精确监听数据变化。数据流 props/event，inject/provide</p>
<p>react 的性能优化需要手动去判断 vue 是自动的应为要给每个属性添加 watcher 所以大型项目 state 不比较多的时候 watcher 也会比较多容易造成卡顿的情况。redux 不能直接调用 reducer 进行修改。而 vuex 有 dispatch 和 commit</p>
<h3 id="React-中，cloneElement-与-createElement-各是什么，有什么区别"><a href="#React-中，cloneElement-与-createElement-各是什么，有什么区别" class="headerlink" title="React 中，cloneElement 与 createElement 各是什么，有什么区别"></a>React 中，cloneElement 与 createElement 各是什么，有什么区别</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">React</span>.<span class="hljs-title function_">cloneElement</span>(element, [props], [...children]);<br><br><span class="hljs-title class_">React</span>.<span class="hljs-title function_">createElement</span>(type, [props], [...children]);<br></code></pre></td></tr></table></figure>

<h3 id="React-Portal-有哪些使用场景"><a href="#React-Portal-有哪些使用场景" class="headerlink" title="React Portal 有哪些使用场景"></a>React Portal 有哪些使用场景</h3><p>在以前， react 中所有的组件都会位于 #app 下，而使用 Portals 提供了一种脱离 #app 的组件。<br>因此 Portals 适合脱离文档流(out of flow) 的组件，特别是 position: absolute 与 position: fixed 的组件。比如模态框，通知，警告，goTop 等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> modalRoot = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;modal&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Modal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    modalRoot.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    modalRoot.<span class="hljs-title function_">removeChild</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createPortal</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">props</span>.<span class="hljs-property">children</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">el</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><ol>
<li>params 传参(刷新页面后参数不消失，参数会在地址栏显示)</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">路由页面：&lt;Route path=<span class="hljs-string">&#x27;/demo/:id&#x27;</span> component=&#123;Demo&#125;&gt;&lt;/Route&gt;  <span class="hljs-comment">//注意要配置 /:id</span><br>路由跳转并传递参数：<br>    链接方式：&lt;Link to=&#123;<span class="hljs-string">&#x27;/demo/&#x27;</span>+<span class="hljs-string">&#x27;6&#x27;</span>&#125;&gt;XX&lt;/Link&gt;<br>        或：&lt;Link to=&#123;&#123;pathname:<span class="hljs-string">&#x27;/demo/&#x27;</span>+<span class="hljs-string">&#x27;6&#x27;</span>&#125;&#125;&gt;XX&lt;/Link&gt;<br><br>    js方式：this<span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.history</span><span class="hljs-selector-class">.push</span>(<span class="hljs-string">&#x27;/demo/&#x27;</span>+<span class="hljs-string">&#x27;6&#x27;</span>)<br>        或：this<span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.history</span><span class="hljs-selector-class">.push</span>(&#123;pathname:<span class="hljs-string">&#x27;/demo/&#x27;</span>+<span class="hljs-string">&#x27;6&#x27;</span>&#125;)<br>获取参数：this<span class="hljs-selector-class">.props</span><span class="hljs-selector-class">.match</span><span class="hljs-selector-class">.params</span><span class="hljs-selector-class">.id</span>    <span class="hljs-comment">//注意这里是match而非history</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>query 传参(刷新页面后参数消失)</li>
</ol>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">路由页面：<span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/demo&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Demo&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>  //无需配置</span><br><span class="language-xml">路由跳转并传递参数：</span><br><span class="language-xml">    链接方式：<span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">pathname:</span><span class="hljs-string">&#x27;/demo&#x27;</span>,query:&#123;id:22,name:<span class="hljs-string">&#x27;dahuang&#x27;</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&#125;&gt;</span>XX<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">    js方式：this.props.history.push(&#123;pathname:&#x27;/demo&#x27;,query:&#123;id:22,name:&#x27;dahuang&#x27;&#125;&#125;)</span><br><span class="language-xml">获取参数： this.props.location.query.name</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>state 传参(刷新页面后参数不消失，state 传的参数是加密的，比 query 传参好用)</li>
</ol>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">路由页面：<span class="hljs-tag">&lt;<span class="hljs-name">Route</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&#x27;/demo&#x27;</span> <span class="hljs-attr">component</span>=<span class="hljs-string">&#123;Demo&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Route</span>&gt;</span>  //无需配置</span><br><span class="language-xml">路由跳转并传递参数：</span><br><span class="language-xml">    链接方式： <span class="hljs-tag">&lt;<span class="hljs-name">Link</span> <span class="hljs-attr">to</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">pathname:</span><span class="hljs-string">&#x27;/demo&#x27;</span>,state:&#123;id:12,name:<span class="hljs-string">&#x27;dahuang&#x27;</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&#125;&gt;</span>XX<span class="hljs-tag">&lt;/<span class="hljs-name">Link</span>&gt;</span></span><br><span class="language-xml">    js方式：this.props.history.push(&#123;pathname:&#x27;/demo&#x27;,state:&#123;id:12,name:&#x27;dahuang&#x27;&#125;&#125;)</span><br><span class="language-xml">获取参数： this.props.location.state.name</span><br></code></pre></td></tr></table></figure>

<h3 id="create-react-app-配置文件修改"><a href="#create-react-app-配置文件修改" class="headerlink" title="create-react-app 配置文件修改"></a>create-react-app 配置文件修改</h3><ul>
<li>通过 package.json 或引用第三方的库增加配置</li>
<li>react 构建时通过 webpack，关于 webpack 配置查看 node_modules/react-scripts/config/webpack*</li>
<li>npm run eject 暴露所有配置文件、(安装 react-app-rewired 包)建立新的配置文件覆盖部分默认的配置</li>
<li>HashRouter 支持配置 package-json homepage: ‘.’修改根目录路径，BrowerRouter 修改无效还得修改服务端配置</li>
</ul>
<h3 id="react-diff-和-vue-diff-的区别"><a href="#react-diff-和-vue-diff-的区别" class="headerlink" title="react diff 和 vue diff 的区别"></a>react diff 和 vue diff 的区别</h3><ul>
<li>vnode 作为数据和视图的一种映射关系</li>
<li>相同点：都是同层比较、不同点：vue 使用双指针比较，react 是 key 集合级比较</li>
</ul>
<h3 id="react-StrictMode-严格模式"><a href="#react-StrictMode-严格模式" class="headerlink" title="react StrictMode 严格模式"></a>react StrictMode 严格模式</h3><p>StrictMode 是一种辅助组件，可以帮助编写更好的组件。</p>
<ol>
<li>验证是否遵循推荐写法</li>
<li>验证是否使用了已经废弃的写法</li>
<li>通过识别一些潜在的风险预防副作用</li>
</ol>
<h3 id="react-事件的合成机制"><a href="#react-事件的合成机制" class="headerlink" title="react 事件的合成机制"></a>react 事件的合成机制</h3><ol>
<li>div 或其他元素触发事件，该事件会冒泡到 document，然后被 React 的事件处理程序捕获</li>
<li>事件处理程序随后将事件传递给 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。</li>
<li>SyntheticEvent 触发 dispatchEvent，将 event 对象交由对应的处理器执行。</li>
</ol>
<ul>
<li><p>为什么要合成事件机制</p>
<ul>
<li>更好的兼容性和跨平台</li>
<li>react 事件机制采用了事件池，大大节省内存</li>
<li>方便事件的统一管理</li>
</ul>
</li>
<li><p>react 处理阻止冒泡</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 阻止事件冒泡，（阻止这个合成事件，往document上冒泡，因此不会触发click方法）</span><br>e.<span class="hljs-title function_">stopPropagation</span>();<br><span class="hljs-comment">// 阻止合成事件间的冒泡，不会往最外层冒了</span><br>e.<span class="hljs-property">nativeEvent</span>.<span class="hljs-title function_">stopImmediatePropagation</span>();<br></code></pre></td></tr></table></figure>

<h3 id="redux-存在的问题-gt-重"><a href="#redux-存在的问题-gt-重" class="headerlink" title="redux 存在的问题 =&gt; 重"></a>redux 存在的问题 =&gt; 重</h3><ul>
<li>一份 store 树，离开页面再次进入，数据不会初始化</li>
<li>reducer 拆分造成汇总困难</li>
<li>action 的 type 管理混乱，重复问题</li>
<li>繁杂的使用规则，index 页面 action 和 store 引入，纯函数 reducer 大量 case 仅仅为了改变一个值</li>
</ul>
<h3 id="常用-UI-库"><a href="#常用-UI-库" class="headerlink" title="常用 UI 库"></a>常用 UI 库</h3><ul>
<li><p>移动端<br><a target="_blank" rel="noopener" href="https://mobile.ant.design/index-cn">ant design mobile</a></p>
</li>
<li><p>pc 端<br><a target="_blank" rel="noopener" href="https://ant.design/">ant design</a></p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://reactstrap.github.io/">reactstrap</a></p>
<p><a target="_blank" rel="noopener" href="https://patternfly-react.surge.sh/">patternfly-react</a></p>
<p><a target="_blank" rel="noopener" href="https://react.semantic-ui.com/">semantic-ui</a></p>
<p><a target="_blank" rel="noopener" href="https://material-ui.com/">material-ui</a></p>
<p><a target="_blank" rel="noopener" href="http://elemental-ui.com/home">elemental-ui</a></p>
<h3 id="常用组件"><a href="#常用组件" class="headerlink" title="常用组件"></a>常用组件</h3><ul>
<li>无限滚动加载<br><a target="_blank" rel="noopener" href="https://github.com/danbovey/react-infinite-scroller">react-infinite-scroller</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/caseywebdev/react-list">react-list</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ankeetmaini/react-infinite-scroll-component">react-infinite-scroll-component</a></p>
<ul>
<li>国际化<br><a target="_blank" rel="noopener" href="https://github.com/i18next/react-i18next">react-i18next</a></li>
</ul>
<p><a target="_blank" rel="noopener" href="https://github.com/formatjs/formatjs">react-intl</a></p>
<ul>
<li>date 库<br><a target="_blank" rel="noopener" href="https://github.com/moment/moment">moment</a><br><a target="_blank" rel="noopener" href="https://github.com/noahlam/Miment">miment</a><br><a target="_blank" rel="noopener" href="https://github.com/iamkun/dayjs">dayjs</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://mydearest.cn/">react</a></p>

    

    

    
    <div class="declare"> 
      <ul class="post-copyright">
        <li>
          <strong>本文作者：</strong>
          luckyship
        </li>
        <li>
          <strong>本文链接：</strong>
          <a href="https://luckyship.github.io/2021/07/18/2021-07-18-react-base/" title="react基础知识" target="_blank">https://luckyship.github.io/2021/07/18/2021-07-18-react-base/</a>
        </li>
        
        <li>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus/blob/master/LICENSE" rel="external nofollow" target="_blank">MIT</a> 许可协议。转载请注明出处！
        </li>
        
      </ul>
    </div>
    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">javascript</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">react</a>
        		</li>
      		
		</ul>
	</div>

    
	<div class="article-category tagcloud">
		<i class="icon-book icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="/categories/review//" class="article-tag-list-link color2">review</a>
        		</li>
      		
		</ul>
	</div>


    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=https://luckyship.github.io/2021/07/18/2021-07-18-react-base/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
    <a href="/2021/07/24/2021-07-24-start-web-server-quick/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          使用node快速启动一个服务器
        
      </div>
    </a>
  
  
    <a href="/2021/07/17/2021-07-17-promise/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">手写promise</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>







  <section id="comments" style="margin:10px;padding:10px;background:#fff;">
    <div id="vcomment" class="comment"></div>
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<script src="/js/valine.js" async></script>
<script async>
  var notify = 'true' == true ? true : false;
  var verify = 'false' == true ? true : false;
  window.onload = function () {
    new Valine({
      el: '.comment',
      notify: notify,
      verify: verify,
      app_id: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      app_key: 'fstd3ABXC89jc5VDSe6ANGV6',
      placeholder: 'Just go go',
      avatar: 'mm',
    });
  };
</script>

  </section>










          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020-2025 <a href="https://luckyship.github.io/" target="_blank">luckyship</a>
    	</div>
      	<div class="footer-right">
			
			
      		GitHub:<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank">hexo-theme-yilia-plus</a> by Litten
      	</div>
    </div>
  </div>

  
	<script async src="/lib/busuanzi.pure.js"></script>
	
  
  
	
	<span id="busuanzi_container_site_pv" style="display:none">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	        <span class="post-meta-divider" >|</span>
	</span>
  	<span id="busuanzi_container_site_uv" style='display:none'>
  		本站访客数<span id="busuanzi_value_site_uv"></span>人
  	</span>
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>




<!--  -->

<script>
  /* 标签页标题切换 */
  var originTitle = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function () {
    if (document.hidden) {
      document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
      titleTime = setTimeout(function () {
        document.title = originTitle;
      }, 2000);
    }
  });
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">搜索</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mongo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">ruby</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">dataTable</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">network</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">base</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">rails</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">kubernetes</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">centos</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">debian</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ubuntu</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">nodejs</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jquery</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">es6</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">npm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">video</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nginx</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">+ vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angular</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">sass</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">less</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angualr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">typescript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">react</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">regexp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">vscode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">regex</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">review</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">tool</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">flutter</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">unicode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">sql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">postgresql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">vite</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">go</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
            <a q-attr="href:path|urlformat">
              <p class="search-content" q-show="matchContent.val">
                <span q-text="matchContent.pre"></span><span class="red" q-text="matchContent.val"></span><span q-text="matchContent.next"></span>
              </p>
            </a>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
        
          
  	  		<div class="aboutme-wrap" id="aboutme">前端攻城狮<br>记录分享自己工作、学习中学到的知识</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script
  type="text/javascript"
  src="/plugins/activate-power-mode/activate-power-mode.js"
></script>
<script>
  document.addEventListener('DOMContentLoaded',function(){
    POWERMODE.colorful = true; // make power mode colorful
    POWERMODE.shake = false; // turn off shake
    document.body.addEventListener('input', POWERMODE);
  });
</script>


  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
  
</body>

</html>

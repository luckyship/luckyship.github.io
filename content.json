[{"title":"go 环境管理","date":"2025-07-30T03:28:28.000Z","path":"2025/07/30/2025-07-30-go-env/","text":"Go 有多种版本管理工具可以帮助您在不同版本之间切换。以下是一些常用的 Go 版本管理工具： 1. goenvgoenv 是一个类似于 rbenv 的 Go 版本管理工具，可以方便地在不同 Go 版本之间切换。 安装方式（在 Linux/macOS 上）： # 克隆 goenvgit clone https://github.com/syndbg/goenv.git ~/.goenv# 添加到 ~/.bashrc 或 ~/.zshrcecho &#x27;export GOENV_ROOT=&quot;$HOME/.goenv&quot;&#x27; &gt;&gt; ~/.bashrcecho &#x27;export PATH=&quot;$GOENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.bashrcecho &#x27;eval &quot;$(goenv init -)&quot;&#x27; &gt;&gt; ~/.bashrc# 重新加载配置source ~/.bashrc# 安装指定版本的 Gogoenv install 1.18.10goenv install 1.21.5# 设置全局版本goenv global 1.21.5# 为特定项目设置版本cd /path/to/projectgoenv local 1.18.10 2. gvm (Go Version Manager)gvm 是另一个流行的 Go 版本管理工具。 安装方式： # 安装 gvmbash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)# 添加到 shell 配置echo &#x27;[[ -s &quot;$HOME/.gvm/scripts/gvm&quot; ]] &amp;&amp; source &quot;$HOME/.gvm/scripts/gvm&quot;&#x27; &gt;&gt; ~/.bashrc# 重新加载配置source ~/.bashrc# 安装和使用特定版本gvm install go1.18.10gvm install go1.21.5gvm use go1.18.10 3. 使用官方方式管理多个 Go 版本您也可以手动安装多个版本的 Go： # 下载并解压不同版本到不同目录wget https://go.dev/dl/go1.18.10.linux-amd64.tar.gzwget https://go.dev/dl/go1.21.5.linux-amd64.tar.gzsudo tar -C /usr/local -xzf go1.18.10.linux-amd64.tar.gzsudo tar -C /usr/local -xzf go1.21.5.linux-amd64.tar.gz# 创建符号链接来切换版本sudo ln -s /usr/local/go1.18.10 /usr/local/go-currentexport PATH=&quot;/usr/local/go-current/bin:$PATH&quot;# 或者直接使用完整路径/usr/local/go1.18.10/bin/go version/usr/local/go1.21.5/bin/go version 4. 使用 Docker如果您不想在本地安装多个 Go 版本，也可以使用 Docker 容器来运行不同版本的 Go： # 使用 Go 1.18 运行项目docker run -it -v $(pwd):/app -w /app golang:1.18 go run main.go# 使用 Go 1.21 运行项目docker run -it -v $(pwd):/app -w /app golang:1.21 go run main.go 推荐方案推荐使用 goenv，因为： 它简单易用，类似于 Python 的 pyenv 可以轻松地在项目级别设置特定的 Go 版本 不会影响系统其他部分 在项目目录下创建 .go-version 文件即可自动切换版本","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"go","slug":"go","permalink":"https://luckyship.github.io/tags/go/"}]},{"title":"vite 性能优化","date":"2025-07-28T23:19:29.000Z","path":"2025/07/29/2025-07-29-vite-optimize/","text":"Vite 本身因其原生 ESM、基于 esbuild 的极速构建和开发性能而被视为性能优秀的构建工具。但在大型项目中，Vite 性能依然可以进一步优化，主要可以从 开发时性能（dev server） 和 构建性能（build） 两大方向入手。 🔧 一、开发阶段性能优化（vite dev）1. ✅ 优化依赖预构建（预打包）Vite 会自动通过 esbuild 对依赖进行预构建（预打包），加快冷启动速度。 配置优化： optimizeDeps: &#123; include: [&#x27;lodash-es&#x27;, &#x27;dayjs&#x27;], // 指定预构建依赖（避免动态导入不被识别） exclude: [&#x27;jspdf&#x27;], // 排除某些大型包，避免打包过慢，该用cdn方式引入、例如video.js 、 jspdf等&#125; 2. ✅ 禁用不必要插件 / 中间件 一些插件（如 legacy、PWA、自动生成路由）会导致开发服务器变慢 推荐：仅在 build 环境中使用插件 plugins: isBuild ? [legacy(), compress(), visualizer()] : [vue()]; legacy 插件：用于兼容旧版浏览器，如 IE11。 compress 插件：用于压缩资源文件。 visualizer 插件：用于可视化打包分析。 3. ✅ 减少热更新开销（HMR） 避免巨型模块（如 store/index.ts）频繁被修改 拆分为小模块，按需 import，可提升 HMR 速度 使用 defineOptions() / defineStore() 替代手动注册模块 4. ✅ 提升冷启动速度 开启缓存（Vite 默认缓存到 node_modules/.vite） 避免项目根目录下存在大量无关文件（如 .git, dist, temp, 大图像等） 设置 server.watch.ignored 忽略监听无关路径： server: &#123; watch: &#123; ignored: [&#x27;**/dist/**&#x27;, &#x27;**/.git/**&#x27;], &#125;,&#125; 📦 二、构建阶段优化（vite build）1. ✅ 合理使用 Rollup 选项build: &#123; rollupOptions: &#123; output: &#123; manualChunks(id) &#123; if (id.includes(&#x27;node_modules&#x27;)) &#123; return &#x27;vendor&#x27; // 将 node_modules 单独打包 &#125; &#125; &#125; &#125;&#125; 2. ✅ 开启构建缓存 构建缓存是 Vite 4.x 后期引入的功能（通过 plugin 或自建缓存层） 可配合 turbo, nx, vite-plugin-cache 实现增量构建 3. ✅ 开启 CSS 代码分离 + 压缩build: &#123; cssCodeSplit: true, minify: &#x27;esbuild&#x27;, // 或 &#x27;terser&#x27;，但 esbuild 更快&#125; 4. ✅ 压缩体积 + 可视化分析插件推荐： rollup-plugin-visualizer —— 打包分析图 vite-plugin-compression —— 开启 gzip/br [vite-plugin-image-optimizer] —— 图像压缩 🌐 三、网络优化（适用于部署后）✅ 配合使用： HTTP/2 CDN 静态资源缓存 SSR with streaming (如 Vue SSR、React Server Component) 使用 vite-ssg 进行预渲染（静态化） 🧩 插件辅助优化（推荐） 插件 用途 vite-plugin-imp 按需引入组件库（如 antd） vite-plugin-compression Gzip/Brotli 压缩 vite-plugin-inspect 插件执行链调试工具 vite-plugin-cache 缓存构建文件，加速构建 rollup-plugin-visualizer 打包体积分析 🎯 实战推荐：性能优化 Checklist 阶段 优化项 建议 开发 缓存 node_modules/.vite ✅ 开启增量预构建 开发 HMR 变慢 ✅ 拆分模块，避免巨型文件 构建 构建慢 ✅ 使用 manualChunks, 开启缓存 构建 包大 ✅ 动态导入，gzip 压缩，Tree Shaking 构建 编译慢 ✅ 使用 esbuild 替代 babel / terser 构建 依赖大 ✅ 替换大型库，如 moment → dayjs","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"},{"name":"vite","slug":"vite","permalink":"https://luckyship.github.io/tags/vite/"}]},{"title":"Babel AST 魔法：Vite 插件如何让你的 try...catch 不再“裸奔”？","date":"2025-07-27T07:56:54.000Z","path":"2025/07/27/2025-07-27-vite-plugin/","text":"插件的“初心”：为什么需要它？在前端开发中，try...catch 块是处理异常的利器。但很多时候，开发者可能会写出这样的代码： try &#123; // 可能会出错的代码 throw new Error(&quot;Something went wrong&quot;);&#125; catch (e) &#123; // 捕获了错误，但可能没有处理，或者处理不当&#125; 或者更“偷懒”的： try &#123; // 可能会出错的代码 throw new Error(&quot;Something went wrong&quot;);&#125; catch &#123;&#125; // 捕获了，但啥也没干 这样一来，错误虽然被捕获了，但并没有被有效地记录下来（比如 console.error），导致问题难以追踪。这个插件的“初心”就是为了解决这个问题：自动在所有 try...catch 块的 catch 部分注入 console.error(error)，确保每一个被捕获的错误都能被打印出来。 核心思路：AST 转换要实现这个功能，我们不能简单地做字符串替换，因为代码结构复杂，容易出错。最可靠的方法是进行 抽象语法树（AST）转换。简单来说，就是把代码解析成一棵树形结构，然后在这棵树上找到 catch 节点，修改它，最后再把修改后的树重新生成为代码。 这里用到的主要工具是 Babel，它是一个强大的 JavaScript 编译器，能够帮助我们完成 AST 的解析、遍历和生成。 插件实现步骤详解 Vite 插件的骨架 首先，我们需要创建一个 Vite 插件。Vite 插件通常是一个返回 Plugin 对象的函数，其中最核心的是 transform 钩子。transform 钩子会在每个模块被 Vite 处理时调用，我们可以在这里拿到原始代码 code 和模块 ID id。 import &#123; Plugin &#125; from &quot;vite&quot;;// ... 其他导入const vitePluginTryCatchConsole = (): Plugin =&gt; &#123; return &#123; name: &quot;vite-plugin-try-catch-console&quot;, enforce: &quot;post&quot;, // 确保在其他转换之后执行 async transform(code, id) &#123; // 1. 过滤文件类型，只处理 JS/TS/JSX/TSX/Vue 文件，并跳过 node_modules if (!/\\.(js|ts|jsx|tsx|vue)$/.test(id) || id.includes(&quot;node_modules&quot;)) &#123; return null; // 不处理这些文件 &#125; // 2. 解析代码生成 AST const ast = parse(code, &#123; /* ...配置 */ &#125;); if (!ast) return null; let transformed = false; // 标记是否进行了转换 // 3. 遍历 AST，找到 CatchClause 节点并修改 traverse(ast, &#123; CatchClause(path) &#123; // ... 核心逻辑 transformed = true; &#125;, &#125;); // 4. 如果有修改，重新生成代码和 Source Map if (transformed) &#123; const output = generate(ast, &#123; sourceMaps: true, sourceFileName: id &#125;, code); return &#123; code: output.code, map: output.map &#125;; &#125; return null; // 没有修改则返回 null &#125;, &#125;;&#125;;export default vitePluginTryCatchConsole; Babel 的引入与配置 @babel/core：用于解析代码 (parse)。 @babel/traverse：用于遍历 AST (traverse)。 @babel/generator：用于将 AST 重新生成代码 (generate)。 @babel/types：提供了创建 AST 节点的方法 (t)。 在 parse 代码时，需要根据文件类型配置 Babel 插件，例如： import * as babel from &quot;@babel/core&quot;;import &#123; parse &#125; from &quot;@babel/core&quot;;import _traverse from &quot;@babel/traverse&quot;;const traverse = typeof _traverse === &quot;function&quot; ? _traverse : (_traverse as any).default; // 兼容不同导入方式import &#123; generate &#125; from &quot;@babel/generator&quot;; // 注意这里是命名导入import * as t from &quot;@babel/types&quot;;// ...const ast = parse(code, &#123; sourceType: &quot;module&quot;, filename: id, plugins: [ &quot;@babel/plugin-transform-typescript&quot;, // 处理 TypeScript &quot;@vue/babel-plugin-jsx&quot;, // 处理 Vue 中的 JSX，这是个坑点！ ],&#125;); 踩坑点 1：generate 的导入方式 一开始我可能写成了 import * as generate from &#39;@babel/generator&#39;;，导致 generate is not a function。这是因为 @babel/generator 的 generate 函数是作为命名导出（named export）的，而不是默认导出（default export）或整个模块的命名空间。正确的导入方式应该是 import &#123; generate &#125; from &#39;@babel/generator&#39;;。 踩坑点 2：JSX 插件的选择 在处理 Vue 文件时，如果代码中包含 JSX 语法（比如 render 函数里写 JSX），需要正确的 Babel JSX 插件。一开始我可能用了 @babel/plugin-transform-react-jsx，这是 React 专用的。在 Vue 项目中，应该使用 @vue/babel-plugin-jsx，否则会导致 JSX 语法解析失败，进而引发后续的错误。 核心逻辑：CatchClause 节点的处理 这是插件的“心脏”部分。我们通过 traverse 找到所有的 CatchClause 节点（即 catch (error) &#123; ... &#125; 中的 catch 部分）。 traverse(ast, &#123; CatchClause(path: babel.NodePath&lt;t.CatchClause&gt;) &#123; const block = path.node.body; // 获取 catch 块的函数体 // 检查 catch 块中是否已经有 console.error(error) 了 const hasConsoleError = block.body.some((statement: t.Statement) =&gt; &#123; return ( t.isExpressionStatement(statement) &amp;&amp; t.isCallExpression(statement.expression) &amp;&amp; t.isMemberExpression(statement.expression.callee) &amp;&amp; t.isIdentifier(statement.expression.callee.object, &#123; name: &quot;console&quot; &#125;) &amp;&amp; t.isIdentifier(statement.expression.callee.property, &#123; name: &quot;error&quot; &#125;) ); &#125;); if (!hasConsoleError) &#123; // 踩坑点 3：处理空的 catch 块和错误参数 // 如果 catch 块没有参数 (catch &#123;&#125;)，我们需要手动给它添加一个参数 if (!path.node.param) &#123; path.node.param = t.identifier(&quot;error&quot;); // 添加一个名为 &#x27;error&#x27; 的标识符作为参数 &#125; const errorArg = path.node.param as t.Identifier; // 获取 catch 块的错误参数 // 创建 console.error(errorArg) 语句 const consoleErrorStatement = t.expressionStatement( t.callExpression( t.memberExpression(t.identifier(&quot;console&quot;), t.identifier(&quot;error&quot;)), // console.error [errorArg] // 传入错误参数 ) ); // 将新语句插入到 catch 块的最前面 block.body.unshift(consoleErrorStatement); transformed = true; &#125; &#125;,&#125;); 踩坑点 3：ReferenceError: e is not defined 或 error is not defined 这个问题是最“磨人”的。当遇到 try &#123; ... &#125; catch &#123;&#125; 这种没有显式错误参数的 catch 块时，path.node.param 是 null。如果直接尝试使用 path.node.param 作为 console.error 的参数，就会导致 ReferenceError。解决方案是：在 path.node.param 为空时，手动创建一个 t.identifier(&#39;error&#39;) 并赋值给 path.node.param，这样 catch 块就会变成 catch (error) &#123;&#125;，然后我们再使用这个 error 标识符来构建 console.error(error) 语句。 插件所需依赖要让这个 vite-plugin-try-catch-console 插件正常工作，你需要安装以下 Babel 相关的核心依赖： npm install --save-dev @babel/core @babel/traverse @babel/generator @babel/types @babel/plugin-transform-typescript @vue/babel-plugin-jsx# 或者使用 yarnyarn add --dev @babel/core @babel/traverse @babel/generator @babel/types @babel/plugin-transform-typescript @vue/babel-plugin-jsx# 或者使用 pnpmpnpm add --save-dev @babel/core @babel/traverse @babel/generator @babel/types @babel/plugin-transform-typescript @vue/babel-plugin-jsx 这些包的作用分别是： @babel/core: Babel 的核心库，用于解析和转换代码。 @babel/traverse: 用于遍历 AST（抽象语法树）。 @babel/generator: 用于将 AST 重新生成为代码。 @babel/types: 提供了用于创建、验证和转换 AST 节点的工具函数。 @babel/plugin-transform-typescript: Babel 插件，用于处理 TypeScript 语法。 @vue/babel-plugin-jsx: Babel 插件，用于处理 Vue 项目中的 JSX 语法。 完整的 vite-plugin-try-catch-console.ts 文件内容经过我们之前的“打磨”，最终的插件代码如下： import &#123; Plugin &#125; from &quot;vite&quot;;import * as babel from &quot;@babel/core&quot;;import &#123; parse &#125; from &quot;@babel/core&quot;;import _traverse from &quot;@babel/traverse&quot;;const traverse = typeof _traverse === &quot;function&quot; ? _traverse : (_traverse as any).default;import &#123; generate &#125; from &quot;@babel/generator&quot;;import * as t from &quot;@babel/types&quot;;const vitePluginTryCatchConsole = (): Plugin =&gt; &#123; return &#123; name: &quot;vite-plugin-try-catch-console&quot;, enforce: &quot;post&quot;, // 确保在其他转换之后执行 async transform(code, id) &#123; // 1. 过滤文件类型，只处理 JS/TS/JSX/TSX/Vue 文件，并跳过 node_modules if (!/\\.(js|ts|jsx|tsx|vue)$/.test(id) || id.includes(&quot;node_modules&quot;)) &#123; return null; // 不处理这些文件 &#125; // 2. 解析代码生成 AST const ast = parse(code, &#123; sourceType: &quot;module&quot;, filename: id, plugins: [ &quot;@babel/plugin-transform-typescript&quot;, // 处理 TypeScript &quot;@vue/babel-plugin-jsx&quot;, // 处理 Vue 中的 JSX ], &#125;); if (!ast) &#123; return null; &#125; let transformed = false; // 标记是否进行了转换 // 3. 遍历 AST，找到 CatchClause 节点并修改 traverse(ast, &#123; CatchClause(path: babel.NodePath&lt;t.CatchClause&gt;) &#123; const block = path.node.body; // 获取 catch 块的函数体 // 检查 catch 块中是否已经有 console.error(error) 了 const hasConsoleError = block.body.some((statement: t.Statement) =&gt; &#123; return ( t.isExpressionStatement(statement) &amp;&amp; t.isCallExpression(statement.expression) &amp;&amp; t.isMemberExpression(statement.expression.callee) &amp;&amp; t.isIdentifier(statement.expression.callee.object, &#123; name: &quot;console&quot; &#125;) &amp;&amp; t.isIdentifier(statement.expression.callee.property, &#123; name: &quot;error&quot; &#125;) ); &#125;); if (!hasConsoleError) &#123; // 如果 catch 块没有参数 (catch &#123;&#125;)，我们需要手动给它添加一个参数 if (!path.node.param) &#123; path.node.param = t.identifier(&quot;error&quot;); // 添加一个名为 &#x27;error&#x27; 的标识符作为参数 &#125; const errorArg = path.node.param as t.Identifier; // 获取 catch 块的错误参数 // 创建 console.error(errorArg) 语句 const consoleErrorStatement = t.expressionStatement( t.callExpression( t.memberExpression(t.identifier(&quot;console&quot;), t.identifier(&quot;error&quot;)), // console.error [errorArg] // 传入错误参数 ) ); // 将新语句插入到 catch 块的最前面 block.body.unshift(consoleErrorStatement); transformed = true; &#125; &#125;, &#125;); // 4. 如果有修改，重新生成代码和 Source Map if (transformed) &#123; const output = generate(ast, &#123; sourceMaps: true, sourceFileName: id &#125;, code); return &#123; code: output.code, map: output.map &#125;; &#125; return null; // 没有修改则返回 null &#125;, &#125;;&#125;;export default vitePluginTryCatchConsole; 如何在 Vite 项目中引入插件 将插件文件放置到项目根目录 将上述代码保存为 文件，并放置在你的 Vite 项目的根目录下（与 vite.config.ts 同级）。 修改 vite.config.ts 文件 打开你项目中的文件，然后按照以下方式引入并使用这个插件： import &#123; defineConfig &#125; from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;import vitePluginTryCatchConsole from &quot;./vite-plugin-try-catch-console&quot;; // 引入你的插件// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ vue(), vitePluginTryCatchConsole(), // 在这里添加你的插件 ],&#125;); 注意： 插件的引入路径 ./vite-plugin-try-catch-console 是相对于 vite.config.ts 文件的。确保路径正确。 运行项目 保存所有修改后，重新运行你的 Vite 项目： npm run dev 现在，你的 try...catch 块就会被这个“尽职尽责”的插件自动注入 console.error 语句了！你可以尝试在 src/App.vue 中添加一个 try &#123; throw new Error(&#39;test error&#39;); &#125; catch &#123;&#125; 这样的代码，然后打开浏览器控制台，看看是否能看到错误信息被打印出来。 希望这份详细的“使用说明书”能帮助你更好地理解和使用这个插件！ 总结这个 vite-plugin-try-catch-console 插件的实现，本质上就是利用 Babel 对 JavaScript 代码进行 AST 级别的静态分析和转换。通过精确地定位 CatchClause 节点，并根据需要注入 console.error 语句，我们实现了在编译时自动增强代码的错误日志功能。","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"},{"name":"vite","slug":"vite","permalink":"https://luckyship.github.io/tags/vite/"}]},{"title":"angular 最新状态变更检测 signal","date":"2025-07-12T09:00:40.000Z","path":"2025/07/12/2025-07-12-angular-signal/","text":"在 Angular v16 及以后的版本中，使用 Signal 并非强制要求，传统的变更检测机制仍然完全有效。Signal 是一种可选的增强功能，用于优化性能和简化状态管理，但 Angular 的核心变更检测系统（基于 Zone.js 和脏检查）并未改变。 一、传统变更检测仍然有效如果你继续使用以下方式定义组件状态，变更检测仍会正常工作： @Input/@Output 装饰器 @Component(&#123; template: ` &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;button (click)=&quot;updateMessage()&quot;&gt;Update&lt;/button&gt; `,&#125;)export class MyComponent &#123; message = &quot;Initial value&quot;; updateMessage() &#123; this.message = &quot;Updated value&quot;; // 传统方式更新，变更检测会捕获 &#125;&#125; RxJS Observable + async 管道 @Component(&#123; template: ` &lt;p&gt;&#123;&#123; data$ | async &#125;&#125;&lt;/p&gt; &lt;!-- 仍然需要async管道 --&gt; `,&#125;)export class MyComponent &#123; data$ = this.http.get(&quot;/api/data&quot;); // 传统Observable方式&#125; ChangeDetectionStrategy.OnPush手动控制变更检测的策略仍然有效： @Component(&#123; changeDetection: ChangeDetectionStrategy.OnPush,&#125;)export class MyComponent &#123; @Input() data: any; @Output() updated = new EventEmitter();&#125; 二、Signal 与传统方式的对比 特性 传统方式 Signal 方式 触发变更检测的方式 事件、定时器、HTTP 请求等（Zone.js 捕获） 直接调用 Signal 的 set/update 方法 依赖追踪 全组件树检测（或 OnPush 限定） 自动追踪依赖，仅更新相关部分 模板语法 需要 async 管道处理 Observable 直接调用 Signal()即可 状态管理复杂度 手动管理订阅、不可变更新 自动处理，减少样板代码 三、何时应该使用 Signal？ 性能敏感的场景例如大型列表或频繁更新的 UI 组件，Signal 可以避免不必要的变更检测： @Component(&#123; template: ` &lt;ul&gt; @for (item of items(); track item.id) &#123; &lt;li&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &#125; &lt;/ul&gt; `,&#125;)export class MyListComponent &#123; items = signal&lt;Item[]&gt;([]); updateItems() &#123; this.items.update((old) =&gt; [...old, newItem]); &#125;&#125; 简化状态管理替代复杂的 RxJS 流，使代码更易读： // 传统方式this.data$.pipe(map((x) =&gt; x * 2)).subscribe((result) =&gt; (this.value = result));// Signal方式const source = signal(1);const result = computed(() =&gt; source() * 2); // 自动计算，无需订阅 跨组件状态共享在服务中定义 Signal，多个组件可直接使用： @Injectable(&#123; providedIn: &quot;root&quot; &#125;)export class AuthService &#123; isLoggedIn = signal(false); login() &#123; this.isLoggedIn.set(true); &#125;&#125; 四、Signal 与变更检测的交互 Signal 触发变更检测当 Signal 的值变化时，Angular 会触发变更检测，但仅针对依赖该 Signal 的组件： const count = signal(0);@Component(&#123; template: `&#123;&#123; count() &#125;&#125;`,&#125;)export class CounterComponent &#123; count = inject(MyService).count; // 仅该组件会在count变化时更新&#125; 与 OnPush 策略结合Signal 可以与ChangeDetectionStrategy.OnPush配合使用，进一步优化性能： @Component(&#123; changeDetection: ChangeDetectionStrategy.OnPush, template: `&#123;&#123; user().name &#125;&#125;`,&#125;)export class UserComponent &#123; @Input(&#123; transform: signal &#125;) user: Signal&lt;User&gt;;&#125; 五、渐进式采用 Signal你可以在现有项目中逐步引入 Signal，而不必重构整个应用： 在新组件中优先使用 Signal。 使用toSignal()将现有的 Observable 转换为 Signal： // 现有服务export class DataService &#123; getData() &#123; return this.http.get(&quot;/api/data&quot;); &#125;&#125;// 在组件中转换为Signalexport class MyComponent &#123; data = toSignal(this.dataService.getData(), &#123; initialValue: null &#125;);&#125; 对于复杂状态管理，可将 Signal 与 NgRx 等状态管理库结合使用。 总结 传统变更检测仍然有效：Angular 不会强制你使用 Signal，以前的变量定义和更新方式继续正常工作。 Signal 是增强而非替代：它提供了更高效的状态管理方式，尤其适合性能敏感或复杂的场景。 渐进式迁移：可以根据项目需求逐步引入 Signal，无需一次性重构整个应用。 Signal 代表了 Angular 状态管理的未来方向，但 Angular 团队一直致力于保持向后兼容性，确保开发者可以按照自己的节奏采用新特性。","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"深入理解 React 的 Fiber 架构","date":"2025-07-06T11:19:15.000Z","path":"2025/07/06/2025-07-06-react-fiber-node/","text":"传统 React 架构的局限性React 最初的架构在处理 UI 更新时采用了同步的、阻塞的方式。即一次更新会从根节点开始递归遍历整棵组件树，直至完成所有组件的渲染。这种方式在处理简单的 UI 时表现良好，但随着应用的复杂性增加，特别是在处理大量节点更新或频繁用户交互时，传统架构暴露出了以下几个主要局限性： 单次渲染时间过长：当组件树较大时，一次完整的渲染更新可能会占用大量的时间，这会导致主线程被阻塞，无法响应用户的输入，进而影响用户体验。 缺乏优先级管理：传统架构无法根据任务的重要性分配优先级，所有更新一视同仁，这意味着关键任务（如用户输入处理）可能会被不重要的任务（如低优先级的动画或日志更新）阻塞。 中断和恢复困难：在传统架构中，一旦开始渲染更新，就无法中途中断并恢复，这使得在处理高优先级任务时非常不灵活。 为什么需要 Fiber？为了克服传统 React 架构的局限性，React 团队提出了 Fiber 架构。Fiber 是 React 的一种新的协调引擎，它通过将更新过程拆分为多个小任务来解决性能瓶颈和用户体验问题。 性能瓶颈 增量渲染：Fiber 将渲染过程分成多个可以中断的小任务，这样即使组件树非常庞大，每个任务的执行时间也会较短，避免了长时间的阻塞。 任务分片：通过任务分片（Time Slicing）技术，Fiber 可以在空闲时间片段内执行渲染任务，从而最大限度地利用浏览器的空闲时间，提升整体性能。 用户体验问题 响应性提升：通过将任务拆分并分配优先级，Fiber 可以确保高优先级的用户交互任务能够尽快得到处理，而不会被低优先级任务阻塞。 平滑的用户体验：由于渲染过程可以中断并恢复，Fiber 可以更灵活地处理动画和过渡效果，提供更加平滑的用户体验。 Fiber 的目标React 团队设计 Fiber 架构的主要目标是： 提升性能：通过增量渲染和任务分片等技术，显著降低长时间渲染任务对用户体验的影响。 灵活性和扩展性：Fiber 架构为未来的新特性和优化奠定了基础，例如 Concurrent Mode 和 Suspense，这些特性能够进一步提升 React 应用的性能和开发体验。 可维护性和可调试性：新的架构不仅提升了性能，还改进了 React 内部的代码结构，使得调试和维护更加容易。 通过引入 Fiber 架构，React 在处理复杂和高频更新场景下的性能和用户体验方面取得了显著进步。接下来，我们将深入探讨 Fiber 的基本概念和工作原理。 Fiber 架构的基本概念什么是 Fiber？在 React 中，Fiber 是一种用于描述组件树的数据结构，它代表了一个可中断的、可恢复的渲染任务。传统的渲染过程是递归式的，一旦开始渲染，就无法中断，直到渲染完成或发生错误。而 Fiber 架构将渲染过程分解成多个小任务，使得在渲染过程中可以中断，并且可以根据需要重新调度任务。Fiber 的引入使得 React 应用能够更好地利用浏览器的空闲时间，提升性能和用户体验。 Fiber 是一种数据结构&#123; stateNode: new ClickCounter(), type: clickCounter, alternate: null, key: null, updateQueue: null, memoizedstate: &#123; count: 0 &#125;, pendingProps: &#123;&#125;, memoizedProps: &#123;&#125;, tag: 1, effectTag: 0, nextEffect: null,&#125;; Fiber 节点是一个 JavaScript 对象，用于描述组件树的结构和状态。每个 Fiber 节点包含了与组件相关的信息，如类型、props、state、效果标记（effect tag）等。Fiber 节点还包含了指向其子节点、兄弟节点和父节点的引用，以构建组件树的层级结构。Fiber 节点的数据结构设计使得 React 能够更高效地管理组件树的更新和渲染过程。 Fiber 树Fiber 树的创建过程Fiber 树的创建过程主要包括以下几个步骤： 根据 JSX 构建虚拟 DOM 树：React 会根据 JSX 语法构建虚拟 DOM 树，表示整个组件树的结构。 生成 Fiber 节点：对于每个虚拟 DOM 节点，React 会生成对应的 Fiber 节点，并建立起 Fiber 树的层级结构。 执行初次渲染：React 会从根节点开始递归遍历 Fiber 树，执行组件的生命周期方法和渲染函数，将组件树渲染到 DOM 中。 Fiber 节点之间通过不同类型的指针（如 child、sibling、return 等）相互连接，构成了 Fiber 树，表示了组件树的结构。 在 Fiber 架构中，Fiber 树的构建是一个增量的过程，即渲染过程可以在任意时刻中断，并在下一个空闲时间片段内恢复。这种设计使得 React 能够更灵活地处理大型组件树的更新，并且可以根据需要调整更新的优先级。 树的更新更新过程是指在组件状态或属性发生变化时，React 如何更新组件树以反映这些变化。树的协调和更新过程主要包括以下几个步骤： 触发更新：当组件的状态或属性发生变化时，React 会调用相应的更新函数，标记组件为需要更新状态。 生成新的虚拟 DOM 树：React 会根据新的状态或属性生成一棵新的虚拟 DOM 树，表示组件树的更新后状态。 协调新旧树：React 使用协调算法比较新旧两棵虚拟 DOM 树的差异，找出需要更新的部分。 执行更新：根据协调算法的结果，React 会更新 Fiber 树的相应节点，执行组件的生命周期方法和渲染函数，将更新后的组件树渲染到 DOM 中。 协调（Reconciliation） 在 React 中，协调是指确定组件树的更新方式，即如何将新的状态映射到 UI 上。传统的协调算法是递归式的深度优先遍历，即通过递归遍历虚拟 DOM 树来查找需要更新的节点，并进行相应的更新操作。然而，这种算法在处理大型组件树或高频更新时效率较低，可能导致界面卡顿或响应缓慢。 旧的协调算法传统的协调算法采用深度优先遍历虚拟 DOM 树的方式来进行更新。这种算法的问题在于，一旦开始更新，就无法中断，直到所有节点都完成更新或者发生错误。这导致在更新过程中无法处理其他任务，从而影响了用户体验。 新的协调算法：增量渲染为了解决传统协调算法的局限性，React 引入了一种新的协调算法：增量渲染。增量渲染的核心思想是将协调过程分解为多个小任务，并使用任务调度器（Scheduler）来动态地调度这些任务。这种方式使得在更新过程中可以中断，并在下一个空闲时间片段内恢复，从而提高了渲染的灵活性和效率。 通过增量渲染，React 能够更好地利用浏览器的空闲时间，提升界面的响应速度和用户体验。同时，增量渲染还为 React 引入了一些新的特性，如时间切片（Time Slicing）和任务优先级调度，使得 React 应用能够更好地适应不同的网络环境和设备性能。 Fiber 架构的工作原理双缓存什么是双缓存在 React 中，双缓存是一种用于解决 UI 渲染过程中闪烁和视觉不连续的技术。传统的渲染过程中，更新操作会直接修改 DOM，导致在更新过程中用户可能会看到中间状态的 UI，造成视觉上的不连续和不稳定。双缓存技术通过在内存中维护两份 UI 状态，一份用于渲染当前帧，另一份用于计算下一帧的状态，从而避免了直接在 DOM 上进行更新操作。 双缓存 Fiber 树在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。 current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。 currentFiber.alternate === workInProgressFiber;workInProgressFiber.alternate === currentFiber; React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。 即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。 每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。 接下来我们以具体例子讲解mount、update的构建/替换流程。 mount 时function App() &#123; const [count, add] = useState(0); return &lt;div onClick=&#123;() =&gt; add(count + 1)&#125;&gt;&#123;count&#125;&lt;/div&gt;;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;)); 首次创建时 首次执行ReactDOM.render会创建fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是&lt;App/&gt;所在组件树的根节点。 之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。 fiberRootNode的current会指向当前页面上已渲染内容对应Fiber树，即current Fiber树。 fiberRootNode.current = rootFiber; 由于是首屏渲染，页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。 渲染阶段 接下来进入 render 阶段，根据组件返回的 JSX 在内存中依次创建 Fiber 节点并连接在一起构建 Fiber 树，被称为 workInProgress Fiber 树 。 在构建 workInProgress Fiber 树时会尝试复用 current Fiber 树中已有的 Fiber 节点内的属性，在首屏渲染时只有 rootFiber 存在对应的 current fiber (即 rootFiber.alternate ) 。 下图中左侧为页面显示的树，右侧为内存中构建的树： 提交阶段 已构建完的 workInProgress Fiber 树 在 commit 阶段 渲染到页面。 此时 DOM 更新为右侧树对应的样子。fiberRootNode 的 current 指针指向 workInProgress Fiber 树 使其变为 current Fiber 树 。 update 时 点击 div 节点，触发状态改变 接下来我们点击 div 节点触发状态改变，这会开启一次新的 render 阶段并构建一棵新的 workInProgress Fiber 树。 和 mount 时一样，workInProgress fiber 的创建可以复用 current Fiber 树对应的节点数据。 渲染之后，提交 workInProgress Fiber 树在 render 阶段 完成构建后进入 commit 阶段 渲染到页面上。渲染完毕后，workInProgress Fiber 树变为 current Fiber 树。 双缓存技术能够有效地解决 UI 渲染过程中的闪烁和不连续问题，提升用户体验和界面稳定性。 时间切片什么是时间切片时间切片是一种将任务拆分成多个小片段，在浏览器空闲时间执行的技术。在 React 中，时间切片被用于将渲染任务拆分成多个小任务，并在多个帧之间动态调度执行，以提高页面的响应速度和用户体验。 任务队列（Task Queue）: React 将所有的更新操作（如状态更新或属性更改）封装成任务，并放入一个任务队列中。 执行任务: React 从任务队列中取出任务并执行。在执行过程中，React 会检查当前任务的执行时间。 时间检查: 如果任务的执行时间超过了一个预设的阈值（默认是 5 毫秒），React 会中断当前任务的执行。 让出线程: React 使用 MessageChannel 和 postMessage API 来让出执行线程。这意味着浏览器可以在此时处理其他任务，如用户输入或动画。 继续执行: 一旦浏览器处理完其他任务，它将通过 onmessage 事件来继续执行之前中断的任务。 循环执行: 这个过程会一直重复，直到任务队列中的所有任务都被执行完毕。 优先级调度不同优先级的任务// 无优先级任务export const NoPriority = 0;// 立即执行任务export const ImmediatePriority = 1;// 用户阻塞任务export const UserBlockingPriority = 2;// 正常任务export const NormalPriority = 3;// 低优先级任务export const LowPriority = 4;// 空闲执行任务export const IdlePriority = 5; 在 React 中，任务被划分为不同的优先级，以便根据任务的重要性进行调度。通常情况下，React 将任务分为以下几个优先级： 同步任务：最高优先级的任务，通常用于处理用户交互事件和页面加载过程中的同步操作。 异步任务：中等优先级的任务，包括普通的更新任务和网络请求等异步操作。 空闲任务：最低优先级的任务，通常用于执行一些不紧急的任务，如日志记录或统计信息收集等。 调度器的工作方式调度器是 React 中负责任务调度的核心组件，它根据任务的优先级和类型来动态地安排任务的执行顺序。调度器会监视浏览器的空闲时间，并根据当前任务队列中的任务优先级，决定在何时执行哪些任务。 React Fiber 与 Concurrent Mode什么是 Concurrent ModeConcurrent Mode 是 React Fiber 的一项重要特性，它是一种新的渲染模式，旨在提高 React 应用的性能和用户体验。在 Concurrent Mode 下，React 能够在多个优先级任务之间动态地调度执行，使得高优先级任务能够优先得到处理，从而提高了页面的响应速度和用户交互的流畅度。 Concurrent Mode 如何利用 FiberConcurrent Mode 利用了 Fiber 架构的增量渲染和时间切片技术，实现了多优先级任务的动态调度。通过 Fiber 架构，React 能够将渲染任务拆分成多个小任务，并在浏览器空闲时间执行，从而最大限度地利用浏览器的资源，提高了渲染效率和用户体验。 Concurrent Mode 的实际应用batchedUpdates在 React 的事件处理过程中，如果连续触发多次状态更新，这些更新可能会被智能地合并为单一的更新操作，以避免不必要的渲染。例如，以下代码片段： // classonClick() &#123; this.setState(&#123; count: 1 &#125;); this.setState(&#123; flag: false &#125;); this.setState(&#123; count: 2 &#125;);&#125;// functionconst [count, setCount] = useState(0);const [flag, setFlag] = useState(false);function handleClick() &#123; setCount((c) =&gt; c + 1); // 不会重新render setFlag((f) =&gt; !f); // 不会重新render // // 合并后才会 重新render&#125; 尽管看起来我们进行了三次状态更新，实际上，React 会将这些更新合并，只触发一次组件的重新渲染。这种优化策略被称为 batchedUpdates。 batchedUpdates 在 React 早期版本就已经存在，但其早期实现有一定的局限性，主要是它不能合并那些脱离当前上下文环境的更新。 在 Concurrent Mode 这种模式下，状态更新的合并不再局限于当前上下文，而是根据更新的优先级来决定是否合并。这意味着，即使更新操作发生在不同的上下文或异步操作中，只要它们的优先级允许，这些更新仍然可以被有效地合并。 这种基于优先级的更新合并策略，不仅提高了应用的响应速度，还使得状态管理更加高效和灵活。 SuspenseSuspense 是一种用于在组件树中等待异步加载内容的机制，能够在数据加载完成之前显示占位符或 loading 界面，从而提高用户体验。 Lazy LoadingLazy Loading 是一种延迟加载组件或资源的技术，能够提高页面的加载速度和响应速度，减少初次加载时的资源占用和等待时间。 useDeferredValueuseDeferredValue是一个 React Hook，返回一个延后更新的值。 const deferredValue = useDeferredValue(value); 在useDeferredValue内部会调用useState并触发一次更新。 这次更新的优先级很低，所以当前如果有正在进行中的更新，不会受useDeferredValue产生的更新影响。所以useDeferredValue能够返回延迟的值。 Concurrent Mode 还提供了一种优雅降级的机制，用于处理低优先级任务无法立即执行的情况。在任务无法立即执行时，Concurrent Mode 能够自动调整任务的优先级，保证高优先级任务能够得到及时处理，从而避免页面加载和渲染的阻塞，提高用户体验的稳定性和流畅度。 结论Fiber 架构作为 React 的核心架构之一，为 React 应用的性能和用户体验带来了重大改进和优势： 增量渲染和时间切片：Fiber 架构通过增量渲染和时间切片技术，将渲染任务拆分成多个小任务，在浏览器空闲时间执行，提高了页面的响应速度和用户交互的流畅度。 优先级调度：Fiber 架构根据任务的优先级动态调度任务的执行顺序，确保高优先级任务能够优先得到处理，提高了系统的响应速度和稳定性。 Concurrent Mode 和 Suspense：Concurrent Mode 和 Suspense 是 Fiber 架构的重要特性，能够提高页面加载速度和性能表现，优化用户的交互体验。 转载","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://luckyship.github.io/tags/react/"}]},{"title":"为什么 JavaScript 中 `'str'` 不是对象，却能调用方法？","date":"2025-07-06T04:12:25.000Z","path":"2025/07/06/2025-07-06-js-string/","text":"我们在日常 JavaScript 编程中，经常会看到这样的代码： &quot;hello&quot;.toUpperCase(); // &#x27;HELLO&#x27; 你可能会想：&#39;hello&#39; 是字符串字面量，它不是对象，那为什么可以调用方法？更有趣的是： console.log(&quot;hello&quot; instanceof String); // falseconsole.log(new String(&quot;hello&quot;) instanceof String); // true 这就引出一个非常核心但又容易被忽略的问题： 为什么 JavaScript 中的字符串（&#39;str&#39;）不是对象？为什么不一开始就写成 new String(&#39;str&#39;)？这样不是更统一吗？ 本文将从原始值、包装对象、自动装箱机制、性能设计等角度全面解答这个问题。 一、字符串是对象吗？先上个例子： typeof &quot;hello&quot;; // &#x27;string&#x27;typeof new String(&quot;hello&quot;); // &#x27;object&#x27;&quot;hello&quot; instanceof String; // falsenew String(&quot;hello&quot;) instanceof String; // true 结论很明确： &#39;hello&#39; 是原始值（primitive），不是对象。 new String(&#39;hello&#39;) 是包装对象（boxed object），是 String 构造函数实例。 二、但为什么 &#39;hello&#39;.toUpperCase() 能调用方法？这其实是 JavaScript 中的一个 “自动装箱（autoboxing）”机制 在默默帮我们工作。 当你调用 &#39;hello&#39;.toUpperCase() 时，JS 引擎会做如下处理： // 隐式转换：new String(&quot;hello&quot;).toUpperCase(); 即： 临时把 &#39;hello&#39; 转成 new String(&#39;hello&#39;)。 调用其原型方法。 调用完毕后销毁这个临时对象，返回结果。 这就是为什么你能像调用对象方法一样使用原始值的原因。 三、为什么不直接让 &#39;str&#39; 就是 new String(&#39;str&#39;)？你可能会想：如果字符串本质就是对象，那是不是设计更统一？其实这是 JS 的设计者故意 不这么做，主要基于以下几点考虑： 1. 性能更好 原始值（如 &#39;abc&#39;, 42, true）是 轻量级的值，没有原型链，访问快，内存小。 如果每个字符串默认都是 new String()，那在大量字符串处理时会显著增加内存占用和 GC 压力。 💡 原始值 = 快速 + 轻量包装对象 = 灵活 + 占内存 JS 要求两者兼得，就引入了“按需装箱”的机制。 2. 语义更清晰，避免陷阱&quot;abc&quot; === new String(&quot;abc&quot;); // false 如果字符串全是对象，值比较就会引发各种“引用 vs 值”的混淆。 比如 Set、Map 的 key 也可能行为不一致。 const set = new Set();set.add(&quot;abc&quot;);set.add(new String(&quot;abc&quot;));console.log(set.size); // 2！不是你想象的 1 这会导致开发者很容易掉坑。 3. 语法一致性体验JavaScript 是“用户友好”的语言： &quot;abc&quot;.length;&quot;abc&quot;.charAt(1); 这些都能正常工作，背后靠的是临时的包装对象实现方法访问，而不是强迫你每次写 new String()。 开发者用得顺手，引擎帮你处理复杂性，这正是 JS 设计的初衷。 四、自动装箱有性能问题吗？几乎没有。 现代 JS 引擎（如 V8）对自动装箱做了很多优化： 使用“隐藏类”、“内联缓存”等机制避免真正 new 出一个对象。 包装对象是临时的，用完即销毁，GC 非常快。 所以你大可以放心使用 &#39;abc&#39;.toUpperCase()，性能不是问题。 五、何时会主动使用包装对象？虽然大多数情况下你不需要用 new String()，但以下场景可能会用到： ✅ 需要对象行为时（如挂属性）const str = new String(&quot;abc&quot;);str.custom = &quot;hello&quot;;console.log(str.custom); // &#x27;hello&#x27; 注意：原始字符串不能挂属性，挂上也访问不到。 ✅ 特殊 API 要求对象作为 key比如 WeakMap 的 key 必须是对象： const wm = new WeakMap();const n = new Number(123);wm.set(n, &quot;value&quot;); // 合法 六、总结 问题 解释 &#39;str&#39; 是对象吗？ ❌ 不是，是原始值 为什么能调用方法？ ✅ 自动装箱：临时转成包装对象调用方法 为什么不是直接用对象？ 性能更好、语义更清晰 装箱有性能问题吗？ 几乎没有，现代引擎优化很好 包装对象还用吗？ 极少用，除非你需要挂属性、作为对象键 ✅ 最后一句话总结： JavaScript 中的 &#39;str&#39; 是原始值，为了性能与语义清晰；包装对象是幕后英雄，让原始值也拥有“像对象一样”的能力，而自动装箱机制则平衡了两者的矛盾，体现了 JavaScript 的灵活与巧妙。","updated":"2025-08-02T05:46:04.182Z","tags":[]},{"title":"自己实现一个简单版 Pinia（miniPinia）","date":"2025-06-23T12:55:56.000Z","path":"2025/06/23/2025-06-23-mini-pinia/","text":"我们做一个极简 Pinia，实现： 创建 store 响应式 state 支持 actions 支持在组件中使用 创建 storecreatePinia() —— 创建一个”全局容器” export function createPinia() &#123; const stores = new Map(); return &#123; install(app) &#123; app.provide(piniaSymbol, this); &#125;, _stores: stores, useStore(storeId, createStoreFn) &#123; if (!this._stores.has(storeId)) &#123; const store = createStoreFn(); this._stores.set(storeId, store); &#125; return this._stores.get(storeId); &#125;, &#125;;&#125; 相当于 Pinia 实例，持有所有的 store（用 Map 存储） 提供 useStore 方法，确保每个 store 是单例 在 app.use(pinia) 时通过 provide 将 pinia 实例挂进 Vue 的上下文中（用于 inject()） 🔁 store 是单例的，怎么实现的？ if (!this._stores.has(storeId)) &#123; const store = createStoreFn(); this._stores.set(storeId, store);&#125; 每个 storeId 对应的 store 只会初始化一次 后续所有 useStore() 都返回同一个对象 defineStore() —— 定义 store 的注册逻辑export function defineStore(id, setupFn) &#123; return function useStore() &#123; const pinia = inject(piniaSymbol); if (!pinia) throw new Error(&quot;Pinia not installed&quot;); return pinia.useStore(id, () =&gt; setupFn()); &#125;;&#125; 使用者写：defineStore(&#39;counter&#39;, () =&gt; &#123; ... &#125;) 返回一个函数 useStore()，用于组件中调用 内部调用 pinia 的 useStore()，传入 storeId 和 setup 逻辑 注入 pinia 实例，从 provide 中获取，确保 store 可以在全局访问 setupFn() —— 创建响应式的 state 和 actionsconst state = reactive(&#123; count: 0 &#125;);function increment() &#123; state.count++;&#125; 使用 Vue 3 的 reactive() 创建响应式数据 组合式 API 的方式将 state 和方法组织成一个 store 返回给组件使用 useStore() in 组件中 —— 获取 store 实例const counter = useCounterStore(); 整体代码🔧 miniPinia.js // miniPinia.jsimport &#123; reactive, inject, provide &#125; from &quot;vue&quot;;const piniaSymbol = Symbol(&quot;miniPinia&quot;);export function createPinia() &#123; const stores = new Map(); return &#123; install(app) &#123; app.provide(piniaSymbol, this); &#125;, _stores: stores, useStore(storeId, createStoreFn) &#123; if (!this._stores.has(storeId)) &#123; const store = createStoreFn(); this._stores.set(storeId, store); &#125; return this._stores.get(storeId); &#125;, &#125;;&#125;export function defineStore(id, setupFn) &#123; return function useStore() &#123; const pinia = inject(piniaSymbol); if (!pinia) throw new Error(&quot;Pinia not installed&quot;); return pinia.useStore(id, () =&gt; setupFn()); &#125;;&#125; // counterStore.jsimport &#123; reactive &#125; from &quot;vue&quot;;import &#123; defineStore &#125; from &quot;./miniPinia&quot;;export const useCounterStore = defineStore(&quot;counter&quot;, () =&gt; &#123; const state = reactive(&#123; count: 0, &#125;); function increment() &#123; state.count++; &#125; return &#123; state, increment, &#125;;&#125;); &lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Count: &#123;&#123; counter.state.count &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;counter.increment()&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt; import &#123; useCounterStore &#125; from &quot;./counterStore&quot;; const counter = useCounterStore();&lt;/script&gt; // main.jsimport &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createPinia &#125; from &quot;./miniPinia&quot;;const app = createApp(App);const pinia = createPinia();app.use(pinia);app.mount(&quot;#app&quot;);","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"PostgreSQL数据库备份还原","date":"2025-01-11T08:01:25.000Z","path":"2025/01/11/2025-01-11-postgresql-backup/","text":"前言 逻辑备份 即 SQL 转储方式，使用 pg_dump 和 pg_dumpall 进行备份。逻辑备份在恢复时，介于逻辑备份与故障时间点之间的数据难以恢复，所以逻辑备份适用于留存某个时间点的备份或进行跨平台跨版本的数据迁移。 文件系统级备份 即拷贝数据文件的完整目录，备份时需要关闭数据库。恢复数据库时，只需将数据目录复制到原来的位置。该方式实际工作中很少使用。 连续归档 该方式是把一个文件系统级别的全量备份和 WAL(预写式日志)级别的增量备份结合起来。当需要恢复时，我们先恢复文件系统级别的备份，然后重放备份的 WAL 文件，把系统恢复到之前的某个状态。 本文主要介绍逻辑备份和连续归档方式的备份及还原，文件系统级备份由于比较简单，这里不在赘述。以下操作使用的数据库版本为 PostgreSQL 12.5，不同的数据库版本在进行连续归档操作时会有细微差异。 逻辑备份使用sql命令备份部分数据（适用于修改删除某些特定数据的备份）# 备份到指定csv表格psql -h localhost -U username -d database -p 5433 -c &quot;\\copy (select * from test_table oc where id = 139375) TO &#x27;~/test.csv&#x27; WITH (FORMAT CSV, HEADER);&quot;# 从csv表格恢复数据到数据库psql -h localhost -U username -d database -p 5433 -c &quot;\\copy test_table FROM &#x27;~/test.csv&#x27; WITH (FORMAT CSV, HEADER);&quot; pg_dump 工具以下为 pg_dump 工具的常用参数选项（更多参数可使用 pg_dump –help 查看） 联接选项:-h, --host=主机名 数据库服务器的主机名或套接字目录-U, --username=名字 以指定的数据库用户联接-d, --dbname=DBNAME 对数据库 DBNAME备份-p, --port=端口号 数据库服务器的端口号-w, --no-password 永远不提示输入口令-W, --password 强制口令提示 (自动)--role=ROLENAME 在转储前运行SET ROLE一般选项:-f, --file=FILENAME 输出文件或目录名，导出到指定文件-F, --format= p|c|d|t 导出文件格式（p|c|d|t） p：plain-输出普通文字SQL脚本（默认）； c：custom-输出自定义归档格式，适用于pg_restore导入，该格式是最灵活导出方式，允许在导入时自定义选择和重 排序归档条目。该格式默认启用压缩； d：directory-输出文件夹归档格式，适用于pg_restore导入。该格式会创建一个文件夹，一个表对应一个文件。该格式默认启用压缩，并且支持并行导出； t：tar-输出tar压缩归档格式，适用于pg_restore导入。该格式将文件夹归档格式产生的文件夹压缩成tar压缩包。但该格式不支持压缩（文件夹归档已经压缩了），并且在导入时也不能更改相关的表顺序。控制输出内容选项:-s, --schema-only 只转储模式, 不包括数据-a, --data-only 只转储数据,不包括模式-t, --table=TABLE 只转储指定名称的表-T, --exclude-table=TABLE 不转储指定名称的表-C, --create 在转储中包括创建数据库语句-c, --clean：包含drop删除语句，建议与--if-exists同时使用；--if-exists，drop删除语句时带上IF EXISTS指令-n, --schema=SCHEMA 只转储指定名称的模式-N, --exclude-schema=SCHEMA 不转储已命名的模式-O, --no-owner 在明文格式中, 忽略恢复对象所属者-S, --superuser=NAME 在明文格式中使用指定的超级用户名--column-inserts 以带有列名的INSERT命令形式转储数据--inserts 以INSERT命令，而不是COPY命令的形式转储数据--disable-triggers 在只恢复数据的过程中禁用触发器--exclude-table-data=TABLE 不转储指定名称的表中的数据--no-synchronized-snapshots 在并行工作集中不使用同步快照--no-tablespaces 不转储表空间分配信息--no-unlogged-table-data 不转储没有日志的表数据--quote-all-identifiers 所有标识符加引号，即使不是关键字--section=SECTION 备份命名的节 (数据前, 数据, 及 数据后)--serializable-deferrable 等到备份可以无异常运行--snapshot=SNAPSHOT 为转储使用给定的快照--strict-names 要求每个表和/或schema包括模式以匹配至少一个实体 常用示例： #备份schema及数据，指定数据库pg_hive，指定文件为pg_hive20210108.sqlpg_dump -h 127.0.0.1 -U postgres -d pg_hive -f /opt/pg_hive20210108.sql#只备份schemapg_dump -h 127.0.0.1 -U postgres -d pg_hive -s -f /opt/pg_hive20210108.sql#只备份数据pg_dump -h 127.0.0.1 -U postgres -d pg_hive -a -f /opt/pg_hive20210108.sql#备份单个表pg_dump -h 127.0.0.1 -U postgres -d pg_hive –t table1 -f /opt/pg_hive20210108.sql#备份多个表pg_dump -h 127.0.0.1 -U postgres -d pg_hive –t table1 –t table2 -f /opt/pg_hive20210108.sql#以带有列名的INSERT命令形式转储数据pg_dump -h 127.0.0.1 -U postgres -d pg_hive --column-inserts -f /opt/pg_hive20210108.sql#指定导出格式为自定义格式(二进制形式)pg_dump -h 127.0.0.1 -U postgres -d pg_hive -Fc -f /opt/pg_hive20210108.dump#使用gzip压缩转储（针对大型数据库）pg_dump -h 127.0.0.1 -U postgres -d pg_hive | gzip &gt; /opt/pg_hive20210108_gz.sql.gz#使用split切片文件（针对大型数据库）/pg_dump -h 127.0.0.1 -U postgres -d pg_hive | split -b 100m - /opt/pg_hive20210108_sp.sql pg_dumpall 工具相对于 pg_dump 只能备份单个库，pg_dumpall 可以备份整个PostgreSql实例中所有的数据，包括角色和表空间定义。 使用示例： #备份整个postgresql实例中所有的数pg_dumpall -h 127.0.0.1 -U postgres -f /opt/pg_hive20210108_all.sql 逻辑备份还原逻辑备份的还原命令为 psql 和 pg_restore：如果使用 pg_dump 未指定 format（即未使用-F 参数），则导出的是 SQL 脚本，导入时需用 psql 命令，否则用 pg_restore 还原。因这 2 个还原工具大部分参数与 pg_dump 含义相近，可使用命令后加–help 查看详细参数。 常用示例： #pg_dump备份时未指定format，还原时用psqlpsql -h 127.0.0.1 -U postgres -d pg_hive -f /opt/pg_hive20210108.sql#pg_dump备份时候使用-F参数指定format，还原时用pg_restorepg_restore -h 127.0.0.1 -U postgres -d pg_hive /opt/pg_hive20210108.dump#还原gzip压缩数据库备份gunzip -c /opt/pg_hive20210108_gz.sql.gz | psql -h 127.0.0.1 -U postgres -d pg_hive#还原切片数据库备份cat /opt/pg_hive20210108_sp.sql* | psql -h 127.0.0.1 -U postgres -d pg_hive 连续归档备份连续归档是通过基础备份和 wal 日志相结合的方式进行备份，恢复的时候可以选择恢复到指定的时间点、指定事务点、或者完全恢复到 wal 日志的最新位置。 操作步骤如下：1、创建备份目录 #创建基础备份目录mkdir -p /data/pg_base#创建wal日志备份目录mkdir -p /data/pg_archive 注意新建备份文件夹的权限及所有者，否则会备份失败 #更新备份文件夹的所有者chown postgres:postgres /data/pg_basechown postgres:postgres /data/pg_archive 2、修改配置文件 打开 postgresql.conf 配置文件，修改以下 3 个参数： vi postgresql.conf#wal_level中有三个主要的参数：minimal、archive和hot_standby。1.minimal是默认的值，它仅写入崩溃或者突发关机时所需要的信息（不建议使用）。2.archive是增加wal归档所需的日志（最常用）。3.hot_standby是在备用服务器上增加了运行只读查询所需的信息，一般实在流复制的时候使用到wal_level = archive#开启归档模式archive_mode = on#备份wal日志，每天生成一个日期命名的文件夹archive_command = &#x27;DIR=/data/pg_archive/`date +%F`; test ! -d $DIR &amp;&amp; mkdir -p $DIR; test ! -f $DIR/%f &amp;&amp; cp %p $DIR/%f&#x27; 3、重启 pg 数据库 命令为：pg_ctl restart4、创建表该步骤为测试备份及恢复效果使用 --创建表，插入10条测试数据：create table test (id integer);insert into test values(generate_series(1,10)); 5、做基础备份 pg_basebackup -Ft -Pv -Xf -z -Z5 -D /data/pg_base/`date +%F` 为了测试备份和恢复效果，再插入 10 条数据，并进行手动切换 wal 日志，执行如下 sql： #插入数据insert into test values(generate_series(1,10));#切换wal日志select pg_switch_wal(); 连续归档恢复1、创建 data 文件夹 #重命名原来的data文件夹mv /pgsql/postgresql/data /pgsql/postgresql/data.bak#创建新的data文件夹mkdir data 2、解压基础备份至新建的 data 文件夹 #拷贝基础备份到新建data文件夹cp /data/pg_base/2021-01-15/base.tar.gz /pgsql/postgresql/data#解压文件tar -zxvf base.tar.gz#删除基础备份中的wal日志和postmaster.pid文件Cd /pgsql/postgresql/datarm -rf pg_walrm -rf postmaster.pid#创建archive_status文件夹mkdir -p pg_wal/archive_status 3、修改配置文件 vi postgresql.conf#修改restore_command为要恢复的wal日志目录restore_command = &#x27;cp /data/pg_archive/2021-01-15/%f %p&#x27; 4、新建 recovery.signal 文件 #恢复时依赖该文件，恢复至最新wal位置，文件无需添加内容touch recovery.signal 5、赋权并启动数据库 #新建的data文件夹更改所有者chown -R postgres:postgres /pgsql/postgresql/data#修改data目录权限，否则会因为目录权限过大无法启动数据库chmod 0700 data -R#启动数据库pg_ctl start","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"sql","slug":"sql","permalink":"https://luckyship.github.io/tags/sql/"},{"name":"postgresql","slug":"postgresql","permalink":"https://luckyship.github.io/tags/postgresql/"}]},{"title":"linux-command","date":"2024-07-01T03:10:05.000Z","path":"2024/07/01/2024-07-01-linux-command/","text":"查看大文件 # 可查看任意目录下的大文件sudo du -h --max-depth=1 / | sort -hr","updated":"2025-08-02T05:46:04.182Z","tags":[]},{"title":"一文彻底搞懂providedIn的所有选项，除了root还能选择啥","date":"2024-04-13T11:32:09.000Z","path":"2024/04/13/2024-04-13-angular-service-providedIn/","text":"当我们在创建 angular 的服务时，providedIn的选项默认都是root，有的小伙伴就会问了，这个providedIn是做什么的，除了 root 还能填其他值嘛 🤔。 查阅angular(v15)文档，发现providedIn总共有 5 种值 root：在大多数应用程序中是指应用程序级注入器。 any：在每个惰性加载的模块中提供一个唯一实例，而所有热切加载的模块共享一个实例。 null：等效于 undefined 。可注入物不会在任何范围内自动提供，必须添加到@NgModule 、 @Component或@Directive的 providers 数组中。 platform：由页面上所有应用程序共享的特殊单例平台注入器。 Type&lt;any&gt; - 将可注入物与 @NgModule 或其他 InjectorType 相关联。此选项已弃用。 angular 官网的文档一如既往的不给力 😳，只有选项，并没有示例说明，下面我们通过几个具体的例子，来看看这几个选项具体的表现 😎 rootprovidedIn 最常见的就是 root，因为服务创建时，默认值都是 root， root 就是在项目根目录创建一个实例，所有注入这个服务的组件，都会共享这个实例。利用这个特性，我们经常使用它去做组件间的传值，或者做全局的传值。 我们按照下面步骤，创建一个示例 创建 2 个 module， 分别命名为 root-first、root-second，并且使用路由懒加载 创建rootService, providedIn为 root, 创建变量count 给 2 个 moudlue 中的 component 都引入rootService, 显示变量count，并且添加+按钮使count + 1 import &#123; Component, NgModule &#125; from &quot;@angular/core&quot;;import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; RouterModule &#125; from &quot;@angular/router&quot;;import &#123; Injectable &#125; from &quot;@angular/core&quot;;@Injectable(&#123; providedIn: &quot;root&quot;,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125;// 第一个module@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt; root-first: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-second&#x27;&quot;&gt; second &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootFirstComponent, &#125;, ]), ], declarations: [RootFirstComponent],&#125;)export class RootFirstModule &#123;&#125;// 第二个module@Component(&#123; selector: &quot;root-second&quot;, template: ` &lt;div&gt; root-second: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-first&#x27;&quot;&gt; first &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootSecondComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootSecondComponent, &#125;, ]), ], declarations: [RootSecondComponent],&#125;)export class RootSecondModule &#123;&#125;// app component, app module@Component(&#123; selector: &quot;app-root&quot;, template: ` &lt;router-outlet&gt;&lt;/router-outlet&gt; `, styles: [``],&#125;)export class AppComponent &#123;&#125;@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule, RouterModule.forRoot([ &#123; path: &quot;root-first&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootFirstModule), &#125;, &#123; path: &quot;root-second&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootSecondModule), &#125;, ]), ], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 如图，我们可以看到，在 root-first 中改变变量的值，在 root-second 中一样会起效，同样在 root-second 中改值，root-first 也会生效。 any每个懒加载的模块中会分别共享一个实例，而所有非懒加载的模块共享一个实例 什么意思呢，同样是上面的代码，我们把 service 中的providedIn改为any，这个时候，在 root-first 中改变值，root-second 中的值就不会变化了 @Injectable(&#123; providedIn: &quot;any&quot;,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125; 这个时候如果我们把 root-first 改为急性加载，并在 app.component 中也注入 root.service import &#123; Component, NgModule &#125; from &quot;@angular/core&quot;;import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; RouterModule &#125; from &quot;@angular/router&quot;;import &#123; Injectable &#125; from &quot;@angular/core&quot;;@Injectable(&#123; providedIn: &quot;any&quot;,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125;// 第一个module@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt; root-first: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-second&#x27;&quot;&gt; second &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;root-first&quot;, component: RootFirstComponent, &#125;, ]), ], declarations: [RootFirstComponent],&#125;)export class RootFirstModule &#123;&#125;// 第二个module@Component(&#123; selector: &quot;root-second&quot;, template: ` &lt;div&gt; root-second: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-first&#x27;&quot;&gt; first &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootSecondComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootSecondComponent, &#125;, ]), ], declarations: [RootSecondComponent],&#125;)export class RootSecondModule &#123;&#125;// app component, app module@Component(&#123; selector: &quot;app-root&quot;, template: ` app header: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, styles: [``],&#125;)export class AppComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule, RootFirstModule, RouterModule.forRoot([ // &#123; // path: &#x27;root-first&#x27;, // loadChildren: () =&gt; // import(&#x27;./app.module&#x27;).then((val) =&gt; val.RootFirstModule), // &#125;, &#123; path: &quot;root-second&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootSecondModule), &#125;, ]), ], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 这个时候我们发现，在 app.component 和 root-first 中 count 是共享的 🤓，但是 root-second 中的 count 是不与他们共享的, 这是因为 root-second 是懒加载的，而其他的则是急性加载所以他们会共享数据 null如果我们把providedIn设为 null 或者不填，那么此时，就需要在 module 中的 providers 注入这个服务，否则就会报错 😲 @Injectable(&#123; providedIn: null,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125; 此时我们在所有用到 root.service 服务的 module 中全部注入 service, 它的表现形式和 any 一样，即在每个懒加载的模块中会分别共享一个实例，而所有非懒加载的模块共享一个实例 import &#123; Component, NgModule &#125; from &quot;@angular/core&quot;;import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; RouterModule &#125; from &quot;@angular/router&quot;;import &#123; Injectable &#125; from &quot;@angular/core&quot;;@Injectable(&#123; providedIn: null,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125;// 第一个module@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt; root-first: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-second&#x27;&quot;&gt; second &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;root-first&quot;, component: RootFirstComponent, &#125;, ]), ], declarations: [RootFirstComponent], // 注入服务 providers: [RootService],&#125;)export class RootFirstModule &#123;&#125;// 第一个module@Component(&#123; selector: &quot;&quot;, template: ` &lt;div&gt; root-second: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;a [routerLink]=&quot;&#x27;/root-first&#x27;&quot;&gt; first &lt;/a&gt; &lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootSecondComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootSecondComponent, &#125;, ]), ], declarations: [RootSecondComponent], // 注入服务 providers: [RootService],&#125;)export class RootSecondModule &#123;&#125;// app component, app module@Component(&#123; selector: &quot;app-root&quot;, template: ` app header: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; `, styles: [``],&#125;)export class AppComponent &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule, RootFirstModule, // RootSecondModule, RouterModule.forRoot([ &#123; path: &quot;root-first&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootFirstModule), &#125;, &#123; path: &quot;root-second&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootSecondModule), &#125;, ]), ], // 注入服务 providers: [RootService], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; platform页面上所有应用程序共享的平台注入器的特殊单例。 创建 appMoudle2 // 第二个根模块@Component(&#123; selector: &quot;app-root2&quot;, template: ` app-root2 header: &#123;&#123; service.count &#125;&#125; &lt;button (click)=&quot;service.count = service.count + 1&quot;&gt;+&lt;/button&gt; `, styles: [``],&#125;)export class AppComponent2 &#123; constructor(public service: RootService) &#123;&#125;&#125;@NgModule(&#123; declarations: [AppComponent2], imports: [BrowserModule, RouterModule], bootstrap: [AppComponent2],&#125;)export class AppModule2 &#123;&#125; 同时在main.ts中引入 import &#123; platformBrowserDynamic &#125; from &quot;@angular/platform-browser-dynamic&quot;;import &#123; AppModule, AppModule2 &#125; from &quot;./app/app.module&quot;;platformBrowserDynamic() .bootstrapModule(AppModule) .catch((err) =&gt; console.error(err));platformBrowserDynamic() .bootstrapModule(AppModule2) .catch((err) =&gt; console.error(err)); 在index.html中引入app-root2 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;AngularService&lt;/title&gt; &lt;base href=&quot;/&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; type=&quot;image/x-icon&quot; href=&quot;favicon.ico&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;hr /&gt; &lt;app-root2&gt;&lt;/app-root2&gt; &lt;/body&gt;&lt;/html&gt; 然后我们把 root.service 的providedIn设为platform @Injectable(&#123; providedIn: &quot;platform&quot;,&#125;)export class RootService &#123; count = 0; constructor() &#123;&#125;&#125; 这时，我们发现虽然是 2 个根模块，但是数据还是共享了（没有实时刷新的原因，是因为分属不同根模块，没有触发脏检查） ngModule在这里我们新创建一个 ngModule，命名为RootChildModule, 服务的providedIn我们设置RootChildModule,并且在app.module中引入RootChildModule @NgModule()export class RootChildModule &#123;&#125;@Injectable(&#123; providedIn: RootChildModule,&#125;)export class RootService &#123; count = 0; constructor() &#123; console.log(&quot;--lucky---&quot;); &#125;&#125;@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule, RootChildModule, RouterModule.forRoot([ &#123; path: &quot;root-first&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootFirstModule), &#125;, &#123; path: &quot;root-second&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootSecondModule), &#125;, ]), ], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 此时的效果与root相同，不同之处在于，只有在 component 中引入 root.service，该服务的代码才会被打包进去，否则代码将会被摇树优化。 为了验证此功能，我们把 root.service 移出，新建/child/root.service 文件 import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; RootChildModule &#125; from &quot;./root-child.module&quot;;@Injectable(&#123; providedIn: RootChildModule,&#125;)export class RootService &#123; count = 0; constructor() &#123; console.log(&quot;--lucky---&quot;); &#125;&#125; 同时新建/child/root-child.module 来给 providedIn 提供值 import &#123; NgModule &#125; from &quot;@angular/core&quot;;@NgModule()export class RootChildModule &#123;&#125; 然后修改一下app.module的代码 import &#123; Component, NgModule &#125; from &quot;@angular/core&quot;;import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; RouterModule &#125; from &quot;@angular/router&quot;;import &#123; RootChildModule &#125; from &quot;./child/root-child.module&quot;;// 第一个模块@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt;root-first&lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor() &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RootChildModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootFirstComponent, &#125;, ]), ], declarations: [RootFirstComponent],&#125;)export class RootFirstModule &#123;&#125;// app component, app module@Component(&#123; selector: &quot;app-root&quot;, template: ` app header &lt;router-outlet&gt;&lt;/router-outlet&gt; `, styles: [``],&#125;)export class AppComponent &#123; constructor() &#123;&#125;&#125;@NgModule(&#123; declarations: [AppComponent], imports: [ BrowserModule, RouterModule, RouterModule.forRoot([ &#123; path: &quot;root-first&quot;, loadChildren: () =&gt; import(&quot;./app.module&quot;).then((val) =&gt; val.RootFirstModule), &#125;, ]), ], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 注意，此时，我们没有在任何地方注入root.service, 此时我们在浏览器 network 中搜索 root.service 中的代码 结果可知，代码没有打包进去 此时，我们在RootFirstComponent中注入root.service import &#123; RootService &#125; from &quot;./child/root.service&quot;;// 第一个模块@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt;root-first&lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor(public rootService: RootService) &#123;&#125;&#125; 此时，再去 network 中搜索，发现已有代码 我们再删除RootFirstComponent中已注入的root.service，并且把providedIn的值改为null，并且在RootFirstModule里面申明RootService import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; RootChildModule &#125; from &quot;./root-child.module&quot;;@Injectable(&#123; providedIn: null,&#125;)export class RootService &#123; count = 0; constructor() &#123; console.log(&quot;--lucky---&quot;); &#125;&#125; import &#123; RootService &#125; from &quot;./child/root.service&quot;;// 第一个模块@Component(&#123; selector: &quot;root-first&quot;, template: ` &lt;div&gt;root-first&lt;/div&gt; `, styles: [&quot;&quot;],&#125;)export class RootFirstComponent &#123; constructor() &#123;&#125;&#125;@NgModule(&#123; imports: [ RouterModule, RootChildModule, RouterModule.forChild([ &#123; path: &quot;&quot;, component: RootFirstComponent, &#125;, ]), ], providers: [RootService], declarations: [RootFirstComponent],&#125;)export class RootFirstModule &#123;&#125; 此时搜索 network, 虽然已经删除了注入部分的代码，但是 root.service 中的代码依然能搜索到 这里，我们不用providedIn：root举例的原因是，服务的 providedIn 为 root 时，不用声明，也能使用，所以自然代码也会被摇树优化掉，我想这也是 ngModule这个选项被弃用的原因。 总结实际中，我们使用比较多的只有root和null， root同时具备摇树优化的能力，但是他会在全局共享数据，并且没有限制，任意地方都可以使用 null可以根据情况，在需要的时候使用providers注入使用，并且会区分懒加载和急性加载 platform虽然有实际的应用场景，但是使用比较少，而any和ngModule都可以被any和root取代 源码angular-injectable-providedIn","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"angular form 自定义组件","date":"2024-04-10T09:31:25.000Z","path":"2024/04/10/2024-04-10-angular-custom-form/","text":"angular 表单里面需要使用 自定义组件时，想要方便的使用formGroup的formControlName，需要自定义组件的formControlName属性，如何去自定义组件的formControlName属性呢？ 引入ControlValueAccessor 接口ControlValueAccessor 接口是angular 表单组件的formControlName属性的依赖注入，ControlValueAccessor 接口需要实现registerOnChange、registerOnTouched、setDisabledState、writeValue方法，我们这里不需要用到表单的disabled属性，所以可以忽略setDisabledState 我们新建input-number组件引入NG_VALUE_ACCESSOR, 并写出对应的registerOnChange、registerOnTouched、writeValue方法 import &#123; Component, OnInit, forwardRef &#125; from &#x27;@angular/core&#x27;;import &#123; NG_VALUE_ACCESSOR &#125; from &#x27;@angular/forms&#x27;;@Component(&#123; selector: &#x27;app-input-number&#x27;, template: ` &lt;div&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;/div&gt; `, styleUrls: [&#x27;./input-number.component.css&#x27;], providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; InputNumberComponent), multi: true, &#125;, ],&#125;)export class InputNumberComponent implements OnInit &#123; /** * formControlName对应的表单值会在此传入 */ writeValue(value: any) &#123; if (value) &#123; this.count = value; &#125; &#125; /** * form表单的更新函数会在此传入，需要调用此函数更新表单的值 */ registerOnChange(fn: any) &#123;&#125; registerOnTouched(fn: any) &#123;&#125;&#125; 定义 updateValue 函数新建 updateValue函数，并且在increment、decrement、writeValue函数中调用updateValue函数，更新表单的值该组件显示数字，并且可以点击增加和减少按钮 import &#123; Component, OnInit, forwardRef &#125; from &#x27;@angular/core&#x27;;import &#123; NG_VALUE_ACCESSOR &#125; from &#x27;@angular/forms&#x27;;@Component(&#123; selector: &#x27;app-input-number&#x27;, template: ` &lt;div&gt; &lt;button (click)=&quot;decrement()&quot;&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button (click)=&quot;increment()&quot;&gt;+&lt;/button&gt; &lt;/div&gt; `, styleUrls: [&#x27;./input-number.component.css&#x27;], providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; InputNumberComponent), multi: true, &#125;, ],&#125;)export class InputNumberComponent implements OnInit &#123; /** * formControlName对应的表单值会在此传入 */ writeValue(value: any) &#123; if (value) &#123; this.count = value; this.updateValue(this.count); &#125; &#125; updateValue: (value: any) =&gt; void = (_: any) =&gt; &#123;&#125;; updateValueByTouched: (value: any) =&gt; void = (_: any) =&gt; &#123;&#125;; /** * form表单的更新函数会在此传入，需要调用此函数更新表单的值 */ registerOnChange(fn: any) &#123; this.updateValue = fn; &#125; registerOnTouched(fn: any) &#123; this.updateValueByTouched = fn; &#125; increment() &#123; this.count++; this.updateValue(this.count); &#125; decrement() &#123; this.count--; this.updateValue(this.count); &#125;&#125; 为了不在每次更新count值的时候，都去手动调用updateValue函数,我们更新一下数据结构，让其在 count 值改变时，自动调用updateValue函数 import &#123; Component, OnInit, forwardRef &#125; from &#x27;@angular/core&#x27;;import &#123; NG_VALUE_ACCESSOR &#125; from &#x27;@angular/forms&#x27;;@Component(&#123; selector: &#x27;app-input-number&#x27;, template: ` &lt;div&gt; &lt;button (click)=&quot;decrement()&quot;&gt;-&lt;/button&gt; &lt;span&gt;&#123;&#123; count &#125;&#125;&lt;/span&gt; &lt;button (click)=&quot;increment()&quot;&gt;+&lt;/button&gt; &lt;/div&gt; `, styleUrls: [&#x27;./input-number.component.css&#x27;], providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; InputNumberComponent), multi: true, &#125;, ],&#125;)export class InputNumberComponent implements OnInit &#123; _count: number = 0; get count() &#123; return this._count; &#125; set count(value: number) &#123; this._count = value; this.updateValue(this._count); &#125; constructor() &#123;&#125; ngOnInit() &#123;&#125; writeValue(value: any) &#123; if (value) &#123; this.count = value; &#125; &#125; updateValue: (value: any) =&gt; void = (_: any) =&gt; &#123;&#125;; updateValueByTouched: (value: any) =&gt; void = (_: any) =&gt; &#123;&#125;; registerOnChange(fn: any) &#123; this.updateValue = fn; &#125; registerOnTouched(fn: any) &#123; this.updateValueByTouched = fn; &#125; increment() &#123; this.count++; &#125; decrement() &#123; this.count--; &#125;&#125; 至此，我们已经写好了自定义的 form 组件 使用自定义组件响应式表单下面我们在 form 表单里引入自定义组件，试试看效果 import &#123; Component &#125; from &#x27;@angular/core&#x27;;import &#123; FormBuilder &#125; from &#x27;@angular/forms&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, template: ` &lt;div&gt; &lt;form [formGroup]=&quot;numberForm&quot;&gt; &lt;app-input-number formControlName=&quot;count&quot;&gt;&lt;/app-input-number&gt; &lt;div&gt;&#123;&#123; numberForm.get(&#x27;count&#x27;)?.value &#125;&#125;&lt;/div&gt; &lt;/form&gt; &lt;/div&gt; `, styleUrls: [&#x27;./app.component.css&#x27;],&#125;)export class AppComponent &#123; numberForm = this.fb.group(&#123; count: 5, // 设置初始值 &#125;); constructor(private fb: FormBuilder) &#123;&#125;&#125; 我们在组件下面显示出对应的 form 的表单值，可以看到，我们的自定义组件input-number已经生效了 模板驱动式表单上面的例子我们是使用 formControlName， 下面我们使用ngModel同样可以 import &#123; Component &#125; from &#x27;@angular/core&#x27;;import &#123; FormBuilder &#125; from &#x27;@angular/forms&#x27;;@Component(&#123; selector: &#x27;app-root&#x27;, template: ` &lt;div&gt; &lt;app-input-number [(ngModel)]=&quot;count&quot;&gt;&lt;/app-input-number&gt; &lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt; &lt;/div&gt; `, styleUrls: [&#x27;./app.component.css&#x27;],&#125;)export class AppComponent &#123; count = 5; constructor(private fb: FormBuilder) &#123;&#125;&#125; 源码angular-custom-form-example","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"unicode中文字节为什么有的占2个有的占3个","date":"2023-12-11T08:16:50.000Z","path":"2023/12/11/2023-12-11-unicode/","text":"本文为掘金文章转载 背景上周在评审测试用例时，有一个营销话术的接口字段，业务上要求不能超过 200 字，会上有人问，后端数据表中的这个字段，最多能存储多少个中文字符，有没有对存储字数做限制。我插入了一句，那要看数据表中这个字段定义的是什么数据类型（CHAR、VARCHAR，TEXT 等），一个中文占两个字节，用这种数据类型的字节数除以 2，就是能存储的中文字符数。然后另一个同事说，UTF-8 编码，一个中文占用 3 个字节。这句话颠覆了我之前的认知，在我的印象里，一个中文占用两个字节，怎么会是三个。我决定查一查，看看谁对谁错。 一石激起千层浪本以为搜索一下就能获得答案，可是发现这个知识点，有些渊源，一言难尽。说得太概括，人难免还是会有疑问。需要追根溯源，才能讲清楚。在查找答案的过程中，发现网上的文章良莠不齐，对于同一个知识点，不同的文章说法相互矛盾，让人思维有些凌乱，对于这种情况，我选择取这些文章的交集，摒弃矛盾与冲突。 缘起 ASCII 码字符编码的起源，是为了解决在计算机中存储与表达特定字符的问题。比如说英文字母 A, 如何表达才能让计算机能够识别。众所周知，在计算机底层只识别 0 和 1。当计算机要存储/展示字符时，需要一个规则，在字符和 0/1 序列之间建立映射关系，这就是字符编码规则。 1945 年世界第一台计算机诞生于美国，所以美国人第一个遇到字符编码问题。自然而然第一个编码规则也是美国人制定的。美国使用的是英语，英语字符数量比较少，26 个英文字母+数字+标点符号。一个字节是 8 位，如果每一个状态对应一个特定字符，每个二进制位有0和1两种取值，可以组合出 256 个字符，足够英语语境使用了。最早的字符编码标准就这样诞生了。美国人起草了计算机的第一份字符集和编码标准，叫 ASCII（American Standard Code for Information Interchange–美国信息交换标准代码），一共规定了 128 个字符及对应的二进制转换关系，128 个字符包括了可显示的 26 个字母（大小写）、10 个数字、标点符号以及特殊的控制符，也就是英语与西欧语言中常见的字符。1967 年定案，最初是美国国家标准，后来被国际标准化组织 ISO(International Organization for Standardization)定为国际标准，称为 ISO 646 标准，适用于所有拉丁文字字母。 各国衍生自己的编码计算机在世界普及之后，人们发现，在英语国家，128 个字符编码够用了，但是对于非英语国家，无法在 ASCII 字符集中找到本国的基本字符。如在法语中，字母上方有注音符号，无法用 ASCII 码表示。于是有人建议，ASCII 字符只是使用了一个字节的前 128 个，后面的 128 个完全可以利用起来，于是一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的 é 的编码为 130（二进制 10000010）。这样一来，这些欧洲国家使用的编码体系，可以最多表示 256 个符号。 但是又出现了新的问题。不同国家有不同的字母(参见下图,英语，法语属于拉丁字母体系，俄语属于斯拉夫字母体系，以色列用的是希伯来字母)，它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了 é，在希伯来语编码中却代表了字母 Gimel (ג)，在俄语编码中又代表另一个符号。128-255 之间不同的字符集导致人们无法跨机器传播交流各种信息。 至于亚洲国家的文字，使用的符号就更多了，最典型就是中文，汉字多达 10 万左右。常用汉字有 6000 个左右，用一个字节是无法表示的，所以也发展出了自己的一套编码规范： 1980 年，中国搞了自己的编码方案 GB/T 2312，一般简称 GB2312。 1993 年，国际标准化组织 ISO 制定了编码标准 ISO/IEC 10646-1:1993，国内予以承认，并编号为 GB 13000.1-1993。 1995 年，国内基于 GB2312 扩展了一套编码方案 GBK（汉字内码扩展规范），并收录了 GB13000.1 和 Big5（由台湾资讯工业策进会在 1984 年制定）中的汉字，微软在 Windows 95、Windows NT 3.51 中进行了实现，称为 Code Page 936。 2000 年，制定了国标 GB 18030-2000，目前已作废。 2005 年，制定了国标 GB 18030-2005，为现行的 GB18030 标准。 2022 年，制定了国标 GB 18030-2022，2023 年 8 月 1 日生效。 前面只介绍了西方国家和中文的编码，放眼全世界，有许多种语言文字，如果各自都搞一套就乱成一锅粥了。如果有一种编码，将世界上所有的符号都纳入其中。给每一个符号赋予一个独一无二的编码，那么相同的二进制值在世界不同国家编码中代表不同的字符乱局就会消失。 Unicode 码统一乱局Unicode 码将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。第一版 发布于 1991 年 ，目前已发展到第 15 版。Unicode 字符集的编码范围是 0x0000 - 0x10FFFF , Unicode 的编码空间从U+0000到U+10FFFF，共有 1,112,064 个码位（code point）可用来映射字符，可以容纳一百多万个字符， 每个字符都有一个独一无二的编码，也即每个字符都有一个二进制数值和它对应，这里的二进制数值也叫 码点 , 比如：汉字 “汉” 的 码点是 0x6C49, 大写字母 A 的码点是 0x41, 具体字符对应的 Unicode 编码可以查询 Unicode 字符编码表。 Unicode 推行过程中遇到的问题Unicode 为每个字符规定了唯一的二进制代码，却没有规定这个二进制代码应该如何存储。例如，汉字的”汉” Unicode 编码是十六进制数 0x6C49，表示这个符号需要 2 个字节。依此类推，表示其它在 Unicode 编码中排序更靠后的符号，需要 3 个或 4 个字节。 这就出现两个问题： 怎样区别 Unicode 和 ASCII 码？计算机无法知道三个字节是表示一个字符的 Unicode 码，还是分别表示三个字符的 ASCII 码。 英文字母只用一个字节表示就够了，如果按照 Unicode 编码，每个符号用三个或四个字节表示，英文文本文件的体积因此大出二三倍，这对存储来说是很大的浪费。 它们造成的结果是： Unicode 在很长一段时间内无法推广，由于 ASCII 字符经过 UTF-16 编码后得到的两个字节，高字节始终是 0×00，很多 C 语言的函数都将此字节视为字符串末尾从而导致无法正确解析文本。因此 UTF-16 刚推出的时候遭到很多西方国家的抵触，大大影响了 Unicode 的推行。 为了平衡 Unicode 浪费存储空间和表达更多字符的问题，出现了多种不同的 Unicode 编码存储格式。 UTF-8 问世伴随着互联网的普及，强烈需要一种统一的 Unicode 的编码方案, 尤其是跨国商务办公场景。UTF-8 是目前互联网上使用最广的一种 Unicode 的编码实现方式。Unicode 的其它实现方式还有 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），在浏览器上很少用，在本地文件中用的较多。 UTF-8 最大的特点，就是它是一种“变长”编码方式。它可以使用 1 到 4 个字节表示一个符号，根据不同的符号而变化字节长度。UTF-8 编码规则是： 对于单字节的符号，字节的第一位设为 0，后面 7 位为这个符号的 Unicode 码。因此对于英文字母，UTF-8 和 ASCII 编码是相同的； 对于 n 字节的符号（n&gt;1），第一个字节的前 n 位都设为 1，第 n+1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码；下表总结了编码规则，字母 x 表示可用编码的位： UTF-8 编码方式 Unicode 符号范围(十六进制) 二进制表示 000000-00007F (0-127) 0xxxxxxx 000080-0007FF (128-2047) 110xxxxx 10xxxxxx 000800-00FFFF (2048-65535) 1110xxxx 10xxxxxx 10xxxxxx 010000-10FFFF (65536 以上) 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 基于 UTF-8 编码规则，解读 UTF-8 编码就非常简单。如果一个字节的第一位是 0，则这个字节单独就是一个字符；如果第一位是 1，则连续有多少个 1，就表示当前字符占用多少个字节。 还是以汉字的汉为例，演示如何实现 UTF-8 编码： 汉的 Unicode 码是 U+6C49（十进制表示为 27721，二进制表示为 110 1100 0100 1001），根据上表，可以发现 6C49 处在第三行的范围内（0000 0800 - 0000 FFFF），因此汉的 UTF-8 编码需要三个字节，即格式是 1110xxxx 10xxxxxx 10xxxxxx。然后，从汉的最后一个二进制位开始，依次从后向前填入格式中的 x，多出的位补 0。这样就得到了，汉的 UTF-8 编码是 11100110 10110001 10001001，转换成十六进制就是 0xE6B789。 UTF-8 BOM 概念解析如下图所示，使用 NodePad++保存文件，选择编码方式时，会看到一个 UTF-8 BOM 的选项，这个选项是什么含义？ BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。Byte Order Mark(BOM)，即字节顺序标记，通常叫做大小端。位于文件开始的地方。用于标记高位在前，还是低位在前。即文件开头有没有 U+FEFF。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。BOM 不受欢迎主要是在 UNIX 环境下，因为 BOM 本身违反了一个 UNIX 设计的常见原则，就是文档中存在的数据必须可见。BOM 不能作为可见字符被文本编辑器编辑，就这一条很多 UNIX 开发者就不满意。因为很多 UNIX 程序不鸟 BOM。主要问题出在 UNIX 那个所有脚本语言通行的首行#!标示，这东西依赖于 shell 解析，而很多 shell 出于兼容的考虑不检测 BOM，所以加进 BOM 时 shell 会把它解释为某个普通字符输入导致破坏#!标示，这就会造成错误。所以不含 BOM 的 UTF-8 才是标准形式，在 UTF-8 文件中放置 BOM 主要是微软的习惯。BOM 解读规则如下: 相对复杂的 UTF-16 编码平面的概念 在了解 UTF-16 之前，我们先看一下平面的概念。Unicode 编码中有很多字符，并不是一次性定义的，而是分区进行定义的。每个区存放 65536 个字符，这称为一个平面，目前共有 17 个平面。第一个平面称为基本平面，它的码点从 0-65535，写成 16 进制就是 U+0000 一 U+FFFF，那剩下的 16 个平面就是辅助平面(除了第二个和第三个平面，其它的都没有广泛使用，参见此文的平面讲解)，码点范围是 U+10000–U+10FFFF。UTF-16 把 Unicode 字符集的抽象码位映射为 16 位长的整数进行数据存储。 Unicode 字符的码位需要 1 个或者 2 个 16 位长的码元来表示，因此 UTF-16 也是变长字节。 UTF-16 编码规则: 编号在 U+0000-U+FFFF 的字符(常用字符集)，直接用两个字节表示 编号在 U+10000-U+10FFFF 之间的字符，需要用四个字节表示 通过上表，可以发现，UTF-16 用二个字节来表示基本平面，用四个字节来表示扩展平面。 编码识别 当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢? 在基本平面内，从 U+D800-U+DFFF 是个空段，这个区间的码点不对应任何字符，这些空段被用来映射辅助平面的字符。110110xx xxxxxxxx（0xd800 - 0xdbff）为高位代理（High Surrogate），110111xx xxxxxxxx（0xdc00 - 0xdfff） 为低位代理(Low Surrogate)。它的作用是告诉计算机，只要碰着了这个区间的数值，就知道扩展平面的字符来了,要把连续两个双字节当做一个字符解码。 一个高位代理和一个低位代理可以组成一个代理对（Surrogate Pair）。如果 y 和 x 全为 0，则为 0x010000 的代码点，全为 1 则为 0x10ffff 的代码点，刚好能把所有扩展平面全部编码。 如果代码点位于 0x000000 - 0x00ffff，直接进行二进制编码，位数不够的左边充 0。 如果代码点位于 0x010000 - 0x10ffff，则： 代码点减去 0x10000，会得到一个位于 0x000000 和 0x0fffff 之间的数字。 这个数字转换为 20 位二进制数，位数不够的，左边充 0，记作：yyyy yyyy yyxx xxxx xxxx。 取出 yy yyyyyyyy，并加上 11011000 00000000(0xD800)，得到高位代理。 取出 xx xxxxxxxx，并加上 11011100 00000000(0xDC00)，得到低位代理。 高位代理和低位代理相连，得到 110110yy yyyyyyyy 110111xx xxxxxxxx。 举例说明 以“嫦”字为例，它的 Unicode 码点为 0x21800 ，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下: 首先计算超出部分的结果: 0x21800 - 0x10000 将上面的计算结果转为 20 位的二进制数，不足 20 位就在前面补 0，结果为: 0001 0001 1000 0000 0000 将得到的两个 10 位二进制数分别对应到两个区间中 取出 0001000110 并加上 11011000 00000000(0xD800)，得到高位代理 1101100001000110 ，转成 16 进制数为 0xD846 。同理计算低位代理为 0xDC00，所以这个字的 UTF-16 编码为 0xD846 0xDC00 最好理解的 UTF-32UTF-32 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。比如“马”字的 Unicode 编号是 U+9A6C ，整数编号是 39532 ，直接转化为二进制: 1001 1010 0110 1100 ，这就是它的 UTF-32 编码。 为什么 UTF-8 不需要字节序,UTF-16,UTF-32 需要字节序？虽然 UTF-8 是变长编码，但是以单字节为编码单元，不存在谁在高低位的问题，由于 UTF-8 的首字节记录了总字节数（比如 3 个），所以读取首字节后，再读取后续字节（2 个），然后进行解码，得到完整的字节数，从而能保证解码也是正确的。 UTF-16 是变长编码，使用 1 个 16-bit 编码单元或者 2 个 16-bit 编码单元，UTF32 是定长编码，使用 2 个 16-bit 编码单元，由于硬件 CPU 的不同，对于一个由 2 个字节组成的 16 位整数，在内存中存储这两个字节有两种方法：一种是将低序字节存储在起始地址，这称为小端(little-endian)字节序；另一种方法是将高序字节存储在起始地址，这称为大端(big-endian)字节序。假如 CPU 是大端序那么高位在前，如果 CPU 是小端序那么低位在前，为了区分，所以有了 BOM（byte order mark），然后计算机才能知道谁是高位，谁是低位，知道了高低位，从而能正确组装，然后才能解码正确。 Unicode、UTF-8、UTF-16、UTF-32 区别? Unicode 是编码字符集 (字符集) ，而 UTF-8 、UTF-16 、UTF-32 是字符集编码 UTF-16 使用变码元序列的编码方式，相较于定长码元序列的 UTF-32 算法更复杂，甚至比同样是变长码元序列的 UTF-8 也更为复杂 UTF-8 需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而 UTF-16 不会判断开头标志，即使错也只会错一个字符，所以容错能力较强 如果字符内容全部英文或英文与其它文字混合，但英文占绝大部分，那么用 UTF-8 就比 UTF-16 节省了很多空间; 而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么 UTF-16 就占优势了，可以节省很多空间。 乱码问题分析所谓“乱码”是指应用程序显示出来的字符文本无法用任何语言去解读，通常会包含大量 ? 或 �，造成乱码的根本原因就是因为使用了错误的字符编码去解码字节流，想要解决乱码问题，就先要搞清楚应用程序当前使用的字符编码是什么。 比如最常见的网页乱码问题。需要从以下三个方面查找原因： 网页文件本身存储时使用的字符编码和网页声明的字符编码是否一致 &lt;meta charset=&quot;utf-8&quot; /&gt; 服务器返回的响应头 Content-Type 有没有指明字符编码 网页内是否使用 META HTTP-EQUIV 标签指定了字符编码 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; MySQL 中一个中文占用几个字节varchar(n)能存储几个汉字？varchar(n)表示 n 个字符，一个汉字也被视为一个字符，无论汉字和英文，MySQL 都能存入 n 个字符，区别是实际占用字节长度不同 一个中文汉字占多少字节与编码有关 UTF8：一个中文汉字＝ 3 个字节 (常用汉字是汉字总数中占比较小，常用汉字每个占用 3 个字节，多数不太常用的汉字每个占用 4 个字节)。 GBK：一个中文汉字＝ 2 个字节 Unicode 简体中文字符集范围Unicode 简体中文字符集的范围是U+4E00 到 U+9FFF，共包括 20992 个字符。 其中： U+4E00 到 U+62FF 是常用汉字区 U+6300 到 U+77FF 是次常用汉字区 U+7800 到 U+8CFF 是非常用汉字区 U+8D00 到 U+9FFF 是未分类汉字区 除了汉字，这个字符范围还包括了汉语拼音、注音符号、部分汉语方言文字和一些符号等。所以一个简体中文汉字的 Unicode 编码值是用 2 位 16 进制数表示，占用 2 个字节。 转载我说一个中文占 2 个字节，同事说 UTF-8 编码中，一个中文占 3 个字节，到底谁对谁错？","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"unicode","slug":"unicode","permalink":"https://luckyship.github.io/tags/unicode/"}]},{"title":"window.print 自定义页眉页脚","date":"2023-11-28T00:47:07.000Z","path":"2023/11/28/2023-11-28-window-print/","text":"&lt;style&gt; .header, .header-space, .footer, .footer-space &#123; height: 100px; &#125; .header &#123; position: fixed; top: 0; &#125; .footer &#123; position: fixed; bottom: 0; &#125;&lt;/style&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;header-space&quot;&gt;&amp;nbsp;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;content&quot;&gt;...&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;footer-space&quot;&gt;&amp;nbsp;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;div class=&quot;header&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;...&lt;/div&gt; 方法一：position fixed&lt;style&gt; .header &#123; position: fixed; top: 0; &#125; .footer &#123; position: fixed; bottom: 0; &#125;&lt;/style&gt;&lt;div class=&quot;header&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;content&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;...&lt;/div&gt;// CSS 这个方法超过一页后，页眉页脚会与内容重叠 方法二：table&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;td&gt; &lt;div class=&quot;header&quot;&gt;...&lt;/div&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt; &lt;div class=&quot;content&quot;&gt;...&lt;/div&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt;&lt;td&gt; &lt;div class=&quot;footer&quot;&gt;...&lt;/div&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; 利用表格 table，打印会自动把 thead,tfoot 设置为页眉页脚，不过这个方法页脚会跟在内容后面，不会在页面底部 总结：两种方法结合，可以很好的实现&lt;style&gt; .header, .header-space, .footer, .footer-space &#123; height: 100px; &#125; .header &#123; position: fixed; top: 0; &#125; .footer &#123; position: fixed; bottom: 0; &#125;&lt;/style&gt;&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;header-space&quot;&gt;&amp;nbsp;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;content&quot;&gt;...&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td&gt; &lt;div class=&quot;footer-space&quot;&gt;&amp;nbsp;&lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt;&lt;div class=&quot;header&quot;&gt;...&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;...&lt;/div&gt; 参考资料","updated":"2025-08-02T05:46:04.182Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"flutter抓包、查看网络请求","date":"2023-10-26T05:56:36.000Z","path":"2023/10/26/2023-10-26-flutter-network/","text":"由于 flutter 的 http 请求代理不走系统，所以只能在代码中设置代理 ip, 使我们的抓包工具能获取到 http 的请求 flutter 使用 Charles 代理爬虫class MyHttpOverrides extends HttpOverrides &#123; bool _badCertificateCallback(X509Certificate cert, String host, int port) &#123; return true; &#125; @override HttpClient createHttpClient(SecurityContext? context) &#123; return super.createHttpClient(context) ..badCertificateCallback = _badCertificateCallback ..findProxy = (uri) &#123; return &#x27;PROXY 192.168.1.193:8888;DIRECT;&#x27;;//192.168.1.193:8888是代理ip端口 &#125; ; &#125;&#125; 在启动时设置 httpoverride HttpOverrides.global = MyHttpOverrides(); 修改 Charles 的 ssl 代理设置，Proxy-&gt;SSL Proxying Settings -&gt; SSL Proxying-&gt;Include,添加要需要爬取的域名。 有时我们需要抓 https 的请求，此时用 charles 抓包的内容是加密的，看不到明文，这时候需要安装下 Charles 的证书来解决。点击 help &gt; SSL Proxying &gt; Install Charles Root Certificate，安装到系统的钥匙串中。","updated":"2025-08-02T05:46:04.181Z","tags":[{"name":"flutter","slug":"flutter","permalink":"https://luckyship.github.io/tags/flutter/"}]},{"title":"flutter安装包切换国内源","date":"2023-09-23T03:43:19.000Z","path":"2023/09/23/2023-09-23-flutter-source-pub/","text":"在学习Flutter，发现无法安装，控制台提示 Got TLS error trying to find package flutter_inappwebview at https://pub.dev. 经过网上查找资料，发现： 如果在中国安装 flutter，配置国内镜像是很好的解决办法。 到此，解决方法找到。 配置本地环境方法 对于 Linux 和 MacOS 来说，添加如下两条环境变量即可： export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 对于 Window 创建上述两个系统变量即可 name: PUB_HOSTED_URL;value: https://pub.flutter-io.cnname: FLUTTER_STORAGE_BASE_URL;value: https://storage.flutter-io.cn","updated":"2025-08-02T05:46:04.181Z","tags":[{"name":"flutter","slug":"flutter","permalink":"https://luckyship.github.io/tags/flutter/"}]},{"title":"nodejs操作excel文件","date":"2023-07-02T02:08:48.000Z","path":"2023/07/02/2023-07-02-node-excel/","text":"ExcelJS读取，操作并写入电子表格数据和样式到 XLSX 和 JSON 文件。 一个 Excel 电子表格文件逆向工程项目。 安装npm install exceljs 导入⬆const ExcelJS = require(&#x27;exceljs&#x27;); ES5 导入⬆要使用 ES5 编译代码，请使用 dist/es5 路径。 const ExcelJS = require(&#x27;exceljs/dist/es5&#x27;); 注意：ES5 版本对许多 polyfill 都具有隐式依赖，而 exceljs 不再明确添加。您需要在依赖项中添加 core-js 和 regenerator-runtime，并在导入 exceljs 之前在代码中包含以下引用： // exceljs 所需的 polyfillsrequire(&#x27;core-js/modules/es.promise&#x27;);require(&#x27;core-js/modules/es.string.includes&#x27;);require(&#x27;core-js/modules/es.object.assign&#x27;);require(&#x27;core-js/modules/es.object.keys&#x27;);require(&#x27;core-js/modules/es.symbol&#x27;);require(&#x27;core-js/modules/es.symbol.async-iterator&#x27;);require(&#x27;regenerator-runtime/runtime&#x27;);const ExcelJS = require(&#x27;exceljs/dist/es5&#x27;); 对于 IE 11，您还需要一个 polyfill 以支持 unicode regex 模式。 例如， const rewritePattern = require(&#x27;regexpu-core&#x27;);const &#123; generateRegexpuOptions,&#125; = require(&#x27;@babel/helper-create-regexp-features-plugin/lib/util&#x27;);const &#123; RegExp &#125; = global;try &#123; new RegExp(&#x27;a&#x27;, &#x27;u&#x27;);&#125; catch (err) &#123; global.RegExp = function (pattern, flags) &#123; if (flags &amp;&amp; flags.includes(&#x27;u&#x27;)) &#123; return new RegExp( rewritePattern( pattern, flags, generateRegexpuOptions(&#123; flags, pattern &#125;) ) ); &#125; return new RegExp(pattern, flags); &#125;; global.RegExp.prototype = RegExp.prototype;&#125; 浏览器端⬆ExcelJS 在 dist/ 文件夹内发布了两个支持浏览器的包： 一个是隐式依赖 core-js polyfills 的… &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-polyfill/6.26.0/polyfill.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;exceljs.js&quot;&gt;&lt;/script&gt; 另一个则没有… &lt;script src=&quot;--your-project&#x27;s-pollyfills-here--&quot;&gt;&lt;/script&gt;&lt;script src=&quot;exceljs.bare.js&quot;&gt;&lt;/script&gt; 接口⬆创建工作簿⬆const workbook = new ExcelJS.Workbook(); 设置工作簿属性⬆workbook.creator = &#x27;Me&#x27;;workbook.lastModifiedBy = &#x27;Her&#x27;;workbook.created = new Date(1985, 8, 30);workbook.modified = new Date();workbook.lastPrinted = new Date(2016, 9, 27); // 将工作簿日期设置为 1904 年日期系统workbook.properties.date1904 = true; 设置计算属性⬆// 在加载时强制工作簿计算属性workbook.calcProperties.fullCalcOnLoad = true; 工作簿视图⬆工作簿视图控制在查看工作簿时 Excel 将打开多少个单独的窗口。 workbook.views = [ &#123; x: 0, y: 0, width: 10000, height: 20000, firstSheet: 0, activeTab: 1, visibility: &#x27;visible&#x27;, &#125;,]; 添加工作表⬆const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;); 使用 addWorksheet 函数的第二个参数来指定工作表的选项。 示例： // 创建带有红色标签颜色的工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; properties: &#123; tabColor: &#123; argb: &#x27;FFC0000&#x27; &#125; &#125;,&#125;);// 创建一个隐藏了网格线的工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; views: [&#123; showGridLines: false &#125;],&#125;);// 创建一个第一行和列冻结的工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; views: [&#123; xSplit: 1, ySplit: 1 &#125;],&#125;);// 使用A4设置的页面设置设置创建新工作表 - 横向const worksheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; pageSetup: &#123; paperSize: 9, orientation: &#x27;landscape&#x27; &#125;,&#125;);// 创建一个具有页眉页脚的工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; headerFooter: &#123; firstHeader: &#x27;Hello Exceljs&#x27;, firstFooter: &#x27;Hello World&#x27; &#125;,&#125;);// 创建一个冻结了第一行和第一列的工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; views: [&#123; state: &#x27;frozen&#x27;, xSplit: 1, ySplit: 1 &#125;],&#125;); 删除工作表⬆使用工作表的 id 从工作簿中删除工作表。 示例： // 创建工作表const sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;);// 使用工作表 id 删除工作表workbook.removeWorksheet(sheet.id); 访问工作表⬆// 遍历所有工作表// 注意： workbook.worksheets.forEach 仍然是可以正常运行的， 但是以下的方式更好workbook.eachSheet(function (worksheet, sheetId) &#123; // ...&#125;);// 按 name 提取工作表const worksheet = workbook.getWorksheet(&#x27;My Sheet&#x27;);// 按 id 提取工作表const worksheet = workbook.getWorksheet(1); 工作表状态⬆// 使工作表可见worksheet.state = &#x27;visible&#x27;;// 隐藏工作表worksheet.state = &#x27;hidden&#x27;;// 从“隐藏/取消隐藏”对话框中隐藏工作表worksheet.state = &#x27;veryHidden&#x27;; 工作表属性⬆工作表支持属性存储，以允许控制工作表的某些功能。 // 创建具有属性的新工作表const worksheet = workbook.addWorksheet(&#x27;sheet&#x27;, &#123; properties: &#123; tabColor: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;,&#125;);// 创建一个具有属性的可写的新工作表const worksheetWriter = workbookWriter.addWorksheet(&#x27;sheet&#x27;, &#123; properties: &#123; outlineLevelCol: 1 &#125;,&#125;);// 之后调整属性（工作表读写器不支持该操作）worksheet.properties.outlineLevelCol = 2;worksheet.properties.defaultRowHeight = 15; 支持的属性 属性名 默认值 描述 tabColor undefined 标签的颜色 outlineLevelCol 0 工作表列大纲级别 outlineLevelRow 0 工作表行大纲级别 defaultRowHeight 15 默认行高 defaultColWidth (optional) 默认列宽 dyDescent 55 TBD 工作表尺寸⬆一些新的尺寸属性已添加到工作表中… 属性名 描述 rowCount 文档的总行数。 等于具有值的最后一行的行号。 actualRowCount 具有值的行数的计数。 如果中间文档行为空，则该行将不包括在计数中。 columnCount 文档的总列数。 等于所有行的最大单元数。 actualColumnCount 具有值的列数的计数。 页面设置⬆所有可能影响工作表打印的属性都保存在工作表上的 pageSetup 对象中。 // 使用 A4 横向的页面设置创建新工作表const worksheet = workbook.addWorksheet(&#x27;sheet&#x27;, &#123; pageSetup: &#123; paperSize: 9, orientation: &#x27;landscape&#x27; &#125;,&#125;);// 使用适合页面的pageSetup设置创建一个新的工作表编写器const worksheetWriter = workbookWriter.addWorksheet(&#x27;sheet&#x27;, &#123; pageSetup: &#123; fitToPage: true, fitToHeight: 5, fitToWidth: 7 &#125;,&#125;);// 之后调整页面设置配置worksheet.pageSetup.margins = &#123; left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3,&#125;;// 设置工作表的打印区域worksheet.pageSetup.printArea = &#x27;A1:G20&#x27;;// 通过使用 `&amp;&amp;` 分隔打印区域来设置多个打印区域worksheet.pageSetup.printArea = &#x27;A1:G10&amp;&amp;A11:G20&#x27;;// 在每个打印页面上重复特定的行worksheet.pageSetup.printTitlesRow = &#x27;1:3&#x27;;// 在每个打印页面上重复特定列worksheet.pageSetup.printTitlesColumn = &#x27;A:C&#x27;; 支持的页面设置配置项 属性名 默认值 描述 margins 页面上的空白边距。 单位为英寸。 orientation &#39;portrait&#39; 页面方向 - 即较高 (&#39;portrait&#39;) 或者较宽 (&#39;landscape&#39;) horizontalDpi 4294967295 水平方向上的 DPI。默认值为 -1 verticalDpi 4294967295 垂直方向上的 DPI。默认值为 -1 fitToPage 是否使用 fitToWidth 和 fitToHeight 或 scale 设置。默认基于存在于 pageSetup 对象中的设置-如果两者都存在，则 scale 优先级高（默认值为 false）。 pageOrder &#39;downThenOver&#39; 打印页面的顺序-[&#39;downThenOver&#39;, &#39;overThenDown&#39;] 之一 blackAndWhite false 无色打印 draft false 打印质量较低（墨水） cellComments &#39;None&#39; 在何处放置批注-[&#39;atEnd&#39;，&#39;asDisplayed&#39;，&#39;None&#39;]中的一个 errors &#39;displayed&#39; 哪里显示错误 -[&#39;dash&#39;, &#39;blank&#39;, &#39;NA&#39;, &#39;displayed&#39;] 之一 scale 100 增加或减小打印尺寸的百分比值。 当 fitToPage 为 false 时激活 fitToWidth 1 纸张应打印多少页宽。 当 fitToPage 为 true 时激活 fitToHeight 1 纸张应打印多少页高。 当 fitToPage 为 true 时激活 paperSize 使用哪种纸张尺寸（见下文） showRowColHeaders false 是否显示行号和列字母 showGridLines false 是否显示网格线 firstPageNumber 第一页使用哪个页码 horizontalCentered false 是否将工作表数据水平居中 verticalCentered false 是否将工作表数据垂直居中 示例纸张尺寸 属性名 值 Letter undefined Legal 5 Executive 7 A3 8 A4 9 A5 11 B5 (JIS) 13 Envelope #10 20 Envelope DL 27 Envelope C5 28 Envelope B5 34 Envelope Monarch 37 Double Japan Postcard Rotated 82 16K 197x273 mm 119 页眉和页脚⬆这是添加页眉和页脚的方法。添加的内容主要是文本，例如时间，简介，文件信息等，您可以设置文本的样式。此外，您可以为首页和偶数页设置不同的文本。 注意：目前不支持图片。 // 创建一个带有页眉和页脚的工作表var sheet = workbook.addWorksheet(&#x27;My Sheet&#x27;, &#123; headerFooter: &#123; firstHeader: &#x27;Hello Exceljs&#x27;, firstFooter: &#x27;Hello World&#x27; &#125;,&#125;);// 创建一个带有页眉和页脚可写的工作表var worksheetWriter = workbookWriter.addWorksheet(&#x27;sheet&#x27;, &#123; headerFooter: &#123; firstHeader: &#x27;Hello Exceljs&#x27;, firstFooter: &#x27;Hello World&#x27; &#125;,&#125;);// 代码中出现的&amp;开头字符对应变量，相关信息可查阅下文的变量表// 设置页脚(默认居中),结果：“第 2 页，共 16 页”worksheet.headerFooter.oddFooter = &#x27;第 &amp;P 页，共 &amp;N 页&#x27;;// 将页脚（默认居中）设置为粗体，结果是：“第2页，共16页”worksheet.headerFooter.oddFooter = &#x27;Page &amp;P of &amp;N&#x27;;// 将左页脚设置为 18px 并以斜体显示。 结果：“第2页，共16页”worksheet.headerFooter.oddFooter = &#x27;&amp;LPage &amp;P of &amp;N&#x27;;// 将中间标题设置为灰色Aril，结果为：“ 52 exceljs”worksheet.headerFooter.oddHeader = &#x27;&amp;C&amp;KCCCCCC&amp;&quot;Aril&quot;52 exceljs&#x27;;// 设置页脚的左，中和右文本。 结果：页脚左侧为“ Exceljs”。 页脚中心的“ demo.xlsx”。 页脚右侧的“第2页”worksheet.headerFooter.oddFooter = &#x27;&amp;Lexceljs&amp;C&amp;F&amp;RPage &amp;P&#x27;;// 在首页添加不同的页眉和页脚worksheet.headerFooter.differentFirst = true;worksheet.headerFooter.firstHeader = &#x27;Hello Exceljs&#x27;;worksheet.headerFooter.firstFooter = &#x27;Hello World&#x27;; 支持的 headerFooter 设置 属性名 默认值 描述 differentFirst false 将 differentFirst 的值设置为 true，这表示第一页的页眉/页脚与其他页不同 differentOddEven false 将 differentOddEven 的值设置为 true，表示奇数页和偶数页的页眉/页脚不同 oddHeader null 设置奇数（默认）页面的标题字符串，可以设置格式化字符串 oddFooter null 设置奇数（默认）页面的页脚字符串，可以设置格式化字符串 evenHeader null 设置偶数页的标题字符串，可以设置格式化字符串 evenFooter null 为偶数页设置页脚字符串，可以设置格式化字符串 firstHeader null 设置首页的标题字符串，可以设置格式化字符串 firstFooter null 设置首页的页脚字符串，可以设置格式化字符串 脚本命令 命令 描述 &amp;L 将位置设定在左侧 &amp;C 将位置设置在中心 &amp;R 将位置设定在右边 &amp;P 当前页码 &amp;N 总页数 &amp;D 当前日期 &amp;T 当前时间 &amp;G 照片 &amp;A 工作表名称 &amp;F 文件名称 &amp;B 加粗文本 &amp;I 斜体文本 &amp;U 文本下划线 &amp;”font name” 字体名称，例如＆“ Aril” &amp;font size 字体大小，例如 12 &amp;KHEXCode 字体颜色，例如 &amp;KCCCCCC 工作表视图⬆现在，工作表支持视图列表，这些视图控制 Excel 如何显示工作表： frozen - 顶部和左侧的许多行和列被冻结在适当的位置。 仅右下部分会滚动 split - 该视图分为 4 个部分，每个部分可半独立滚动。 每个视图还支持各种属性： 属性名 默认值 描述 state &#39;normal&#39; 控制视图状态 - &#39;normal&#39;, &#39;frozen&#39; 或者 &#39;split&#39; 之一 rightToLeft false 将工作表视图的方向设置为从右到左 activeCell undefined 当前选择的单元格 showRuler true 在页面布局中显示或隐藏标尺 showRowColHeaders true 显示或隐藏行标题和列标题（例如，顶部的 A1，B1 和左侧的 1,2,3） showGridLines true 显示或隐藏网格线（针对未定义边框的单元格显示） zoomScale 100 用于视图的缩放比例 zoomScaleNormal 100 正常缩放视图 style undefined 演示样式- pageBreakPreview 或 pageLayout 之一。 注意：页面布局与 frozen 视图不兼容 冻结视图⬆冻结视图支持以下额外属性： 属性名 默认值 描述 xSplit 0 冻结多少列。要仅冻结行，请将其设置为 0 或 undefined ySplit 0 冻结多少行。要仅冻结列，请将其设置为 0 或 undefined topLeftCell special 哪个单元格将在右下窗格中的左上角。注意：不能是冻结单元格。默认为第一个未冻结的单元格 worksheet.views = [ &#123; state: &#x27;frozen&#x27;, xSplit: 2, ySplit: 3, topLeftCell: &#x27;G10&#x27;, activeCell: &#x27;A1&#x27;, &#125;,]; 拆分视图⬆拆分视图支持以下额外属性： 属性名 默认值 描述 xSplit 0 从左侧多少个点起，以放置拆分器。要垂直拆分，请将其设置为 0 或 undefined ySplit 0 从顶部多少个点起，放置拆分器。要水平拆分，请将其设置为 0 或 undefined topLeftCell undefined 哪个单元格将在右下窗格中的左上角。 activePane undefined 哪个窗格将处于活动状态-topLeft，topRight，bottomLeft 和 bottomRight 中的一个 worksheet.views = [ &#123; state: &#x27;split&#x27;, xSplit: 2000, ySplit: 3000, topLeftCell: &#x27;G10&#x27;, activeCell: &#x27;A1&#x27;, &#125;,]; 自动筛选器⬆可以对工作表应用自动筛选器。 worksheet.autoFilter = &#x27;A1:C1&#x27;; 尽管范围字符串是 autoFilter 的标准形式，但工作表还将支持以下值： // 将自动筛选器设置为从 A1 到 C1worksheet.autoFilter = &#123; from: &#x27;A1&#x27;, to: &#x27;C1&#x27;,&#125;;// 将自动筛选器设置为从第3行第1列的单元格到第5行第12列的单元格worksheet.autoFilter = &#123; from: &#123; row: 3, column: 1, &#125;, to: &#123; row: 5, column: 12, &#125;,&#125;;// 将自动筛选器设置为从D3到第7行第5列中的单元格worksheet.autoFilter = &#123; from: &#x27;D3&#x27;, to: &#123; row: 7, column: 5, &#125;,&#125;; 列⬆// 添加列标题并定义列键和宽度// 注意：这些列结构仅是构建工作簿的方便之处，除了列宽之外，它们不会完全保留。worksheet.columns = [ &#123; header: &#x27;Id&#x27;, key: &#x27;id&#x27;, width: 10 &#125;, &#123; header: &#x27;Name&#x27;, key: &#x27;name&#x27;, width: 32 &#125;, &#123; header: &#x27;D.O.B.&#x27;, key: &#x27;DOB&#x27;, width: 10, outlineLevel: 1 &#125;,];// 通过键，字母和基于1的列号访问单个列const idCol = worksheet.getColumn(&#x27;id&#x27;);const nameCol = worksheet.getColumn(&#x27;B&#x27;);const dobCol = worksheet.getColumn(3);// 设置列属性// 注意：将覆盖 C1 单元格值dobCol.header = &#x27;Date of Birth&#x27;;// 注意：这将覆盖 C1:C2 单元格值dobCol.header = [&#x27;Date of Birth&#x27;, &#x27;A.K.A. D.O.B.&#x27;];// 从现在开始，此列将以 “dob” 而不是 “DOB” 建立索引dobCol.key = &#x27;dob&#x27;;dobCol.width = 15;// 如果需要，隐藏列dobCol.hidden = true;// 为列设置大纲级别worksheet.getColumn(4).outlineLevel = 0;worksheet.getColumn(5).outlineLevel = 1;// 列支持一个只读字段，以指示基于 `OutlineLevel` 的折叠状态expect(worksheet.getColumn(4).collapsed).to.equal(false);expect(worksheet.getColumn(5).collapsed).to.equal(true);// 遍历此列中的所有当前单元格dobCol.eachCell(function (cell, rowNumber) &#123; // ...&#125;);// 遍历此列中的所有当前单元格，包括空单元格dobCol.eachCell(&#123; includeEmpty: true &#125;, function (cell, rowNumber) &#123; // ...&#125;);// 添加一列新值worksheet.getColumn(6).values = [1, 2, 3, 4, 5];// 添加稀疏列值worksheet.getColumn(7).values = [, , 2, 3, , 5, , 7, , , , 11];// 剪切一列或多列（右边的列向左移动）// 如果定义了列属性，则会相应地对其进行切割或移动// 已知问题：如果拼接导致任何合并的单元格移动，结果可能是不可预测的worksheet.spliceColumns(3, 2);// 删除一列，再插入两列。// 注意：第4列及以上的列将右移1列。// 另外：如果工作表中的行数多于列插入项中的值，则行将仍然被插入，就好像值存在一样。const newCol3Values = [1, 2, 3, 4, 5];const newCol4Values = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;];worksheet.spliceColumns(3, 1, newCol3Values, newCol4Values); 行⬆// 获取一个行对象。如果尚不存在，则将返回一个新的空对象const row = worksheet.getRow(5);// Get multiple row objects. If it doesn&#x27;t already exist, new empty ones will be returnedconst rows = worksheet.getRows(5, 2); // start, length (&gt;0, else undefined is returned)// 获取工作表中的最后一个可编辑行（如果没有，则为 `undefined`）const row = worksheet.lastRow;// 设置特定的行高row.height = 42.5;// 隐藏行row.hidden = true;// 为行设置大纲级别worksheet.getRow(4).outlineLevel = 0;worksheet.getRow(5).outlineLevel = 1;// 行支持一个只读字段，以指示基于 `OutlineLevel` 的折叠状态expect(worksheet.getRow(4).collapsed).to.equal(false);expect(worksheet.getRow(5).collapsed).to.equal(true);row.getCell(1).value = 5; // A5 的值设置为5row.getCell(&#x27;name&#x27;).value = &#x27;Zeb&#x27;; // B5 的值设置为 “Zeb” - 假设第2列仍按名称键入row.getCell(&#x27;C&#x27;).value = new Date(); // C5 的值设置为当前时间// 获取行并作为稀疏数组返回// 注意：接口更改：worksheet.getRow(4) ==&gt; worksheet.getRow(4).valuesrow = worksheet.getRow(4).values;expect(row[5]).toEqual(&#x27;Kyle&#x27;);// 通过连续数组分配行值（其中数组元素 0 具有值）row.values = [1, 2, 3];expect(row.getCell(1).value).toEqual(1);expect(row.getCell(2).value).toEqual(2);expect(row.getCell(3).value).toEqual(3);// 通过稀疏数组分配行值（其中数组元素 0 为 `undefined`）const values = [];values[5] = 7;values[10] = &#x27;Hello, World!&#x27;;row.values = values;expect(row.getCell(1).value).toBeNull();expect(row.getCell(5).value).toEqual(7);expect(row.getCell(10).value).toEqual(&#x27;Hello, World!&#x27;);// 使用列键按对象分配行值row.values = &#123; id: 13, name: &#x27;Thing 1&#x27;, dob: new Date(),&#125;;// 在该行下方插入一个分页符row.addPageBreak();// 遍历工作表中具有值的所有行worksheet.eachRow(function (row, rowNumber) &#123; console.log(&#x27;Row &#x27; + rowNumber + &#x27; = &#x27; + JSON.stringify(row.values));&#125;);// 遍历工作表中的所有行（包括空行）worksheet.eachRow(&#123; includeEmpty: true &#125;, function (row, rowNumber) &#123; console.log(&#x27;Row &#x27; + rowNumber + &#x27; = &#x27; + JSON.stringify(row.values));&#125;);// 连续遍历所有非空单元格row.eachCell(function (cell, colNumber) &#123; console.log(&#x27;Cell &#x27; + colNumber + &#x27; = &#x27; + cell.value);&#125;);// 遍历一行中的所有单元格（包括空单元格）row.eachCell(&#123; includeEmpty: true &#125;, function (cell, colNumber) &#123; console.log(&#x27;Cell &#x27; + colNumber + &#x27; = &#x27; + cell.value);&#125;);// 提交给流一个完成的行row.commit();// 行尺寸const rowSize = row.cellCount;const numValues = row.actualCellCount; Add Rows⬆// Add a couple of Rows by key-value, after the last current row, using the column keysworksheet.addRow(&#123; id: 1, name: &#x27;John Doe&#x27;, dob: new Date(1970, 1, 1) &#125;);worksheet.addRow(&#123; id: 2, name: &#x27;Jane Doe&#x27;, dob: new Date(1965, 1, 7) &#125;);// Add a row by contiguous Array (assign to columns A, B &amp; C)worksheet.addRow([3, &#x27;Sam&#x27;, new Date()]);// Add a row by sparse Array (assign to columns A, E &amp; I)const rowValues = [];rowValues[1] = 4;rowValues[5] = &#x27;Kyle&#x27;;rowValues[9] = new Date();worksheet.addRow(rowValues);// Add a row with inherited style// This new row will have same style as last row// And return as row objectconst newRow = worksheet.addRow(rowValues, &#x27;i&#x27;);// Add an array of rowsconst rows = [ [5, &#x27;Bob&#x27;, new Date()], // row by array &#123; id: 6, name: &#x27;Barbara&#x27;, dob: new Date() &#125;,];// add new rows and return them as array of row objectsconst newRows = worksheet.addRows(rows);// Add an array of rows with inherited style// These new rows will have same styles as last row// and return them as array of row objectsconst newRowsStyled = worksheet.addRows(rows, &#x27;i&#x27;); Parameter Description Default Value value/s The new row/s values style ‘i’ for inherit from row above, ‘i+’ to include empty cells, ‘n’ for none ‘n’ 处理单个单元格⬆const cell = worksheet.getCell(&#x27;C3&#x27;);// 修改/添加单个单元格cell.value = new Date(1968, 5, 1);// 查询单元格的类型expect(cell.type).toEqual(Excel.ValueType.Date);// 使用单元格的字符串值myInput.value = cell.text;// 使用 html 安全的字符串进行渲染...const html = &#x27;&lt;div&gt;&#x27; + cell.html + &#x27;&lt;/div&gt;&#x27;; 合并单元格⬆// 合并一系列单元格worksheet.mergeCells(&#x27;A4:B5&#x27;);// ...合并的单元格被链接起来了worksheet.getCell(&#x27;B5&#x27;).value = &#x27;Hello, World!&#x27;;expect(worksheet.getCell(&#x27;B5&#x27;).value).toBe(worksheet.getCell(&#x27;A4&#x27;).value);expect(worksheet.getCell(&#x27;B5&#x27;).master).toBe(worksheet.getCell(&#x27;A4&#x27;));// ...合并的单元格共享相同的样式对象expect(worksheet.getCell(&#x27;B5&#x27;).style).toBe(worksheet.getCell(&#x27;A4&#x27;).style);worksheet.getCell(&#x27;B5&#x27;).style.font = myFonts.arial;expect(worksheet.getCell(&#x27;A4&#x27;).style.font).toBe(myFonts.arial);// 取消单元格合并将打破链接的样式worksheet.unMergeCells(&#x27;A4&#x27;);expect(worksheet.getCell(&#x27;B5&#x27;).style).not.toBe(worksheet.getCell(&#x27;A4&#x27;).style);expect(worksheet.getCell(&#x27;B5&#x27;).style.font).not.toBe(myFonts.arial);// 按左上，右下合并worksheet.mergeCells(&#x27;K10&#x27;, &#x27;M12&#x27;);// 按开始行，开始列，结束行，结束列合并（相当于 K10:M12）worksheet.mergeCells(10, 11, 12, 13); Insert Rows⬆insertRow(pos, value, (style = &#x27;n&#x27;));insertRows(pos, values, (style = &#x27;n&#x27;));// Insert a couple of Rows by key-value, shifting down rows every timeworksheet.insertRow(1, &#123; id: 1, name: &#x27;John Doe&#x27;, dob: new Date(1970, 1, 1) &#125;);worksheet.insertRow(1, &#123; id: 2, name: &#x27;Jane Doe&#x27;, dob: new Date(1965, 1, 7) &#125;);// Insert a row by contiguous Array (assign to columns A, B &amp; C)worksheet.insertRow(1, [3, &#x27;Sam&#x27;, new Date()]);// Insert a row by sparse Array (assign to columns A, E &amp; I)var rowValues = [];rowValues[1] = 4;rowValues[5] = &#x27;Kyle&#x27;;rowValues[9] = new Date();// insert new row and return as row objectconst insertedRow = worksheet.insertRow(1, rowValues);// Insert a row, with inherited style// This new row will have same style as row on top of it// And return as row objectconst insertedRowInherited = worksheet.insertRow(1, rowValues, &#x27;i&#x27;);// Insert a row, keeping original style// This new row will have same style as it was previously// And return as row objectconst insertedRowOriginal = worksheet.insertRow(1, rowValues, &#x27;o&#x27;);// Insert an array of rows, in position 1, shifting down current position 1 and later rows by 2 rowsvar rows = [ [5, &#x27;Bob&#x27;, new Date()], // row by array &#123; id: 6, name: &#x27;Barbara&#x27;, dob: new Date() &#125;,];// insert new rows and return them as array of row objectsconst insertedRows = worksheet.insertRows(1, rows);// Insert an array of rows, with inherited style// These new rows will have same style as row on top of it// And return them as array of row objectsconst insertedRowsInherited = worksheet.insertRows(1, rows, &#x27;i&#x27;);// Insert an array of rows, keeping original style// These new rows will have same style as it was previously in &#x27;pos&#x27; positionconst insertedRowsOriginal = worksheet.insertRows(1, rows, &#x27;o&#x27;); Parameter Description Default Value pos Row number where you want to insert, pushing down all rows from there value/s The new row/s values style ‘i’ for inherit from row above, , ‘i+’ to include empty cells, ‘o’ for original style, ‘o+’ to include empty cells, ‘n’ for none ‘n’ Splice⬆// Cut one or more rows (rows below are shifted up)// Known Issue: If a splice causes any merged cells to move, the results may be unpredictableworksheet.spliceRows(4, 3);// remove one row and insert two more.// Note: rows 4 and below will be shifted down by 1 row.const newRow3Values = [1, 2, 3, 4, 5];const newRow4Values = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;five&#x27;];worksheet.spliceRows(3, 1, newRow3Values, newRow4Values);// Cut one or more cells (cells to the right are shifted left)// Note: this operation will not affect other rowsrow.splice(3, 2);// remove one cell and insert two more (cells to the right of the cut cell will be shifted right)row.splice(4, 1, &#x27;new value 1&#x27;, &#x27;new value 2&#x27;); Parameter Description Default Value start Starting point to splice from count Number of rows/cells to remove …inserts New row/cell values to insert 重复行⬆duplicateRow(start, (amount = 1), (insert = true));const wb = new ExcelJS.Workbook();const ws = wb.addWorksheet(&#x27;duplicateTest&#x27;);ws.getCell(&#x27;A1&#x27;).value = &#x27;One&#x27;;ws.getCell(&#x27;A2&#x27;).value = &#x27;Two&#x27;;ws.getCell(&#x27;A3&#x27;).value = &#x27;Three&#x27;;ws.getCell(&#x27;A4&#x27;).value = &#x27;Four&#x27;;// 该行将重复复制第一行两次，但将替换第二行和第三行// 如果第三个参数为 true，则它将插入2个新行，其中包含行 “One” 的值和样式ws.duplicateRow(1, 2, false); 参数 描述 默认值 start 要复制的行号（Excel 中的第一个是 1） amount 您要复制行的次数 1 insert 如果要为重复项插入新行，则为 true，否则为 false 将替换已有行 true 定义名称⬆单个单元格（或多个单元格组）可以为它们分配名称。名称可用于公式和数据验证（可能还有更多）。 // 为单元格分配（或获取）名称（将覆盖该单元具有的其他任何名称）worksheet.getCell(&#x27;A1&#x27;).name = &#x27;PI&#x27;;expect(worksheet.getCell(&#x27;A1&#x27;).name).to.equal(&#x27;PI&#x27;);// 为单元格分配（或获取）一组名称（单元可以具有多个名称）worksheet.getCell(&#x27;A1&#x27;).names = [&#x27;thing1&#x27;, &#x27;thing2&#x27;];expect(worksheet.getCell(&#x27;A1&#x27;).names).to.have.members([&#x27;thing1&#x27;, &#x27;thing2&#x27;]);// 从单元格中删除名称worksheet.getCell(&#x27;A1&#x27;).removeName(&#x27;thing1&#x27;);expect(worksheet.getCell(&#x27;A1&#x27;).names).to.have.members([&#x27;thing2&#x27;]); 数据验证⬆单元格可以定义哪些值有效或无效，并提示用户以帮助指导它们。 验证类型可以是以下之一： 类型 描述 list 定义一组离散的有效值。Excel 将在下拉菜单中提供这些内容，以便于输入 whole 该值必须是整数 decimal 该值必须是十进制数 textLength 该值可以是文本，但长度是受控的 custom 自定义公式控制有效值 对于 list 或 custom 以外的其他类型，以下运算符会影响验证： 运算符 描述 between 值必须介于公式结果之间 notBetween 值不能介于公式结果之间 equal 值必须等于公式结果 notEqual 值不能等于公式结果 greaterThan 值必须大于公式结果 lessThan 值必须小于公式结果 greaterThanOrEqual 值必须大于或等于公式结果 lessThanOrEqual 值必须小于或等于公式结果 // 指定有效值的列表（One，Two，Three，Four）。// Excel 将提供一个包含这些值的下拉列表。worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;list&#x27;, allowBlank: true, formulae: [&#x27;&quot;One,Two,Three,Four&quot;&#x27;],&#125;;// 指定范围内的有效值列表。// Excel 将提供一个包含这些值的下拉列表。worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;list&#x27;, allowBlank: true, formulae: [&#x27;$D$5:$F$5&#x27;],&#125;;// 指定单元格必须为非5的整数。// 向用户显示适当的错误消息（如果他们弄错了）worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;whole&#x27;, operator: &#x27;notEqual&#x27;, showErrorMessage: true, formulae: [5], errorStyle: &#x27;error&#x27;, errorTitle: &#x27;Five&#x27;, error: &#x27;The value must not be Five&#x27;,&#125;;// 指定单元格必须为1.5到7之间的十进制数字。// 添加“工具提示”以帮助指导用户worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;decimal&#x27;, operator: &#x27;between&#x27;, allowBlank: true, showInputMessage: true, formulae: [1.5, 7], promptTitle: &#x27;Decimal&#x27;, prompt: &#x27;The value must between 1.5 and 7&#x27;,&#125;;// 指定单元格的文本长度必须小于15worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;textLength&#x27;, operator: &#x27;lessThan&#x27;, showErrorMessage: true, allowBlank: true, formulae: [15],&#125;;// 指定单元格必须是2016年1月1日之前的日期worksheet.getCell(&#x27;A1&#x27;).dataValidation = &#123; type: &#x27;date&#x27;, operator: &#x27;lessThan&#x27;, showErrorMessage: true, allowBlank: true, formulae: [new Date(2016, 0, 1)],&#125;; 单元格注释⬆将旧样式的注释添加到单元格 // 纯文字笔记worksheet.getCell(&#x27;A1&#x27;).note = &#x27;Hello, ExcelJS!&#x27;;// 彩色格式化的笔记ws.getCell(&#x27;B1&#x27;).note = &#123; texts: [ &#123; font: &#123; size: 12, color: &#123; theme: 0 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;This is &#x27;, &#125;, &#123; font: &#123; italic: true, size: 12, color: &#123; theme: 0 &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;a&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; &#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; argb: &#x27;FFFF6600&#x27; &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;colorful&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; text &#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; argb: &#x27;FFCCFFCC&#x27; &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;with&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; in-cell &#x27;, &#125;, &#123; font: &#123; bold: true, size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;format&#x27;, &#125;, ], margins: &#123; insetmode: &#x27;custom&#x27;, inset: [0.25, 0.25, 0.35, 0.35], &#125;, protection: &#123; locked: True, lockText: False, &#125;, editAs: &#x27;twoCells&#x27;,&#125;; 单元格批注属性⬆下表定义了单元格注释已支持的属性。 Field Required Default Value Description texts Y 评论文字 margins N {} 确定自动或自定义设置单元格注释的边距值 protection N {} 可以使用保护属性来指定对象和对象文本的锁定状态 editAs N ‘absolute’ 可以使用’editAs’属性来指定注释如何锚定到单元格 单元格批注页边距⬆确定单元格批注的页面距设置模式，自动或者自定义模式。 ws.getCell(&#x27;B1&#x27;).note.margins = &#123; insetmode: &#x27;custom&#x27;, inset: [0.25, 0.25, 0.35, 0.35],&#125;; 已支持的页边距属性⬆ Property Required Default Value Description insetmode N ‘auto’ 确定是否自动设置注释边距，并且值是’auto’ 或者 ‘custom’ inset N [0.13, 0.13, 0.25, 0.25] 批注页边距的值，单位是厘米, 方向是左-上-右-下 注意：只有当 insetmode的值设置为’custom’时，inset的设置才生效。 单元格批注保护⬆可以使用保护属性来修改单元级别保护。 ws.getCell(&#x27;B1&#x27;).note.protection = &#123; locked: &#x27;False&#x27;, lockText: &#x27;False&#x27;,&#125;; 已支持的保护属性⬆ Property Required Default Value Description locked N ‘True’ 此元素指定在保护工作表时对象已锁定 lockText N ‘True’ 该元素指定对象的文本已锁定 单元格批注对象位置属性⬆单元格注释还可以具有属性 ‘editAs’，该属性将控制注释如何锚定到单元格。它可以具有以下值之一： ws.getCell(&#x27;B1&#x27;).note.editAs = &#x27;twoCells&#x27;; Value Description twoCells 它指定注释的大小、位置随单元格而变 oneCells 它指定注释的大小固定，位置随单元格而变 absolute 这是默认值，它指定注释的大小、位置均固定 表格⬆表允许表格内数据的表内操作。 要将表添加到工作表，请定义表模型并调用 addTable： // 将表格添加到工作表ws.addTable(&#123; name: &#x27;MyTable&#x27;, ref: &#x27;A1&#x27;, headerRow: true, totalsRow: true, style: &#123; theme: &#x27;TableStyleDark3&#x27;, showRowStripes: true, &#125;, columns: [ &#123; name: &#x27;Date&#x27;, totalsRowLabel: &#x27;Totals:&#x27;, filterButton: true &#125;, &#123; name: &#x27;Amount&#x27;, totalsRowFunction: &#x27;sum&#x27;, filterButton: false &#125;, ], rows: [ [new Date(&#x27;2019-07-20&#x27;), 70.1], [new Date(&#x27;2019-07-21&#x27;), 70.6], [new Date(&#x27;2019-07-22&#x27;), 70.1], ],&#125;); 注意：将表格添加到工作表将通过放置表格的标题和行数据来修改工作表。结果就是表格覆盖的工作表上的所有数据（包括标题和所有的）都将被覆盖。 表格属性⬆下表定义了表格支持的属性。 表属性 描述 是否需要 默认值 name 表格名称 Y displayName 表格的显示名称 N name ref 表格的左上方单元格 Y headerRow 在表格顶部显示标题 N true totalsRow 在表格底部显示总计 N false style 额外的样式属性 N {} columns 列定义 Y rows 数据行 Y 表格样式属性⬆下表定义了表格中支持的属性样式属性。 样式属性 描述 是否需要 默认值 theme 桌子的颜色主题 N &#39;TableStyleMedium2&#39; showFirstColumn 突出显示第一列（粗体） N false showLastColumn 突出显示最后一列（粗体） N false showRowStripes 用交替的背景色显示行 N false showColumnStripes 用交替的背景色显示列 N false 表格列属性⬆下表定义了每个表格列中支持的属性。 列属性 描述 是否需要 默认值 name 列名，也用在标题中 Y filterButton 切换标题中的过滤器控件 N false totalsRowLabel 用于描述统计行的标签（第一列） N &#39;Total&#39; totalsRowFunction 统计函数名称 N &#39;none&#39; totalsRowFormula 自定义函数的可选公式 N 统计函数⬆下表列出了由列定义的 totalsRowFunction 属性的有效值。如果使用 &#39;custom&#39; 以外的任何值，则无需包括关联的公式，因为该公式将被表格插入。 统计函数 描述 none 此列没有统计函数 average 计算列的平均值 countNums 统计数字条目数 count 条目数 max 此列中的最大值 min 此列中的最小值 stdDev 该列的标准偏差 var 此列的方差 sum 此列的条目总数 custom 自定义公式。 需要关联的 totalsRowFormula 值。 表格样式主题⬆有效的主题名称遵循以下模式： “TableStyle[Shade][Number]” Shades（阴影），Number（数字）可以是以下之一： Light, 1-21 Medium, 1-28 Dark, 1-11 对于无主题，请使用值 null。 注意：exceljs 尚不支持自定义表格主题。 修改表格⬆表格支持一组操作函数，这些操作函数允许添加或删除数据以及更改某些属性。由于这些操作中的许多操作可能会对工作表产生副作用，因此更改必须在完成后立即提交。 表中的所有索引值均基于零，因此第一行号和第一列号为 0。 添加或删除标题和统计 const table = ws.getTable(&#x27;MyTable&#x27;);// 打开标题行table.headerRow = true;// 关闭统计行table.totalsRow = false;// 将表更改提交到工作表中table.commit(); 重定位表 const table = ws.getTable(&#x27;MyTable&#x27;);// 表格左上移至 D4table.ref = &#x27;D4&#x27;;// 将表更改提交到工作表中table.commit(); 添加和删除行 const table = ws.getTable(&#x27;MyTable&#x27;);// 删除前两行table.removeRows(0, 2);// 在索引 5 处插入新行table.addRow([new Date(&#x27;2019-08-05&#x27;), 5, &#x27;Mid&#x27;], 5);// 在表格底部追加新行table.addRow([new Date(&#x27;2019-08-10&#x27;), 10, &#x27;End&#x27;]);// 将表更改提交到工作表中table.commit(); 添加和删除列 const table = ws.getTable(&#x27;MyTable&#x27;);// 删除第二列table.removeColumns(1, 1);// 在索引 1 处插入新列（包含数据）table.addColumn( &#123; name: &#x27;Letter&#x27;, totalsRowFunction: &#x27;custom&#x27;, totalsRowFormula: &#x27;ROW()&#x27;, totalsRowResult: 6, filterButton: true, &#125;, [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;], 2);// 将表更改提交到工作表中table.commit(); 更改列属性 const table = ws.getTable(&#x27;MyTable&#x27;);// 获取第二列的列包装器const column = table.getColumn(1);// 设置一些属性column.name = &#x27;Code&#x27;;column.filterButton = true;column.style = &#123; font: &#123; bold: true, name: &#x27;Comic Sans MS&#x27; &#125; &#125;;column.totalsRowLabel = &#x27;Totals&#x27;;column.totalsRowFunction = &#x27;custom&#x27;;column.totalsRowFormula = &#x27;ROW()&#x27;;column.totalsRowResult = 10;// 将表更改提交到工作表中table.commit(); 样式⬆单元格，行和列均支持一组丰富的样式和格式，这些样式和格式会影响单元格的显示方式。 通过分配以下属性来设置样式： numFmt font alignment border fill // 为单元格分配样式ws.getCell(&#x27;A1&#x27;).numFmt = &#x27;0.00%&#x27;;// 将样式应用于工作表列ws.columns = [ &#123; header: &#x27;Id&#x27;, key: &#x27;id&#x27;, width: 10 &#125;, &#123; header: &#x27;Name&#x27;, key: &#x27;name&#x27;, width: 32, style: &#123; font: &#123; name: &#x27;Arial Black&#x27; &#125; &#125;, &#125;, &#123; header: &#x27;D.O.B.&#x27;, key: &#x27;DOB&#x27;, width: 10, style: &#123; numFmt: &#x27;dd/mm/yyyy&#x27; &#125; &#125;,];// 将第3列设置为“货币格式”ws.getColumn(3).numFmt = &#x27;&quot;£&quot;#,##0.00;[Red]-&quot;£&quot;#,##0.00&#x27;;// 将第2行设置为 Comic Sans。ws.getRow(2).font = &#123; name: &#x27;Comic Sans MS&#x27;, family: 4, size: 16, underline: &#x27;double&#x27;, bold: true,&#125;; 将样式应用于行或列时，它将应用于该行或列中所有当前存在的单元格。另外，创建的任何新单元格都将从其所属的行和列继承其初始样式。 如果单元格的行和列都定义了特定的样式（例如，字体），则该单元格所在行样式比列样式具有更高优先级。但是，如果行和列定义了不同的样式（例如 column.numFmt 和 row.font），则单元格将继承行的字体和列的 numFmt。 注意：以上所有属性（numFmt（字符串）除外）都是 JS 对象结构。如果将同一样式对象分配给多个电子表格实体，则每个实体将共享同一样式对象。如果样式对象后来在电子表格序列化之前被修改，则所有引用该样式对象的实体也将被修改。此行为旨在通过减少创建的 JS 对象的数量来优先考虑性能。如果希望样式对象是独立的，则需要先对其进行克隆，然后再分配它们。同样，默认情况下，如果电子表格实体共享相似的样式，则从文件（或流）中读取文档时，它们也将引用相同的样式对象。 数字格式⬆// 将值显示为“ 1 3/5”ws.getCell(&#x27;A1&#x27;).value = 1.6;ws.getCell(&#x27;A1&#x27;).numFmt = &#x27;# ?/?&#x27;;// 显示为“ 1.60％”ws.getCell(&#x27;B1&#x27;).value = 0.016;ws.getCell(&#x27;B1&#x27;).numFmt = &#x27;0.00%&#x27;; 字体// for the wannabe graphic designers out therews.getCell(&#x27;A1&#x27;).font = &#123; name: &#x27;Comic Sans MS&#x27;, family: 4, size: 16, underline: true, bold: true,&#125;;// for the graduate graphic designers...ws.getCell(&#x27;A2&#x27;).font = &#123; name: &#x27;Arial Black&#x27;, color: &#123; argb: &#x27;FF00FF00&#x27; &#125;, family: 2, size: 14, italic: true,&#125;;// 垂直对齐ws.getCell(&#x27;A3&#x27;).font = &#123; vertAlign: &#x27;superscript&#x27;,&#125;;// 注意：该单元格将存储对分配的字体对象的引用。// 如果之后更改了字体对象，则单元字体也将更改。const font = &#123; name: &#x27;Arial&#x27;, size: 12 &#125;;ws.getCell(&#x27;A3&#x27;).font = font;font.size = 20; // 单元格 A3 现在具有20号字体！// 从文件或流中读取工作簿后，共享相似字体的单元格可能引用相同的字体对象 字体属性 描述 示例值 name 字体名称。 ‘Arial’, ‘Calibri’, etc. family 备用字体家族。整数值。 1 - Serif, 2 - Sans Serif, 3 - Mono, Others - unknown scheme 字体方案。 ‘minor’, ‘major’, ‘none’ charset 字体字符集。整数值。 1, 2, etc. size 字体大小。整数值。 9, 10, 12, 16, etc. color 颜色描述，一个包含 ARGB 值的对象。 { argb: ‘FFFF0000’} bold 字体 粗细 true, false italic 字体 倾斜 true, false underline 字体 下划线 样式 true, false, ‘none’, ‘single’, ‘double’, ‘singleAccounting’, ‘doubleAccounting’ strike 字体 删除线 true, false outline 字体轮廓 true, false vertAlign 垂直对齐 ‘superscript’, ‘subscript’ 对齐⬆// 将单元格对齐方式设置为左上，中间居中，右下ws.getCell(&#x27;A1&#x27;).alignment = &#123; vertical: &#x27;top&#x27;, horizontal: &#x27;left&#x27; &#125;;ws.getCell(&#x27;B1&#x27;).alignment = &#123; vertical: &#x27;middle&#x27;, horizontal: &#x27;center&#x27; &#125;;ws.getCell(&#x27;C1&#x27;).alignment = &#123; vertical: &#x27;bottom&#x27;, horizontal: &#x27;right&#x27; &#125;;// 将单元格设置为自动换行ws.getCell(&#x27;D1&#x27;).alignment = &#123; wrapText: true &#125;;// 将单元格缩进设置为1ws.getCell(&#x27;E1&#x27;).alignment = &#123; indent: 1 &#125;;// 将单元格文本旋转设置为向上30deg，向下45deg和垂直文本ws.getCell(&#x27;F1&#x27;).alignment = &#123; textRotation: 30 &#125;;ws.getCell(&#x27;G1&#x27;).alignment = &#123; textRotation: -45 &#125;;ws.getCell(&#x27;H1&#x27;).alignment = &#123; textRotation: &#x27;vertical&#x27; &#125;; 有效的对齐属性值 水平的 垂直 文本换行 自适应 缩进 阅读顺序 文本旋转 left top true true integer rtl 0 to 90 center middle false false ltr -1 to -90 right bottom vertical fill distributed justify justify centerContinuous distributed 边框⬆// 在A1周围设置单个细边框ws.getCell(&#x27;A1&#x27;).border = &#123; top: &#123; style: &#x27;thin&#x27; &#125;, left: &#123; style: &#x27;thin&#x27; &#125;, bottom: &#123; style: &#x27;thin&#x27; &#125;, right: &#123; style: &#x27;thin&#x27; &#125;,&#125;;// 在A3周围设置双细绿色边框ws.getCell(&#x27;A3&#x27;).border = &#123; top: &#123; style: &#x27;double&#x27;, color: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;, left: &#123; style: &#x27;double&#x27;, color: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;, bottom: &#123; style: &#x27;double&#x27;, color: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;, right: &#123; style: &#x27;double&#x27;, color: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;,&#125;;// 在A5中设置厚红十字边框ws.getCell(&#x27;A5&#x27;).border = &#123; diagonal: &#123; up: true, down: true, style: &#x27;thick&#x27;, color: &#123; argb: &#x27;FFFF0000&#x27; &#125;, &#125;,&#125;; 有效边框样式 thin dotted dashDot hair dashDotDot slantDashDot mediumDashed mediumDashDotDot mediumDashDot medium double thick 填充⬆// 用红色深色垂直条纹填充A1ws.getCell(&#x27;A1&#x27;).fill = &#123; type: &#x27;pattern&#x27;, pattern: &#x27;darkVertical&#x27;, fgColor: &#123; argb: &#x27;FFFF0000&#x27; &#125;,&#125;;// 在A2中填充深黄色格子和蓝色背景ws.getCell(&#x27;A2&#x27;).fill = &#123; type: &#x27;pattern&#x27;, pattern: &#x27;darkTrellis&#x27;, fgColor: &#123; argb: &#x27;FFFFFF00&#x27; &#125;, bgColor: &#123; argb: &#x27;FF0000FF&#x27; &#125;,&#125;;// 从左到右用蓝白蓝渐变填充A3ws.getCell(&#x27;A3&#x27;).fill = &#123; type: &#x27;gradient&#x27;, gradient: &#x27;angle&#x27;, degree: 0, stops: [ &#123; position: 0, color: &#123; argb: &#x27;FF0000FF&#x27; &#125; &#125;, &#123; position: 0.5, color: &#123; argb: &#x27;FFFFFFFF&#x27; &#125; &#125;, &#123; position: 1, color: &#123; argb: &#x27;FF0000FF&#x27; &#125; &#125;, ],&#125;;// 从中心开始用红绿色渐变填充A4ws.getCell(&#x27;A4&#x27;).fill = &#123; type: &#x27;gradient&#x27;, gradient: &#x27;path&#x27;, center: &#123; left: 0.5, top: 0.5 &#125;, stops: [ &#123; position: 0, color: &#123; argb: &#x27;FFFF0000&#x27; &#125; &#125;, &#123; position: 1, color: &#123; argb: &#x27;FF00FF00&#x27; &#125; &#125;, ],&#125;; 填充模式⬆ 属性 是否需要 描述 type Y 值: &#39;pattern&#39;指定此填充使用模式 pattern Y 指定模式类型 (查看下面 有效模式类型 ) fgColor N 指定图案前景色。默认为黑色。 bgColor N 指定图案背景色。默认为白色。 有效模式类型 none solid darkGray mediumGray lightGray gray125 gray0625 darkHorizontal darkVertical darkDown darkUp darkGrid darkTrellis lightHorizontal lightVertical lightDown lightUp lightGrid lightTrellis 渐变填充⬆ 属性 是否需要 描述 type Y 值: &#39;gradient&#39;指定此填充使用渐变 gradient Y 指定渐变类型。[&#39;angle&#39;，&#39;path&#39;] 之一 degree angle 对于“角度”渐变，指定渐变的方向。0 是从左到右。值从 1-359 顺时针旋转方向 center path 对于“路径”渐变。指定路径起点的相对坐标。“左”和“顶”值的范围是 0 到 1 stops Y 指定渐变颜色序列。是包含位置和颜色（从位置 0 开始到位置 1 结束）的对象的数组。中间位置可用于指定路径上的其他颜色。 注意事项 使用上面的接口，可能会创建使用 XLSX 编辑器程序无法实现的渐变填充效果。例如，Excel 仅支持 0、45、90 和 135 的角度梯度。类似地，stops 的顺序也可能受到 UI 的限制，其中位置 [0,1] 或[0,0.5,1] 是唯一的选择。请谨慎处理此填充，以确保目标 XLSX 查看器支持该填充。 富文本⬆现在，单个单元格支持 RTF 文本或单元格格式化。富文本值可以控制文本值内任意数量的子字符串的字体属性。有关支持哪些字体属性的详细信息，请参见字体。 ws.getCell(&#x27;A1&#x27;).value = &#123; richText: [ &#123; font: &#123; size: 12, color: &#123; theme: 0 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;This is &#x27;, &#125;, &#123; font: &#123; italic: true, size: 12, color: &#123; theme: 0 &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;a&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; &#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; argb: &#x27;FFFF6600&#x27; &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;colorful&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; text &#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; argb: &#x27;FFCCFFCC&#x27; &#125;, name: &#x27;Calibri&#x27;, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;with&#x27;, &#125;, &#123; font: &#123; size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27; in-cell &#x27;, &#125;, &#123; font: &#123; bold: true, size: 12, color: &#123; theme: 1 &#125;, name: &#x27;Calibri&#x27;, family: 2, scheme: &#x27;minor&#x27;, &#125;, text: &#x27;format&#x27;, &#125;, ],&#125;;expect(ws.getCell(&#x27;A1&#x27;).text).to.equal( &#x27;This is a colorful text with in-cell format&#x27;);expect(ws.getCell(&#x27;A1&#x27;).type).to.equal(Excel.ValueType.RichText); 单元格保护⬆可以使用保护属性来修改单元级别保护。 ws.getCell(&#x27;A1&#x27;).protection = &#123; locked: false, hidden: true,&#125;; 支持的保护属性 属性 默认值 描述 locked true 指定在工作表受保护的情况下是否将单元格锁定。 hidden false 指定如果工作表受保护，则单元格的公式是否可见。 条件格式化⬆条件格式化允许工作表根据单元格值或任意公式显示特定的样式，图标等。 条件格式设置规则是在工作表级别添加的，通常会覆盖一系列单元格。 可以将多个规则应用于给定的单元格范围，并且每个规则都将应用自己的样式。 如果多个规则影响给定的单元格，则规则优先级值将确定如果竞争样式冲突，则哪个规则胜出。优先级值较低的规则获胜。如果没有为给定规则指定优先级值，ExcelJS 将按升序分配它们。 注意：目前，仅支持条件格式设置规则的子集。具体来说，只有格式规则不需要 &lt;extLst&amp;gt 元素内的 XML 呈现。这意味着不支持数据集和三个特定的图标集（3Triangles，3Stars，5Boxes）。 // 根据行和列为偶数或奇数向 A1:E7 添加一个棋盘图案worksheet.addConditionalFormatting(&#123; ref: &#x27;A1:E7&#x27;, rules: [ &#123; type: &#x27;expression&#x27;, formulae: [&#x27;MOD(ROW()+COLUMN(),2)=0&#x27;], style: &#123; fill: &#123; type: &#x27;pattern&#x27;, pattern: &#x27;solid&#x27;, bgColor: &#123; argb: &#x27;FF00FF00&#x27; &#125;, &#125;, &#125;, &#125;, ],&#125;); 支持的条件格式设置规则类型 类型 描述 expression 任何自定义功能均可用于激活规则。 cellIs 使用指定的运算符将单元格值与提供的公式进行比较 top10 将格式化应用于值在顶部（或底部）范围内的单元格 aboveAverage 将格式化应用于值高于（或低于）平均值的单元格 colorScale 根据其值在范围内的位置将彩色背景应用于单元格 iconSet 根据值将一系列图标之一添加到单元格 containsText 根据单元格是否为特定文本来应用格式 timePeriod 根据单元格日期时间值是否在指定范围内应用格式 表达式⬆ 属性 可选 默认值 描述 type &#39;expression&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 formulae 1 个包含真/假值的公式字符串数组。要引用单元格值，请使用左上角的单元格地址 style 公式返回 true 时要应用的样式结构 Cell Is⬆ 属性 可选 默认值 描述 type &#39;cellIs&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 operator 如何将单元格值与公式结果进行比较 formulae 1 个公式字符串数组，返回要与每个单元格进行比较的值 style 如果比较返回 true，则应用样式结构 Cell Is 运算符 运算 描述 equal 如果单元格值等于公式值，则应用格式 greaterThan 如果单元格值大于公式值，则应用格式 lessThan 如果单元格值小于公式值，则应用格式 between 如果单元格值在两个公式值之间（包括两个值），则应用格式 Top 10⬆ 属性 可选 默认值 描述 type &#39;top10&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 rank Y 10 指定格式中包含多少个顶部（或底部）值 percent Y false 如果为 true，则等级字段为百分比，而不是绝对值 bottom Y false 如果为 true，则包含最低值而不是最高值 style 如果比较返回 true，则应用样式结构 高于平均值⬆ 属性 可选 默认值 描述 type &#39;aboveAverage&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 aboveAverage Y false 如果为 true，则等级字段为百分比，而不是绝对值 style 如果比较返回 true，则应用样式结构 色阶⬆ 属性 可选 默认值 描述 type &#39;colorScale&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 cfvo 2 到 5 个条件格式化值对象的数组，指定值范围内的航路点 color 在给定的航路点使用的相应颜色数组 style 如果比较返回 true，则应用样式结构 图标集⬆ 属性 可选 默认值 描述 type &#39;iconSet&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 iconSet Y 3TrafficLights 设置使用的图标名称 showValue true 指定应用范围内的单元格是显示图标和单元格值，还是仅显示图标 reverse false 指定是否以保留顺序显示 iconSet 中指定的图标集中的图标。 如果 custom 等于 true，则必须忽略此值 custom false 指定是否使用自定义图标集 cfvo 2 到 5 个条件格式化值对象的数组，指定值范围内的航路点 style 如果比较返回 true，则应用样式结构 数据条⬆ 字段 可选 默认值 描述 type &#39;dataBar&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 minLength 0 指定此条件格式范围内最短数据条的长度 maxLength 100 指定此条件格式范围内最长数据条的长度 showValue true 指定条件格式范围内的单元格是否同时显示数据条和数值或数据条 gradient true 指定数据条是否具有渐变填充 border true 指定数据条是否有边框 negativeBarColorSameAsPositive true 指定数据条是否具有与正条颜色不同的负条颜色 negativeBarBorderColorSameAsPositive true 指定数据条的负边框颜色是否不同于正边框颜色 axisPosition ‘auto’ 指定数据条的轴位置 direction ‘leftToRight’ 指定数据条的方向 cfvo 2 到 5 个条件格式化值对象的数组，指定值范围内的航路点 style 如果比较返回 true，则应用样式结构 包含文字⬆ 属性 可选 默认值 描述 type &#39;containsText&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 operator 文本比较类型 text 要搜索的文本 style 如果比较返回 true，则应用样式结构 包含文本运算符 运算符 描述 containsText 如果单元格值包含在 text 字段中指定的值，则应用格式 containsBlanks 如果单元格值包含空格，则应用格式 notContainsBlanks 如果单元格值不包含空格，则应用格式 containsErrors 如果单元格值包含错误，则应用格式 notContainsErrors 如果单元格值不包含错误，则应用格式 时间段⬆ 属性 可选 默认值 描述 type &#39;timePeriod&#39; priority Y &lt;auto&gt; 确定样式的优先顺序 timePeriod 比较单元格值的时间段 style 如果比较返回 true，则应用样式结构 时间段 时间段 描述 lastWeek 如果单元格值落在最后一周内，则应用格式 thisWeek 如果单元格值在本周下降，则应用格式 nextWeek 如果单元格值在下一周下降，则应用格式 yesterday 如果单元格值等于昨天，则应用格式 today 如果单元格值等于今天，则应用格式 tomorrow 如果单元格值等于明天，则应用格式 last7Days 如果单元格值在过去 7 天之内，则应用格式 lastMonth 如果单元格值属于上个月，则应用格式 thisMonth 如果单元格值在本月下降，则应用格式 nextMonth 如果单元格值在下个月下降，则应用格式 大纲级别⬆Excel 支持大纲；行或列可以根据用户希望查看的详细程度展开或折叠。 大纲级别可以在列设置中定义： worksheet.columns = [ &#123; header: &#x27;Id&#x27;, key: &#x27;id&#x27;, width: 10 &#125;, &#123; header: &#x27;Name&#x27;, key: &#x27;name&#x27;, width: 32 &#125;, &#123; header: &#x27;D.O.B.&#x27;, key: &#x27;DOB&#x27;, width: 10, outlineLevel: 1 &#125;,]; 或直接在行或列上 worksheet.getColumn(3).outlineLevel = 1;worksheet.getRow(3).outlineLevel = 1; 工作表大纲级别可以在工作表上设置 // 设置列大纲级别worksheet.properties.outlineLevelCol = 1;// 设置行大纲级别worksheet.properties.outlineLevelRow = 1; 注意：调整行或列上的大纲级别或工作表上的大纲级别将产生副作用，即还修改受属性更改影响的所有行或列的折叠属性。 例如。： worksheet.properties.outlineLevelCol = 1;worksheet.getColumn(3).outlineLevel = 1;expect(worksheet.getColumn(3).collapsed).to.be.true;worksheet.properties.outlineLevelCol = 2;expect(worksheet.getColumn(3).collapsed).to.be.false; 大纲属性可以在工作表上设置 worksheet.properties.outlineProperties = &#123; summaryBelow: false, summaryRight: false,&#125;; 图片⬆将图像添加到工作表是一个分为两个步骤的过程。首先，通过 addImage() 函数将图像添加到工作簿中，该函数还将返回 imageId 值。然后，使用 imageId，可以将图像作为平铺背景或覆盖单元格区域添加到工作表中。 注意：从此版本开始，不支持调整或变换图像。 将图片添加到工作簿⬆Workbook.addImage 函数支持按文件名或按 Buffer 添加图像。请注意，在两种情况下，都必须指定扩展名。有效的扩展名包括 “jpeg”，“png”，“gif”。 // 通过文件名将图像添加到工作簿const imageId1 = workbook.addImage(&#123; filename: &#x27;path/to/image.jpg&#x27;, extension: &#x27;jpeg&#x27;,&#125;);// 通过 buffer 将图像添加到工作簿const imageId2 = workbook.addImage(&#123; buffer: fs.readFileSync(&#x27;path/to.image.png&#x27;), extension: &#x27;png&#x27;,&#125;);// 通过 base64 将图像添加到工作簿const myBase64Image = &#x27;data:image/png;base64,iVBORw0KG...&#x27;;const imageId2 = workbook.addImage(&#123; base64: myBase64Image, extension: &#x27;png&#x27;,&#125;); 将图片添加到工作表背景⬆使用 Workbook.addImage 中的图像 ID，可以使用 addBackgroundImage 函数设置工作表的背景 // 设置背景worksheet.addBackgroundImage(imageId1); 在一定范围内添加图片⬆使用 Workbook.addImage 中的图像 ID，可以将图像嵌入工作表中以覆盖一定范围。从该范围计算出的坐标将覆盖从第一个单元格的左上角到第二个单元格的右下角。 // 在 B2:D6 上插入图片worksheet.addImage(imageId2, &#x27;B2:D6&#x27;); 使用结构而不是范围字符串，可以部分覆盖单元格。 请注意，为此使用的坐标系基于零，因此 A1 的左上角将为 &#123;col：0，row：0&#125;。单元格的分数可以通过使用浮点数来指定，例如 A1 的中点是 &#123;col：0.5，row：0.5&#125;。 // 在 B2:D6 的一部分上插入图像worksheet.addImage(imageId2, &#123; tl: &#123; col: 1.5, row: 1.5 &#125;, br: &#123; col: 3.5, row: 5.5 &#125;,&#125;); 单元格区域还可以具有属性 &quot;editAs&quot;，该属性将控制将图像锚定到单元格的方式。它可以具有以下值之一： 值 描述 undefined 它指定使图像将根据单元格移动和调整其大小 oneCell 这是默认值。图像将与单元格一起移动，但大小不变动 absolute 图像将不会随着单元格移动或调整大小 ws.addImage(imageId, &#123; tl: &#123; col: 0.1125, row: 0.4 &#125;, br: &#123; col: 2.101046875, row: 3.4 &#125;, editAs: &#x27;oneCell&#x27;,&#125;); 将图片添加到单元格⬆您可以将图像添加到单元格，然后以 96dpi 定义其宽度和高度（以像素为单位）。 worksheet.addImage(imageId2, &#123; tl: &#123; col: 0, row: 0 &#125;, ext: &#123; width: 500, height: 200 &#125;,&#125;); 添加带有超链接的图片⬆您可以将带有超链接的图像添加到单元格，并在图像范围内定义超链接。 worksheet.addImage(imageId2, &#123; tl: &#123; col: 0, row: 0 &#125;, ext: &#123; width: 500, height: 200 &#125;, hyperlinks: &#123; hyperlink: &#x27;http://www.somewhere.com&#x27;, tooltip: &#x27;http://www.somewhere.com&#x27;, &#125;,&#125;); 工作表保护⬆可以通过添加密码来保护工作表免受修改。 await worksheet.protect(&#x27;the-password&#x27;, options); 工作表保护也可以删除： worksheet.unprotect(); 有关如何修改单个单元格保护的详细信息请查看 单元格保护。 注意： 当 protect() 函数返回一个 Promise 代表它是异步的，当前的实现在主线程上运行，并且在 CPU 上将使用平均大约 600 毫秒。可以通过设置 spinCount 进行调整，该值可用于使过程更快或更有弹性。 工作表保护选项⬆ 属性 默认值 描述 selectLockedCells true 允许用户选择锁定的单元格 selectUnlockedCells true 允许用户选择未锁定的单元格 formatCells false 允许用户格式化单元格 formatColumns false 允许用户格式化列 formatRows false 允许用户格式化行 insertRows false 允许用户插入行 insertColumns false 允许用户插入列 insertHyperlinks false 允许用户插入超链接 deleteRows false 允许用户删除行 deleteColumns false 允许用户删除列 sort false 允许用户对数据进行排序 autoFilter false 允许用户过滤表中的数据 pivotTables false 允许用户使用数据透视表 spinCount 100000 保护或取消保护时执行的哈希迭代次数 文件 I/O⬆XLSX⬆读 XLSX⬆// 从文件读取const workbook = new Excel.Workbook();await workbook.xlsx.readFile(filename);// ... 使用 workbook// 从流读取const workbook = new Excel.Workbook();await workbook.xlsx.read(stream);// ... 使用 workbook// 从 buffer 加载const workbook = new Excel.Workbook();await workbook.xlsx.load(data);// ... 使用 workbook 写 XLSX// 写入文件const workbook = createAndFillWorkbook();await workbook.xlsx.writeFile(filename);// 写入流await workbook.xlsx.write(stream);// 写入 bufferconst buffer = await workbook.xlsx.writeBuffer(); CSV⬆读 CSV⬆读取 CSV 文件时支持的选项。 属性 是否需要 类型 描述 dateFormats N Array 指定 dayjs 的日期编码格式。 map N Function 自定义Array.prototype.map() 回调函数，用于处理数据。 sheetName N String 指定工作表名称。 parserOptions N Object parseOptions 选项 @fast-csv/format 模块以写入 csv 数据。 // 从文件读取const workbook = new Excel.Workbook();const worksheet = await workbook.csv.readFile(filename);// ... 使用 workbook 或 worksheet// 从流中读取const workbook = new Excel.Workbook();const worksheet = await workbook.csv.read(stream);// ... 使用 workbook 或 worksheet// 从带有欧洲日期的文件中读取const workbook = new Excel.Workbook();const options = &#123; dateFormats: [&#x27;DD/MM/YYYY&#x27;],&#125;;const worksheet = await workbook.csv.readFile(filename, options);// ... 使用 workbook 或 worksheet// 从具有自定义值解析的文件中读取const workbook = new Excel.Workbook();const options = &#123; map(value, index) &#123; switch (index) &#123; case 0: // 第1列是字符串 return value; case 1: // 第2列是日期 return new Date(value); case 2: // 第3列是公式值的JSON return JSON.parse(value); default: // 其余的是数字 return parseFloat(value); &#125; &#125;, // https://c2fo.io/fast-csv/docs/parsing/options parserOptions: &#123; delimiter: &#x27;\\t&#x27;, quote: false, &#125;,&#125;;const worksheet = await workbook.csv.readFile(filename, options);// ... 使用 workbook 或 worksheet CSV 解析器使用 fast-csv 读取 CSV 文件。传递给上述写入函数的选项中的 formatterOptions 将传递给 @fast-csv/format 模块以写入 csv 数据。 有关详细信息，请参阅 fast-csv README.md。 使用 npm 模块 dayjs 解析日期。如果未提供 dateFormats 数组，则使用以下 dateFormats： ‘YYYY-MM-DD[T]HH:mm:ss’ ‘MM-DD-YYYY’ ‘YYYY-MM-DD’ 请参阅 dayjs CustomParseFormat 插件，以获取有关如何构造 dateFormat 的详细信息。 写 CSV⬆写入 CSV 文件时支持的选项。 属性 是否需要 类型 描述 dateFormat N String 指定 dayjs 的日期编码格式。 dateUTC N Boolean 指定 ExcelJS 是否使用dayjs.utc()转换时区以解析日期。 encoding N String 指定文件编码格式。 includeEmptyRows N Boolean 指定是否可以写入空行。 map N Function 自定义Array.prototype.map() 回调函数，用于处理行值。 sheetName N String 指定工作表名称。 sheetId N Number 指定工作表 ID。 formatterOptions N Object formatterOptions 选项 @fast-csv/format 模块写入 csv 数据。 // 写入文件const workbook = createAndFillWorkbook();await workbook.csv.writeFile(filename);// 写入流// 请注意，您需要提供 sheetName 或 sheetId 以正确导入到 csvawait workbook.csv.write(stream, &#123; sheetName: &#x27;Page name&#x27; &#125;);// 使用欧洲日期时间写入文件const workbook = new Excel.Workbook();const options = &#123; dateFormat: &#x27;DD/MM/YYYY HH:mm:ss&#x27;, dateUTC: true, // 呈现日期时使用 utc&#125;;await workbook.csv.writeFile(filename, options);// 使用自定义值格式写入文件const workbook = new Excel.Workbook();const options = &#123; map(value, index) &#123; switch (index) &#123; case 0: // 第1列是字符串 return value; case 1: // 第2列是日期 return dayjs(value).format(&#x27;YYYY-MM-DD&#x27;); case 2: // 第3列是一个公式，只写结果 return value.result; default: // 其余的是数字 return value; &#125; &#125;, // https://c2fo.io/fast-csv/docs/formatting/options formatterOptions: &#123; delimiter: &#x27;\\t&#x27;, quote: false, &#125;,&#125;;await workbook.csv.writeFile(filename, options);// 写入新 bufferconst buffer = await workbook.csv.writeBuffer(); CSV 解析器使用 fast-csv 编写 CSV 文件。传递给上述写入函数的选项中的 formatterOptions 将传递给 @fast-csv/format 模块以写入 csv 数据。有关详细信息，请参阅 fast-csv README.md。 日期使用 npm 模块 dayjs 格式化。如果未提供 dateFormat，则使用 dayjs.ISO_8601。编写 CSV 时，您可以提供布尔值 dateUTC 为 true，以使 ExcelJS 解析日期，而无需使用 dayjs.utc() 自动转换时区。 流式 I/O⬆上面记录的文件 I/O 需要在内存中建立整个工作簿，然后才能写入文件。虽然方便，但是由于所需的内存量，它可能会限制文档的大小。 流写入器（或读取器）在生成工作簿或工作表数据时对其进行处理，然后将其转换为文件形式。通常，这在内存上效率要高得多，因为最终的内存占用量，甚至中间的内存占用量都比文档版本要紧凑得多，尤其是当您考虑到行和单元格对象一旦提交就被销毁时，尤其如此。 流式工作簿和工作表的接口几乎与文档版本相同，但实际存在一些细微差别： 将工作表添加到工作簿后，将无法将其删除。 提交行后，将无法再访问该行，因为该行将从工作表中删除。 不支持 unMergeCells()。 请注意，可以在不提交任何行的情况下构建整个工作簿。提交工作簿后，所有添加的工作表（包括所有未提交的行）将自动提交。但是，在这种情况下，与文档版本相比收效甚微。 流式 XLSX⬆流式 XLSX 写入器⬆流式 XLSX 写入器在 ExcelJS.stream.xlsx 命名空间中可用。 构造函数采用带有以下字段的可选 options 对象： 字段 描述 stream 指定要写入 XLSX 工作簿的可写流。 filename 如果未指定流，则此字段指定要写入 XLSX 工作簿的文件的路径。 useSharedStrings 指定是否在工作簿中使用共享字符串。默认为 false useStyles 指定是否将样式信息添加到工作簿。样式会增加一些性能开销。默认为 false zip ExcelJS 内部传递给 Archiver 的 Zip 选项。默认值为 undefined 如果在选项中未指定 stream 或 filename，则工作簿编写器将创建一个 StreamBuf 对象，该对象将 XLSX 工作簿的内容存储在内存中。可以通过属性 workbook.stream 访问此 StreamBuf 对象，该对象可用于通过 stream.read() 直接访问字节，或将内容通过管道传输到另一个流。 // 使用样式和共享字符串构造流式 XLSX 工作簿编写器const options = &#123; filename: &#x27;./streamed-workbook.xlsx&#x27;, useStyles: true, useSharedStrings: true,&#125;;const workbook = new Excel.stream.xlsx.WorkbookWriter(options); 通常，流式 XLSX 写入器的接口与上述文档工作簿（和工作表）相同，实际上行，单元格和样式对象是相同的。 但是有一些区别… 构造 如上所示，WorkbookWriter 通常将要求在构造函数中指定输出流或文件。 提交数据 当工作表行准备就绪时，应将其提交，以便可以释放行对象和内容。通常，这将在添加每一行时完成… worksheet .addRow(&#123; id: i, name: theName, etc: someOtherDetail, &#125;) .commit(); WorksheetWriter 在添加行时不提交行的原因是允许单元格跨行合并： worksheet.mergeCells(&#x27;A1:B2&#x27;);worksheet.getCell(&#x27;A1&#x27;).value = &#x27;I am merged&#x27;;worksheet.getCell(&#x27;C1&#x27;).value = &#x27;I am not&#x27;;worksheet.getCell(&#x27;C2&#x27;).value = &#x27;Neither am I&#x27;;worksheet.getRow(2).commit(); // now rows 1 and two are committed. 每个工作表完成后，还必须提交： // 完成添加数据。 提交工作表worksheet.commit(); 要完成 XLSX 文档，必须提交工作簿。 如果未提交工作簿中的任何工作表，则将在工作簿提交中自动提交它们。 // 完成 workbook.await workbook.commit();// ... 流已被写入 流式 XLSX 阅读器⬆流式 XLSX 工作簿阅读器可以在 ExcelJS.stream.xlsx 命名空间中找到。 构造函数包含必需的输入参数和可选的 options 参数: Argument Description input (必需的) 指定从中读取 XLSX 工作簿的文件或可读流的名称 options (可选的) 指定如何处理读取解析期间发生的事件类型 options.entries 指定是否去触发事件(&#39;emit&#39;)或者不发出事件(&#39;ignore&#39;)，默认值是&#39;emit&#39; options.sharedStrings 指定是否去缓存(&#39;cache&#39;)共享字符串，将其插入到相应的单元格值中，或者是否去触发(&#39;emit&#39;)或忽略(&#39;ignore&#39;)它们，在这两种情况下，单元格值都将是对共享字符串索引的引用。默认值是&#39;cache&#39; options.hyperlinks 指定是否去缓存超链接(&#39;cache&#39;)，将其插入到相应的单元格值中，是否去触发(&#39;emit&#39;)或忽略(&#39;ignore&#39;)它们。默认值是&#39;cache&#39; options.styles 指定是否去缓存样式(&#39;cache&#39;)，将其插入到相应的行或单元格值中，或是否忽略(&#39;忽略&#39;)它们。默认值是&#39;cache&#39; options.worksheets 指定是否去触发(&#39;emit&#39;)或忽略(&#39;ignore&#39;)工作表。默认值是&#39;emit&#39; const workbook = new ExcelJS.stream.xlsx.WorkbookReader(&#x27;./file.xlsx&#x27;);for await (const worksheetReader of workbookReader) &#123; for await (const row of worksheetReader) &#123; // ... &#125;&#125; 请注意，由于性能原因，worksheetReader返回一个行数组，而不是单独返回每一行: https://github.com/nodejs/node/issues/31979 迭代遍历所有事件⬆工作簿上的事件是 ‘worksheet’、’shared-strings’ 和 ‘hyperlinks’。 工作表上的事件是 ‘row’ 和 ‘hyperlinks’. const options = &#123; sharedStrings: &#x27;emit&#x27;, hyperlinks: &#x27;emit&#x27;, worksheets: &#x27;emit&#x27;,&#125;;const workbook = new ExcelJS.stream.xlsx.WorkbookReader(&#x27;./file.xlsx&#x27;, options);for await (const &#123; eventType, value &#125; of workbook.parse()) &#123; switch (eventType) &#123; case &#x27;shared-strings&#x27;: // 值是共享字符串 case &#x27;worksheet&#x27;: // 值是worksheetReader case &#x27;hyperlinks&#x27;: // 值是hyperlinksReader &#125;&#125; 可读流⬆我们强烈建议使用异步迭代，但我们也公开了流接口以实现向后兼容性。 const options = &#123; sharedStrings: &#x27;emit&#x27;, hyperlinks: &#x27;emit&#x27;, worksheets: &#x27;emit&#x27;,&#125;;const workbookReader = new ExcelJS.stream.xlsx.WorkbookReader( &#x27;./file.xlsx&#x27;, options);workbookReader.read();workbookReader.on(&#x27;worksheet&#x27;, worksheet =&gt; &#123; worksheet.on(&#x27;row&#x27;, row =&gt; &#123;&#125;);&#125;);workbookReader.on(&#x27;shared-strings&#x27;, sharedString =&gt; &#123; // ...&#125;);workbookReader.on(&#x27;hyperlinks&#x27;, hyperlinksReader =&gt; &#123; // ...&#125;);workbookReader.on(&#x27;end&#x27;, () =&gt; &#123; // ...&#125;);workbookReader.on(&#x27;error&#x27;, err =&gt; &#123; // ...&#125;); 浏览器⬆该库的一部分已被隔离，并经过测试可在浏览器环境中使用。 由于工作簿读写器的流式传输性质，因此未包括这些内容。只能使用基于文档的工作簿（有关详细信息，请参见 创建工作簿）。 例如，在浏览器中使用 ExcelJS 的代码可查看 github 中的 spec / browser 文件夹。 预捆绑⬆以下文件已预先捆绑在一起，并包含在 dist 文件夹中。 exceljs.js exceljs.min.js 值类型⬆支持以下值类型。 Null 值⬆Enum: Excel.ValueType.Null 空值表示没有值，通常在写入文件时将不存储（合并的单元格除外）。可用于从单元格中删除该值。例如： worksheet.getCell(&#x27;A1&#x27;).value = null; 合并单元格⬆Enum: Excel.ValueType.Merge 合并单元格是其值绑定到另一个“主”单元格的单元格。分配给合并单元将导致修改单元格。 数字值⬆Enum: Excel.ValueType.Number 一个数字值。 例如： worksheet.getCell(&#x27;A1&#x27;).value = 5;worksheet.getCell(&#x27;A2&#x27;).value = 3.14159; 字符串值⬆Enum: Excel.ValueType.String 一个简单的文本字符串。 例如： worksheet.getCell(&#x27;A1&#x27;).value = &#x27;Hello, World!&#x27;; 日期值⬆Enum: Excel.ValueType.Date 日期值，由 JavaScript Date 类型表示。 例如： worksheet.getCell(&#x27;A1&#x27;).value = new Date(2017, 2, 15); 超链接值⬆Enum: Excel.ValueType.Hyperlink 具有文本和链接值的 URL。 例如： // 链接到网络worksheet.getCell(&#x27;A1&#x27;).value = &#123; text: &#x27;www.mylink.com&#x27;, hyperlink: &#x27;http://www.mylink.com&#x27;, tooltip: &#x27;www.mylink.com&#x27;,&#125;;// 内部链接worksheet.getCell(&#x27;A1&#x27;).value = &#123; text: &#x27;Sheet2&#x27;, hyperlink: &quot;#&#x27;Sheet2&#x27;!A1&quot; &#125;; 公式值⬆Enum: Excel.ValueType.Formula 一个 Excel 公式，用于即时计算值。请注意，虽然单元格类型将为“公式”，但该单元格可能具有一个有效类型值，该值将从结果值中得出。 请注意，ExcelJS 无法处理公式以生成结果，必须提供该公式。 例如： worksheet.getCell(&#x27;A3&#x27;).value = &#123; formula: &#x27;A1+A2&#x27;, result: 7 &#125;; 单元格还支持便捷的获取器，以访问公式和结果： worksheet.getCell(&#x27;A3&#x27;).formula === &#x27;A1+A2&#x27;;worksheet.getCell(&#x27;A3&#x27;).result === 7; 共享公式⬆共享的公式通过减少工作表 xml 中文本的重复来增强 xlsx 文档的压缩。范围中左上角的单元格是指定的母版，它将保留该范围内的所有其他单元格都将引用的公式。然后，其他“从属”单元格可以引用此主单元格，而不必再次重新定义整个公式。请注意，主公式将以常用的 Excel 方式转换为从属单元格，以便对其他单元格的引用将根据从属单元相对于主单元的偏移量向右下移。例如：如果主单元格 A2 具有引用 A1 的公式，则如果单元格 B2 共享 A2 的公式，则它将引用 B1。 可以将主公式与该范围内的从属单元格一起分配给该单元格 worksheet.getCell(&#x27;A2&#x27;).value = &#123; formula: &#x27;A1&#x27;, result: 10, shareType: &#x27;shared&#x27;, ref: &#x27;A2:B3&#x27;,&#125;; 可以使用新的值形式将共享公式分配给单元格： worksheet.getCell(&#x27;B2&#x27;).value = &#123; sharedFormula: &#x27;A2&#x27;, result: 10 &#125;; 这指定单元格 B2 是将从 A2 中的公式派生的公式，其结果为 10。 公式便捷获取器会将 A2 中的公式转换为 B2 中应具有的公式： expect(worksheet.getCell(&#x27;B2&#x27;).formula).to.equal(&#x27;B1&#x27;); 可以使用 fillFormula 方法将共享的公式分配到工作表中： // 将 A1 设置为起始编号worksheet.getCell(&#x27;A1&#x27;).value = 1;// 从 A1 开始以递增计数将 A2 填充到 A10worksheet.fillFormula(&#x27;A2:A10&#x27;, &#x27;A1+1&#x27;, [2, 3, 4, 5, 6, 7, 8, 9, 10]); fillFormula 也可以使用回调函数来计算每个单元格的值 // 从A1开始以递增计数将 A2 填充到 A100worksheet.fillFormula(&#x27;A2:A100&#x27;, &#x27;A1+1&#x27;, (row, col) =&gt; row); 公式类型⬆要区分真正的和转换后的公式单元格，请使用 FormulaType getter： worksheet.getCell(&#x27;A3&#x27;).formulaType === Enums.FormulaType.Master;worksheet.getCell(&#x27;B3&#x27;).formulaType === Enums.FormulaType.Shared; 公式类型具有以下值： 名称 值 Enums.FormulaType.None 0 Enums.FormulaType.Master 1 Enums.FormulaType.Shared 2 数组公式⬆在 Excel 中表示共享公式的一种新方法是数组公式。以这种形式，主单元格是唯一包含与公式有关的任何信息的单元格。它包含 shareType ‘array’ 以及适用于其的单元格范围以及将要复制的公式。其余单元格是具有常规值的常规单元格。 注意：数组公式不会以共享公式的方式转换。因此，如果主单元 A2 引用 A1，则从单元 B2 也将引用 A1。 例如： // 将数组公式分配给 A2:B3worksheet.getCell(&#x27;A2&#x27;).value = &#123; formula: &#x27;A1&#x27;, result: 10, shareType: &#x27;array&#x27;, ref: &#x27;A2:B3&#x27;,&#125;;// 可能没有必要填写工作表中的其余值 fillFormula 方法也可以用于填充数组公式 // 用数组公式 &quot;A1&quot; 填充 A2:B3worksheet.fillFormula(&#x27;A2:B3&#x27;, &#x27;A1&#x27;, [1, 1, 1, 1], &#x27;array&#x27;); 富文本值⬆Enum: Excel.ValueType.RichText 样式丰富的文本。 例如： worksheet.getCell(&#x27;A1&#x27;).value = &#123; richText: [&#123; text: &#x27;This is &#x27; &#125;, &#123; font: &#123; italic: true &#125;, text: &#x27;italic&#x27; &#125;],&#125;; 布尔值⬆Enum: Excel.ValueType.Boolean 例如： worksheet.getCell(&#x27;A1&#x27;).value = true;worksheet.getCell(&#x27;A2&#x27;).value = false; 错误值⬆Enum: Excel.ValueType.Error 例如： worksheet.getCell(&#x27;A1&#x27;).value = &#123; error: &#x27;#N/A&#x27; &#125;;worksheet.getCell(&#x27;A2&#x27;).value = &#123; error: &#x27;#VALUE!&#x27; &#125;; 当前有效的错误文本值为： 名称 值 Excel.ErrorValue.NotApplicable #N/A Excel.ErrorValue.Ref #REF! Excel.ErrorValue.Name #NAME? Excel.ErrorValue.DivZero #DIV/0! Excel.ErrorValue.Null #NULL! Excel.ErrorValue.Value #VALUE! Excel.ErrorValue.Num #NUM! 接口变化⬆我们会尽一切努力创建一个良好的，一致的接口，该接口不会在版本之间不兼容，但令人遗憾的是，为了实现更大的利益，有时需要进行一些更改。 0.1.0⬆Worksheet.eachRow⬆在 Worksheet.eachRow 的回调函数中的参数已被交换和更改；它是 function(rowNumber，rowValues)，现在是 function(row，rowNumber)，使它的外观更像 underscore(_.each)方法，并且行对象优先于行号。 Worksheet.getRow⬆此函数已从返回稀疏的单元格数组更改为返回 Row 对象。这样可以访问行属性，并有助于管理行样式等。 仍可通过 Worksheet.getRow(rowNumber).values; 获得稀疏的单元格值的数组。 0.1.1⬆cell.model⬆cell.styles 重命名为 cell.style 0.2.44⬆从 Bluebird 切换到 Node 原生 Promise 的函数返回的 Promise 如果依赖 Bluebird 的额外功能，则可能会破坏调用代码。 为了减少这种情况的出现，在 0.3.0 中添加了以下两个更改： 默认情况下使用功能更全且仍与浏览器兼容的 promise lib。 该库支持 Bluebird 的许多功能，但占用空间少得多。 注入其他 Promise 实现的选项。有关更多详细信息，请参见配置部分。 配置⬆ExcelJS 现在支持对 Promise 库的依赖项注入。您可以通过在模块中包含以下代码来还原 Bluebird Promise。 ExcelJS.config.setValue(&#x27;promise&#x27;, require(&#x27;bluebird&#x27;)); 请注意：我已经使用 bluebird 专门测试了 ExcelJS（直到最近，这是它使用的库）。根据我所做的测试，它不适用于 Q。 注意事项⬆Dist 文件夹⬆在发布此模块之前，先对源代码进行编译和其他处理，然后再将它们放置在 dist/ 文件夹中。该自述文件标识两个文件-浏览器捆绑和压缩版本。除了在 package.json 中指定为 &quot;main&quot; 的文件外，不能保证 dist/ 文件夹的其他内容。 已知的问题⬆使用 Puppeteer 进行测试⬆该 lib 中包含的测试套件包括一个在无头浏览器中执行的小脚本，以验证捆绑的软件包。 在撰写本文时，其表现出该测试在 Windows Linux 子系统中不能很好地进行。 因此，可以通过存在名为 .disable-test-browser 的文件来禁用浏览器测试。 sudo apt-get install libfontconfig 拼接与合并⬆如果任何 splice 操作影响合并的单元格，则合并组将无法正确移动","updated":"2025-08-02T05:46:04.181Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"github、gitee自动部署hexo博客","date":"2023-06-14T03:57:13.000Z","path":"2023/06/14/2023-06-14-github-gitee-blog/","text":"使用 hexo 时，我们需要手动执行hexo deploy去部署博客代码，使用 gitee 部署博客时，因为 gitee 博客不会自动部署，我们需要手动点击部署按钮 针对上面 2 个问题我们使用 github actions 自动去执行相关代码 github 自动部署代码在创建之前，我们先需要手动创建主题的submodule # Add submodule$ git submodule add https://github.com/theme-next/hexo-theme-next themes/next# Get tags list$ cd themes/next$ git tag -l…v6.0.0v6.0.1v6.0.2...# Switch on v6.0.1 tagged release version$ git checkout tags/v6.0.1Note: checking out &#x27;tags/v6.0.1&#x27;.…HEAD is now at da9cdd2... Release v6.0.1# If you want to switch on latest release version without defining tag (optional)$ git checkout $(git describe --tags $(git rev-list --tags --max-count=1)) 如果没有打 tag，在 git submodule add之后， 直接提交代码即可 name: Hexo Deploy Automatically and update gitee deployon: push: branches: [dev] workflow_dispatch:jobs: deploy-blog: runs-on: ubuntu-latest steps: - name: Checkout Latest Version uses: actions/checkout@v2 # 需要提交创建对应的theme的submodule - name: Checkout Theme run: | git submodule init git submodule update - name: Setup Node Env uses: actions/setup-node@v1 # Caching dependencies to speed up workflows. (GitHub will remove any cache entries that have not been accessed in over 7 days.) - name: Cache Node Dependencies id: cache uses: actions/cache@v1 with: path: node_modules key: $&#123;&#123;runner.OS&#125;&#125;-npm-caches-$&#123;&#123; hashFiles(&#x27;package-lock.json&#x27;) &#125;&#125; - name: Install Dependencies if: steps.cache.outputs.cache-hit != &#x27;true&#x27; run: npm install # 填写自己的github username、email - name: Deploy env: SSH_KEY: $&#123;&#123;secrets.GITEE_RSA_PRIVATE_KEY&#125;&#125; run: | export TZ=&#x27;Asia/Shanghai&#x27; mkdir -p ~/.ssh/ echo &quot;$SSH_KEY&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name &#x27;[username]&#x27; git config --global user.email &#x27;[email]&#x27; hexo clean hexo generate hexo deploy - name: Sync to Gitee uses: wearerequired/git-mirror-action@master env: # 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY SSH_PRIVATE_KEY: $&#123;&#123; secrets.GITEE_RSA_PRIVATE_KEY &#125;&#125; with: # 注意替换为你的 GitHub 源仓库地址 source-repo: git@github.com:luckyship/luckyship.github.io.git # 注意替换为你的 Gitee 目标仓库地址 destination-repo: git@gitee.com:luckyship/luckyship.git - name: Build Gitee Pages uses: yanglbme/gitee-pages-action@main with: # 注意替换为你的 Gitee 用户名 gitee-username: luckyship # 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD gitee-password: $&#123;&#123; secrets.GITEE_PASSWORD &#125;&#125; # 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错 gitee-repo: luckyship/luckyship # 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在） branch: main GITEE_RSA_PRIVATE_KEY使用的是私钥， 在~/.ssh/id_rsa 是私钥, 如何生成公钥和私钥，参考git 参考gitee-pages-actionhexo-action","updated":"2025-08-02T05:46:04.181Z","tags":[{"name":"hexo","slug":"hexo","permalink":"https://luckyship.github.io/tags/hexo/"}]},{"title":"angular中的变化检测-zone.js","date":"2023-06-06T07:58:39.000Z","path":"2023/06/06/2023-06-06-angular-detect-changes/","text":"Zone 是跨异步任务而持久存在的执行上下文。你可以将其视为 JavaScript VM 中的线程本地存储。本指南介绍了如何使用 Angular 的 的 NgZone 自动检测组件中的更改以更新 HTML。 变更检测的基础要理解 NgZone 的好处，重要的是要清楚地了解什么是变更检测以及它的工作原理。 在 Angular 中显示和更新数据在 Angular 中，你可以通过把 HTML 模板中的控件绑定到 Angular 组件的属性来显示数据。 // src/app/app.component.tsimport &#123; Component &#125; from &quot;@angular/core&quot;;@Component(&#123; selector: &quot;app-root&quot;, template: ` &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;h2&gt;My favorite hero is: &#123;&#123; myHero &#125;&#125;&lt;/h2&gt; `,&#125;)export class AppComponent &#123; title = &quot;Tour of Heroes&quot;; myHero = &quot;Windstorm&quot;;&#125; 另外，你也可以将 DOM 事件绑定到 Angular 组件中的方法。在此类方法中，你还可以更新 Angular 组件的属性，该属性将更新模板中显示的相应数据。 // src/app/click-me.component.ts@Component(&#123; selector: &quot;app-click-me&quot;, template: ` &lt;button type=&quot;button&quot; (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt; &#123;&#123; clickMessage &#125;&#125;`,&#125;)export class ClickMeComponent &#123; clickMessage = &quot;&quot;; onClickMe() &#123; this.clickMessage = &quot;You are my hero!&quot;; &#125;&#125; 在以上两个示例中，组件的代码仅更新组件的属性。但是，HTML 也会自动更新。本指南介绍了 Angular 如何以及何时根据 Angular 组件中的数据渲染 HTML。 使用普通（Plain）JavaScript 检测更改为了阐明如何检测到更改和更新值，请考虑以下用普通 JavaScript 编写的代码。 &lt;html&gt; &lt;div id=&quot;dataDiv&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;updateData&lt;/button&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; let value = &quot;initialValue&quot;; // initial rendering detectChange(); function renderHTML() &#123; document.getElementById(&quot;dataDiv&quot;).innerText = value; &#125; function detectChange() &#123; const currentValue = document.getElementById(&quot;dataDiv&quot;).innerText; if (currentValue !== value) &#123; renderHTML(); &#125; &#125; // Example 1: update data inside button click event handler document.getElementById(&quot;btn&quot;).addEventListener(&quot;click&quot;, () =&gt; &#123; // update value value = &quot;button update value&quot;; // call detectChange manually detectChange(); &#125;); // Example 2: HTTP Request const xhr = new XMLHttpRequest(); xhr.addEventListener(&quot;load&quot;, function () &#123; // get response from server value = this.responseText; // call detectChange manually detectChange(); &#125;); xhr.open(&quot;GET&quot;, serverUrl); xhr.send(); // Example 3: setTimeout setTimeout(() =&gt; &#123; // update value inside setTimeout callback value = &quot;timeout update value&quot;; // call detectChange manually detectChange(); &#125;, 100); // Example 4: Promise.then Promise.resolve(&quot;promise resolved a value&quot;).then((v) =&gt; &#123; // update value inside Promise thenCallback value = v; // call detectChange manually detectChange(); &#125;, 100); // Example 5: some other asynchronous APIs document.getElementById(&quot;canvas&quot;).toBlob((blob) =&gt; &#123; // update value when blob data is created from the canvas value = `value updated by canvas, size is $&#123;blob.size&#125;`; // call detectChange manually detectChange(); &#125;); &lt;/script&gt;&lt;/html&gt; 更新数据后，需要调用 detectChange() 来检查数据是否已更改。如果数据已更改，则渲染 HTML 以反映更新的数据。 在 Angular 中，此步骤是不必要的。每当你更新数据时，你的 HTML 都会自动更新。 应用何时更新 HTML要了解变更检测的工作原理，请首先考虑应用程序何时需要更新 HTML。通常，会由于以下原因之一而发生更新： 组件初始化。比如，当引导 Angular 应用程序时，Angular 会加载引导组件并触发 ApplicationRef.tick() 来调用变更检测和视图渲染。 事件监听器。DOM 事件侦听器可以更新 Angular 组件中的数据，还可以触发变更检测，如下例所示。 // src/app/click-me.component.ts@Component(&#123; selector: &quot;app-click-me&quot;, template: ` &lt;button type=&quot;button&quot; (click)=&quot;onClickMe()&quot;&gt;Click me!&lt;/button&gt; &#123;&#123; clickMessage &#125;&#125;`,&#125;)export class ClickMeComponent &#123; clickMessage = &quot;&quot;; onClickMe() &#123; this.clickMessage = &quot;You are my hero!&quot;; &#125;&#125; HTTP 数据请求。你还可以通过 HTTP 请求从服务器获取数据。比如： @Component(&#123; selector: &#x27;app-root&#x27;, template: &#x27;&lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&#x27;;&#125;)export class AppComponent implements OnInit &#123; data = &#x27;initial value&#x27;; serverUrl = &#x27;SERVER_URL&#x27;; constructor(private httpClient: HttpClient) &#123;&#125; ngOnInit() &#123; this.httpClient.get(this.serverUrl).subscribe(response =&gt; &#123; // user does not need to trigger change detection manually this.data = response.data; &#125;); &#125;&#125; 宏任务，比如 setTimeout() 或 setInterval()。你还可以在诸如 setTimeout() macroTask 的回调函数中更新数据。比如： @Component(&#123; selector: &#x27;app-root&#x27;, template: &#x27;&lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&#x27;;&#125;)export class AppComponent implements OnInit &#123; data = &#x27;initial value&#x27;; ngOnInit() &#123; setTimeout(() =&gt; &#123; // user does not need to trigger change detection manually this.data = &#x27;value updated&#x27;; &#125;); &#125;&#125; 微任务，比如 Promise.then()。其他异步 API（比如 fetch）会返回 Promise 对象，因此 then() 回调函数也可以更新数据。比如： @Component(&#123; selector: &#x27;app-root&#x27;, template: &#x27;&lt;div&gt;&#123;&#123;data&#125;&#125;&lt;/div&gt;&#x27;;&#125;)export class AppComponent implements OnInit &#123; data = &#x27;initial value&#x27;; ngOnInit() &#123; Promise.resolve(1).then(v =&gt; &#123; // user does not need to trigger change detection manually this.data = v; &#125;); &#125;&#125; 其他异步操作。除了 addEventListener()，setTimeout() 和 Promise.then()，还有其他一些操作可以异步更新数据。比如 WebSocket.onmessage() 和 Canvas.toBlob()。 前面的列表包含应用程序可能会在其中更改数据的最常见场景。只要 Angular 检测到数据可能已更改，就会运行变更检测。变更检测的结果是 DOM 被这些新数据更新。Angular 会以不同的方式检测变化。对于组件初始化，Angular 调用显式变更检测。对于异步操作，Angular 会使用 Zone 在数据可能被修改的地方检测变化，并自动运行变更检测。 Zone 和执行上下文Zone 提供了在异步任务之间持久存在的执行上下文。执行上下文是一个抽象概念，用于在当前执行的代码中保存有关环境的信息。考虑以下示例： const callback = function () &#123; console.log(&quot;setTimeout callback context is&quot;, this);&#125;;const ctx1 = &#123; name: &quot;ctx1&quot; &#125;;const ctx2 = &#123; name: &quot;ctx2&quot; &#125;;const func = function () &#123; console.log(&quot;caller context is&quot;, this); setTimeout(callback);&#125;;func.apply(ctx1);func.apply(ctx2); setTimeout() 回调中的 this 值可能会有所不同，具体取决于 setTimeout() 的调用时机。因此，你可能会在异步操作中丢失上下文。 The value of this in the callback of setTimeout() might differ depending on when setTimeout() is called.Thus, you can lose the context in asynchronous operations. Zone 提供了不同于 this 的新的 Zone 上下文，该 Zone 上下文在异步操作中保持不变。在下例中，新的 Zone 上下文称为 zoneThis。 zone.run(() =&gt; &#123; // now you are in a zone expect(zoneThis).toBe(zone); setTimeout(function () &#123; // the zoneThis context will be the same zone // when the setTimeout is scheduled expect(zoneThis).toBe(zone); &#125;);&#125;); 新的上下文 zoneThis 可以从 setTimeout() 的回调函数中检索出来，这个上下文和调用 setTimeout() 时的上下文是一样的。要获取此上下文，可以调用 Zone.current。 Zone 和异步生命周期钩子Zone.js 可以创建在异步操作中持久存在的上下文，并为异步操作提供生命周期钩子。 const zone = Zone.current.fork(&#123; name: &quot;zone&quot;, onScheduleTask: function (delegate, curr, target, task) &#123; console.log(&quot;new task is scheduled:&quot;, task.type, task.source); return delegate.scheduleTask(target, task); &#125;, onInvokeTask: function (delegate, curr, target, task, applyThis, applyArgs) &#123; console.log(&quot;task will be invoked:&quot;, task.type, task.source); return delegate.invokeTask(target, task, applyThis, applyArgs); &#125;, onHasTask: function (delegate, curr, target, hasTaskState) &#123; console.log(&quot;task state changed in the zone:&quot;, hasTaskState); return delegate.hasTask(target, hasTaskState); &#125;, onInvoke: function (delegate, curr, target, callback, applyThis, applyArgs) &#123; console.log(&quot;the callback will be invoked:&quot;, callback); return delegate.invoke(target, callback, applyThis, applyArgs); &#125;,&#125;);zone.run(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;timeout callback is invoked.&quot;); &#125;);&#125;); 上面的示例创建了一个具有多个钩子的 Zone。 当任务状态更改时，就会触发 onXXXTask 钩子。Zone 任务的概念与 JavaScript VM 中任务的概念非常相似： macroTask：比如 setTimeout() microTask：比如 Promise.then() eventTask：比如 element.addEventListener()eventTask: such as element.addEventListener() 这些钩子在以下情况下触发： 钩子 详情 onScheduleTask 在计划新的异步任务时触发，比如调用 setTimeout() 时。 onInvokeTask 在异步任务即将执行时触发，比如 setTimeout() 的回调即将执行时。 onHasTask 当 Zone 内的一种任务的状态从稳定变为不稳定或从不稳定变为稳定时触发。状态“稳定”表示该 Zone 内没有任务，而“不稳定”表示在该 Zone 中计划了新任务。 onInvoke 将在 Zone 中执行同步函数时触发。 使用这些钩子，Zone 可以监视 Zone 内所有同步和异步操作的状态。 上面的示例返回以下输出： the callback will be invoked: () =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;timeout callback is invoked.&#x27;); &#125;);&#125;new task is scheduled: macroTask setTimeouttask state changed in the zone: &#123; microTask: false, macroTask: true, eventTask: false, change: &#x27;macroTask&#x27; &#125;task will be invoked macroTask: setTimeouttimeout callback is invoked.task state changed in the zone: &#123; microTask: false, macroTask: false, eventTask: false, change: &#x27;macroTask&#x27; &#125; Zone 的所有函数都由一个名为 Zone.js 的库提供。该库通过猴子补丁拦截异步 API 来实现这些特性。 猴子补丁是一种在运行时添加或更改函数的默认行为而不更改源代码的技术。 Zone 的所有功能均由名为 Zone.js 的库提供。该库通过猴子补丁拦截异步 API 来实现这些功能。猴子补丁是一种在运行时添加或修改函数默认行为而无需更改源代码的技术。 NgZone虽然 Zone.js 可以监视同步和异步操作的所有状态，但 Angular 还提供了一项名为 NgZone 的服务。满足以下条件时，此服务会创建一个名为 angular 的 Zone 来自动触发变更检测。 当执行同步或异步功能时 已经没有已计划的 microTask NgZone run() 和 runOutsideOfAngular()Zone 处理大多数异步 API，比如 setTimeout()、Promise.then() 和 addEventListener()。有关完整列表，请参见 Zone 模块的文档。在这些异步 API 中，你无需手动触发变更检测。 有些第三方 API 没有被 Zone 处理。在这种情况下，[NgZone](https://angular.cn/api/core/NgZone) 服务提供了 run() 方法，该方法允许你在 angular Zone 中执行函数。此函数以及该函数中的所有异步操作会在正确的时间自动触发变更检测。 export class AppComponent implements OnInit &#123; constructor(private ngZone: NgZone) &#123;&#125; ngOnInit() &#123; // New async API is not handled by Zone, so you need to use ngZone.run() // to make the asynchronous operation callback in the Angular zone and // trigger change detection automatically. someNewAsyncAPI(() =&gt; &#123; this.ngZone.run(() =&gt; &#123; // update the data of the component &#125;); &#125;); &#125;&#125; 默认情况下，所有异步操作都在 Angular Zone 内，这会自动触发变更检测。另一个常见的情况是你不想触发变更检测。在这种情况下，你可以使用另一个 [NgZone](https://angular.cn/api/core/NgZone) 方法：runOutsideAngular()。 设置 Zone.js为了使 Zone.js 在 Angular 中可用，你需要导入 zone.js 包。如果使用的是 Angular CLI，则此步骤将自动完成，并且你会在 src/polyfills.ts 中看到以下行： /*************************************************************************************************** * Zone JS is required by default for Angular itself. */import &quot;zone.js&quot;; // Included with Angular CLI. 在导入 zone.js 软件包之前，你可以做如下配置： 禁用一些异步 API 的猴子补丁，以获得更好的性能。比如，你可以禁用 requestAnimationFrame() 的猴子补丁，这样 requestAnimationFrame() 的回调就不会触发变更检测。如果你的应用程序不会在 requestAnimationFrame() 回调中更新任何数据，则这种方式很有用。 指定某些 DOM 事件不在 Angular Zone 内运行；比如，为了防止 mousemove 或 scroll 事件来触发变更检测。 还可以更改另外几个设置。要进行这些更改，你需要创建一个 zone-flags.ts 文件，如下所示。 // disable patching requestAnimationFrame(window as any).__Zone_disable_requestAnimationFrame = true;// disable patching specified eventNames(window as any).__zone_symbol__UNPATCHED_EVENTS = [&quot;scroll&quot;, &quot;mousemove&quot;]; 有关可以配置的内容的更多信息，请参阅Zone.js文档。 NoopZoneZone 能帮助 Angular 知道何时要触发变更检测，并使开发人员专注于应用开发。默认情况下，Zone 已加载且无需其他配置即可工作。也不是一定要用 Zone 才能使 Angular 工作。相反，你也可以选择自己触发变更检测。 要删除 Zone.js，请进行以下更改。 从 polyfills.ts 中移除对 zone.js 的导入 /*************************************************************************************************** * Zone JS is required by default for Angular itself. */// import &#x27;zone.js&#x27;; // Included with Angular CLI. 在 src/main.ts 中使用 noop Zone 引导 Angular： platformBrowserDynamic() .bootstrapModule(AppModule, &#123; ngZone: &quot;noop&quot; &#125;) .catch((err) =&gt; console.error(err)); 转载ngZone","updated":"2025-08-02T05:46:04.181Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"什么是iconfont","date":"2023-06-05T05:41:43.000Z","path":"2023/06/05/2023-06-05-iconfont/","text":"iconfont 是什么： 顾名思义，IconFont 就是字体图标。严格地说，就是一种字体，但是，它们不包含字母或数字，而是包含符号和字形。您可以使用 CSS 设置样式，就像设置常规文本一样，这使得 IconFont 成为 Web 开发时图标的热门选择。 IconFont 的使用方式和 传统的 WebFont 如出一辙，又把大量的图标变成了一个字体文件，减少了请求数，而且有效减小请求体积。当一个网页有自己的图标字体库之后，可以复用在很多地方，减少很多二次开发成本。因此现代网页多会使用 IconFont 来展示图标，那么如何使用并且生成 IconFont 也就变成了前端开发人员必知必会的能力。 优缺点： 优点 可以方便地将任何 CSS 效果应用于它们。 因为它们是矢量图形，所以它们是可伸缩的。这意味着我们可以在不降低质量的情况下伸缩它们。 我们只需要发送一个或少量 HTTP 请求来加载它们，而不是像图片，可能需要多个 HTTP 请求。 由于尺寸小，它们加载速度快。 它们在所有浏览器中都得到支持（甚至支持到 IE6）。 缺点 不能用来显示复杂图像 通常只限于一种颜色，除非应用一些 CSS 技巧 字体图标通常是根据特定的网格设计的，例如 16x16, 32×32, 48×48等。如果由于某种原因将网格系统改为25×25，可能不会得到清晰的结果 **IconFont 原理** IconFont 的使用原理来自于 css 的 @font-face 属性。这个属性用来定义一个新的字体，基本用法如下： @font-face &#123; font-family: &lt;YourFontName&gt;; src: &lt;url&gt; [&lt;format&gt;],[&lt;source&gt; [&lt;format&gt;]], *; [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;];&#125; font-family：为载入的字体取名字。 src：[url]加载字体，可以是相对路径，可以是绝对路径，也可以是网络地址。 [format]定义的字体的格式，用来帮助浏览器识别。主要取值为：truetype(.ttf)、opentype（.otf）、truetype-aat、embedded-opentype(.eot)、svg(.svg)、woff(.woff)。 font-weight：定义加粗样式。 font-style：定义字体样式。 format 对应字体格式 **常见兼容性写法：** @font-face &#123; font-family: &quot;defineName&quot;; src: url(&quot;../fonts/custom-font.eot&quot;); src: url(&quot;../fonts/custom-font.eot?#iefix&quot;) format(&quot;embedded-opentype&quot;), url(&quot;../fonts/custom-font.woff&quot;) format(&quot;woff&quot;), url(&quot;../fonts/custom-font.ttf&quot;) format(&quot;truetype&quot;), url(&quot;../fonts/custom-font.svg#defineName&quot;) format(&quot;svg&quot;); font-weight: normal; font-style: normal;&#125; **iefix有何作用？** IE9 之前的版本没有按照标准解析字体声明，当 src 属性包含多个 url 时，它无法正确的解析而返回 404 错误，而其他浏览器会自动采用自己适用的 url。因此把仅 IE9 之前支持的 EOT 格式放在第一位，然后在 url 后加上 ?，这样 IE9 之前的版本会把问号之后的内容当作 url 的参数。 **至于 #iefix 的作用**，一是起到了注释的作用，二是可以将 url 参数变为锚点，减少发送给服务器的字符。 **为何有两个src？** 绝大多数情况下，第一个 src 是可以去掉的，除非需要支持 IE9 下的兼容模式。在 IE9 中可以使用 IE7 和 IE8 的模式渲染页面，微软修改了在兼容模式下的 CSS 解析器，导致使用 ? 的方案失效。由于 CSS 解释器是从下往上解析的，所以在上面添加一个不带问号的 src 属性便可以解决此问题。 **定义好自己的 font-face 后**，就有了新的 IconFont，给要使用这个 IconFont 的对象赋予对应的 font-family 即可。 .example &#123; font-family: &quot;defineName&quot;; content: &quot;/e103&quot;;&#125; 复制代码这个例子就会将 example 选中的元素渲染为 /e103 对应的 icon。","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://luckyship.github.io/tags/html/"}]},{"title":"css选择器大全","date":"2023-03-17T05:45:44.000Z","path":"2023/03/17/2023-03-17-css-selector/","text":"CSS 选择器在 CSS 中，选择器是选取需设置样式的元素的模式。 下面列举了所有常见的css选择器 选择器 例子 例子描述 .class .intro 选择 class=”intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id=”firstname” 的元素。 * * 选择所有元素。 element p 选择所有 &lt;p&gt; 元素。 element.class p.intro 选择 class=”intro” 的所有 &lt;p&gt; 元素。 element,element div, p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。 element&gt;element div &gt; p 选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。 element+element div + p 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。 element1~element2 p ~ ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 [attribute] [target] 选择带有 target 属性的所有元素。 [attribute=value] [target=_blank] 选择带有 target=”_blank” 属性的所有元素。 [_attribute_~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute|=value] [lang|=en] 选择 lang 属性值以 “en” 开头的所有元素。 [attribute_^=_value] a[href^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 [attribute$=value] a[href$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 [attribute_*=_value] a[href*=”w3school”] 选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 &lt;p&gt; 的内容之后插入内容。 ::before p::before 在每个 &lt;p&gt; 的内容之前插入内容。 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :default input:default 选择默认的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个被禁用的 &lt;input&gt; 元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :focus input:focus 选择获得焦点的 input 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 input 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 input 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"angular依赖注入","date":"2023-03-14T07:14:06.000Z","path":"2023/03/14/2023-03-14-angular-service-inject/","text":"掘金上看到一篇讲 angular 依赖注入 的文章，非常的细致，记录一下 依赖注入是前端开发者也是 Angular 开发者一道很难迈过去的坎，依赖注入到底是啥？为什么要依赖注入？Angular 的依赖注入怎么有那么多概念，看了官方文档一遍后感觉是懂了，但是过一段时间发现又不懂了，这是前端开发者普遍遇到的问题，我司的前端也一样，那么这篇文章尝试用更容易理解的语言全面解析一下 Angular 的依赖注入，内容有点多，可以先收藏观看。 Angular 官方文档关于依赖注入介绍的其实挺详细的，但是组织的语言过于官方，不易理解，其次就是文档太过分散，没有把依赖注入聚合在一起，有些核心的概念可能在示例中出现了解读，你很难在一个地方找到所有依赖注入的讲解。在开始之前，我简单列了一些关于 Angular 依赖注入的问题，如果你每个问题都非常了解可以划过这篇文章了。 依赖注入和控制反转(Ioc)的区别是什么？ providedIn: &#39;root&#39; ​ 的作用是什么，指定 root 的好处有哪些？ providedIn ​ 除了 root 外还可以设置哪些值？ 构造函数注入 constructor(heroService: HeroService) ​ 是依赖注入的简写，那么完整的写法是什么？ 依赖注入可以注入一个接口吗？ constructor(heroService: IHeroService) ​ 为什么？ useClass ​ 和 useExisting ​ 提供者的区别是什么？ providers: [ Logger ] ​ 这种写法 Logger ​ 使用的是什么类型的供应商？ DI Token 可以是字符串吗？如果可以如何注入？ providers ​ 与 viewProviders ​ 的区别是什么？ Injectable 、 Inject ​ 、 Injector ​ 和 Provider ​ 这些名词到底是什么？ ReflectiveInjector ​ 和 StaticInjector ​ 的区别是什么？为什么 Angular 在 V5 版本废弃了 ReflectiveInjector ​API？ 懒加载模块中的供应商和 AppModule ​ 中提供的供应商有什么区别？ 简单一张思维导图完整覆盖这篇文章的内容： 前言控制反转和依赖注入那么在开始正题之前，肯定要先理解依赖注入的概念，如果已经理解的同学可以忽略这一章节，一提起依赖注入，大家就会和控制反转联系在一起，我在看过很多文章之后发现知乎上的一个回答 Spring IoC 有什么好处呢？ 介绍的特别详细和易懂，大家不了解的可以阅读一下，简单总结一下就是： 软件只有到达了一定的复杂度才会需要各种设计原则和模式，那么依赖倒置原则（Dependency Inversion Principle ）就是为了解决软件模块之间的耦合性提出的一种思想，让大型软件变的可维护，高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。那么控制反转（Inversion of Control） 就是依赖倒置原则的一种代码设计思路，具体采用的方法就是所谓的依赖注入（Dependency Injection），通过依赖注入实现控制权的反转，除了依赖注入外，还有可以通过模板方法模式实现控制反转，那么所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的“控制”。 以下是一个通过构造函数注入的示例，那么除了构造函数注入外，还会有 setter 注入和接口注入。 class Logger &#123; log(message: string) &#123;&#125;&#125;class HeroesService &#123; constructor(logger: Logger) &#123;&#125;&#125;const logger = new Logger();const heroesService = new HeroesService(logger); 通过上述示例发现， HeroesService ​ 不直接创建 Logger ​ 类的实例，统一在外层创建后通过构造函数好传入 HeroesService ​ 如果我们的类成千上万，那么实例化类的工作变得相当繁琐，会有一大推样板代码，为了管理创建依赖工作，一般会使用 **控制反转容器(IoC Container) ** 进行管理。只需要通过如下一行代码即可实现 HeroesService ​ 的创建， IocContainer ​ 会通过 HeroesService ​ 的构造函数寻找 Logger ​ 的依赖并实例化。 const heroesService = IocContainer.get(HeroesService); 如果类很多，依赖层级比较深，那么 IocContainer 会帮我们统一管理依赖， IocContainer ​ 其实也叫注入器 Injector ​, 说的其实就是一回事，Angular 框架中叫 Injector ​。关于控制反转和依赖注入更多参考：Inversion of Control vs Dependency InjectionWikipedia Dependency Injection 依赖注入的优势： 更容易维护 协同合作 方便单元测试 松耦合 减少了样板代（Ioc 容器/注入器维护管理依赖） 扩展应用程序变得更加容易 依赖注入的缺点： 学习起来有点复杂 阅读代码变得抽象 依赖注入框架是通过反射或动态编程实现，导致 IDE 对“查找引用”，“显示调用层次结构”和安全重构变得困难 编译时错误被推送到运行时 为什么 Angular 有依赖注入那么 Angular 为什么会有依赖注入？前面我已经说过，只有程序到达一定的复杂度，才会需要各种设计模式和原则等工程化方法提升程序的可维护性，那么 Angular.js 起初是为了解决谷歌内部复杂中大型的前端应用，同时是一批 Java 程序打造的，所以首次在前端中大胆引入了依赖注入，那么 Angular 是基于 Angular.js 打造的新一代前端框架，所以延续了依赖注入特性，并改善了层级注入器，同时采用了更优雅的装饰器 API 形式。 服务和依赖注入的关系另外 Angular 为了解决数据共享和逻辑复用问题，引入了服务的概念，服务简单理解就是一个带有特性功能的类，Angular 提倡把与视图无关的逻辑抽取到服务中，这样可以让组件类更加精简、高效，组件的工作只管用户体验，把业务逻辑相关功能（比如：从服务器获取数据，验证用户输入或直接往控制台中写日志等）委托给各种服务，最后通过 Angular 的依赖注入，这些带有特定功能的服务类可以被任何组件注入并使用。Angular 依赖注入： 连接服务的桥梁，在需要的地方（组件/指令/其他服务）通过构造函数注入依赖的服务，依赖注入 + 服务的组合造就了使用 Angular 可以轻松组织复杂应用。 那么其他框架 React 和 Vue 有依赖注入吗？可以说有，也可以说没有，React 为了解决全局数据的共享问题，提出了 Context，那么创建好 Context 后需要在上层组件通过 &lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt; ​ 提供依赖值，然后在任何的子组件中通过 &lt;MyContext.Consumer&gt; ​ 进行消费（Vue 中也有类似的 provide ​ 和 inject ​），其实这可以狭隘的理解成最简单的依赖注入，只不过 Context 只解决了数据共享的问题，虽然也可以作为逻辑复用，但是官方不推荐，React 官方先后推出 Mixin、高阶组件、Render Props 以及最新的 Hooks 用来解决逻辑复用问题。 &lt;MyContext.Consumer&gt; &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/MyContext.Consumer&gt; 那么回到 Angular 框架来说，Angular 的服务 + 依赖注入完美解决了数据共享和逻辑复用问题，服务本质上和 React Hooks 没有太多的区别，只是 API 形态不一样，一个是通过函数形式一个是通过类+依赖注入，因为这两个框架的底层机制和思想不一样，导致了 API 表现形式的不同，但是最终都是在解决数据共享和逻辑复用的问题。 入门到高级那么接下来我会从依赖注入的基本使用 =&gt; 依赖提供者 =&gt; 多级注入器三个方面详细讲解一下。 基本使用在 Angular 中，通过 @angular/cli ​ 提供的命令 ng generate service heroes/hero (简写 ng g s heroes/hero ​ ) 可以快速的创建一个服务，创建后的服务代码如下： // src/app/heroes/hero.service.tsimport &#123; Injectable &#125; from &quot;@angular/core&quot;;@Injectable(&#123; providedIn: &quot;root&quot;,&#125;)export class HeroService &#123; constructor() &#123;&#125;&#125; HeroService 通过 @Injectable() ​ 装饰器标记为可以被注入的服务， providedIn: &#39;root&#39; ​ 表示当前服务在 Root 注入器中提供，简单理解就是这个服务在整个应用所有地方都可以注入，并全局唯一实例。添加完服务后，我们就可以在任何组件中通过构造函数注入 HeroService， 通过 TS 的构造函数赋值属性的特性设置为公开，这样组件内和模板中都可以使用该服务端的函数和方法。 // src/app/heroes/hero-list.componentconstructor(public heroService: HeroService) 简单的代码如下： import &#123; Hero &#125; from &quot;../hero&quot;;import &#123; HeroService &#125; from &quot;../hero.service&quot;;@Component(&#123; selector: &quot;app-hero-list&quot;, template: &quot;Heroes: &#123;&#123;heroes | json&#125;&#125;&quot;,&#125;)export class HeroListComponent implements OnInit &#123; heroes!: Hero[]; constructor(public heroService: HeroService) &#123;&#125; ngOnInit(): void &#123; this.heroes = this.heroService.getHeroes(); &#125;&#125; 除了在组件中注入服务外，在 Angular 中还可以在服务中注入其他服务，当某个服务依赖于另一个服务时，遵循与注入组件相同的模式，比如： HeroService ​ 要依靠 Logger ​ 服务来记录日志。 // src/app/heroes/hero.service.tsimport &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; HEROES &#125; from &quot;./mock-heroes&quot;;import &#123; Logger &#125; from &quot;../logger.service&quot;;@Injectable(&#123; providedIn: &quot;root&quot;,&#125;)export class HeroService &#123; constructor(private logger: Logger) &#123;&#125; getHeroes() &#123; this.logger.log(&quot;Getting heroes ...&quot;); return HEROES; &#125;&#125; 以上就是在 Angular 中最简单的使用依赖注入的姿势，是不是觉得和 React 的 Hooks 一样，只是通过面向对象的 API 共享数据和业务逻辑，个人感觉更加的简单和易读。 Angular 依赖注入简介下面简单的介绍一下 Angular 依赖注入的几个基本的元素： @Injectable() 装饰器来提供元数据，表示一个服务可以被注入的（在之前的版本中不加也是可以被注入的，后来 5.0 版本改成静态注入器后必须要标识一下才可以被注入，否则会报错） 注入器（Injector） 会创建依赖、维护一个容器来管理这些依赖，并尽可能复用它们，Angular 默认会创建各种注入器，甚至感觉不到他的存在，但是理解注入器的底层逻辑后再看依赖注入就更简单了 @Inject() 装饰器表示要在组件或者服务中注入一个服务 提供者（Provider） 是一个对象，用来告诉注入器应该如何获取或创建依赖值。 上面的示例中虽然没有出现 @Inject() ​ 装饰器，但是这是 Angular 提供的简写，注入一个服务的全写如下所示，我们通常定义服务都是使用类，所以省略 @Inject(HeroService) ​ 极大的简化了样板代码。 // src/app/heroes/hero-list.componentclass HeroListComponent &#123; constructor(@Inject(HeroService) private heroService: HeroService) &#123;&#125;&#125; 依赖提供者（Dependency providers）Angular 官方文档对于依赖提供者，也就是 providers ​ 的解释如下：说实话我读了很多遍都无法理解具体含义，后来我简单总结为依赖提供者就做了两件事： 告诉注入器如何提供依赖值 限制服务可使用的范围 在上述的示例中，使用 @Inject(HeroService) ​ 注入一个服务时，Angular 注入器会通过 new HeroService() ​ 实例化一个类返回依赖值，实例化类其实就是 如何提供依赖值， 那么 Angular 中除了实例化类提供依赖值外还提供给了如下类型的 Provider ​，每种 Provider ​ 都有其使用场景。 export declare type Provider = | TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];export declare type StaticProvider = | ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[]; 关于 限制服务可使用的范围 就更好理解了 ， 满足只能在某个模块或者组件中注入 HeroService ​ 的场景。 如何定义提供者在组件或者模块中通过装饰器元数据 providers 定义提供者。比如: 类提供者 provide 属性是依赖令牌，它作为一个 key，在定义依赖值和配置注入器时使用，可以是一个 类的类型 、 InjectionToken 、或者字符串，甚至对象，但是不能是一个 Interface、数字和布尔类型 第二个属性是一个提供者定义对象，它告诉注入器要如何创建依赖值。 提供者定义对象中的 key 可以是 useClass —— 就像这个例子中一样。 也可以是 useExisting ​ 、 useValue ​ 或 useFactory ​, 每一个 key 都用于提供一种不同类型的依赖。 类提供者（TypeProvider 和 ClassProvider）类提供者应该是最常用的一种，文章开始中的示例就是，简写和全写的配置如下： provides: [Logger]; // 简写provides: [&#123; provide: Logger, useClass: Logger &#125;]; // 全写 provide: Logger 意思是把类的类型作为 DI Token（依赖令牌） useClass 表示使用此类实例化作为依赖值，其实就是通过 new Logger() ​ 返回依赖值 使用场景： 所有 class 定义的服务默认都是用 类提供者 指定替代性的类提供者，替换原有服务的行为实现可扩展性，这样我在使用的时候还是注入 Logger ​，但是实际返回的对象是 BetterLogger ​ 示例 [&#123; provide: Logger, useClass: BetterLogger &#125;];// 当使用 Logger 令牌请求 Logger 时，返回一个 BetterLogger 别名类提供者（ExistingProvider）在下面的例子中，当组件请求新的或旧的 Logger 时，注入器都会注入一个 NewLogger 的实例。 通过这种方式， OldLogger ​ 就成了 NewLogger ​ 的别名。 [ NewLogger, // Alias OldLogger reference to NewLogger &#123; provide: OldLogger, useExisting: NewLogger &#125;,]; 那么别名类提供者和类提供者有什么区别呢？ [NewLogger, &#123; provide: OldLogger, useClass: NewLogger &#125;]; useExisting 值是一个 DI Token ，provide 也是一个 DI Token， 2 个 Token 指向同一个实例 useClass 值是一个可以实例化的类，也就是可以 new 出来的类，这个类可以是任何类 使用场景： 收窄类型 MinimalLogger ， Logger 类的返回的方法和属性太多，当前场景只需要使用少量的属性和函数，可以定义一个简化版的 MinimalLogger， 通过注入 MinimalLogger ​ 使用，运行时返回的其实还是 Logger 对象 重构，替换命名，一次性无法完全修改，先临时提供一个新的别名，将来逐步替换 解决循环引用问题，为类接口(抽象)指定别名 // Class used as a &quot;narrowing&quot; interface that exposes a minimal logger// Other members of the actual implementation are invisibleexport abstract class MinimalLogger &#123; abstract logs: string[]; abstract logInfo: (msg: string) =&gt; void;&#125;&#123; provide: MinimalLogger, useExisting: LoggerService &#125;, // parent.tsclass abstract Parent &#123; ...&#125;// alex.component.tsproviders: [&#123; provide: Parent, useExisting: forwardRef(() =&gt; AlexComponent) &#125;]class AlexComponent &#123; // ChildComponent&#125;// child.component.tsclass ChildComponent &#123; constructor(parent: Parent)&#125; 对象提供者（ValueProvider）要注入一个对象，可以用 useValue ​ 选项来配置注入器，下面的提供者定义对象使用 useValue ​ 作为 key 来把该变量与 Logger ​ 令牌关联起来。 // An object in the shape of the logger servicefunction silentLoggerFn() &#123;&#125;export const silentLogger = &#123; logs: [&#x27;Silent logger says &quot;Shhhhh!&quot;. Provided via &quot;useValue&quot;&#x27;], log: silentLoggerFn,&#125;;[&#123; provide: Logger, useValue: silentLogger &#125;]; 使用场景：通过对象提供者注入一个配置对象，一般推荐使用 InjectionToken ​ 作为令牌 ​ // src/app/app.config.tsimport &#123; InjectionToken &#125; from &quot;@angular/core&quot;;export const APP_CONFIG = new InjectionToken&lt;AppConfig&gt;(&quot;app.config&quot;);export const HERO_DI_CONFIG: AppConfig = &#123; apiEndpoint: &quot;api.heroes.com&quot;, title: &quot;Dependency Injection&quot;,&#125;; // src/app/app.module.ts (providers)providers: [ &#123; provide: APP_CONFIG, useValue: HERO_DI_CONFIG &#125;], 当使用 InjectionToken ​ 作为令牌时，在组件或者服务中必须借助参数装饰器 @Inject() ​ ，才可以把这个配置对象注入到构造函数中。 // src/app/app.component.tsconstructor(@Inject(APP_CONFIG) config: AppConfig) &#123; this.title = config.title;&#125; Inject, 类构造函数中依赖项参数上的参数装饰器，用于指定依赖项的自定义提供者，参数传入 DI Token，映射到要注入的依赖项。同时在定义 InjectionToken ​ 的时候还可以设置 providedIn ​ 和 factory ​ export const TOKEN_FACTORY = new InjectionToken(&quot;factory-token&quot;, &#123; providedIn: &quot;root&quot;, factory: () =&gt; &#123; return &quot;I am from InjectionToken factory&quot;; &#125;,&#125;); 工厂提供者（FactoryProvider）要想根据运行前尚不可用的信息创建可变的依赖值，可以使用工厂提供者。也就是完全自己决定如何创建依赖。比如：只有授权用户才能看到 HeroService ​ 中的秘密英雄。 // src/app/heroes/hero.service.ts (excerpt)constructor( private logger: Logger, private isAuthorized: boolean) &#123; &#125;getHeroes() &#123; const auth = this.isAuthorized ? &#x27;authorized &#x27; : &#x27;unauthorized&#x27;; this.logger.log(`Getting heroes for $&#123;auth&#125; user.`); return HEROES.filter(hero =&gt; this.isAuthorized || !hero.isSecret);&#125; // src/app/heroes/hero.service.provider.ts (excerpt)const heroServiceFactory = (logger: Logger, userService: UserService) =&gt; &#123; return new HeroService(logger, userService.user.isAuthorized);&#125;;export const heroServiceProvider = &#123; provide: HeroService, useFactory: heroServiceFactory, deps: [Logger, UserService],&#125;; useFactory ​ 字段指定该提供者是一个工厂函数，其实现代码是 heroServiceFactory ​ deps ​ 属性是一个提供者令牌数组， Logger 和 UserService 类都是类提供者的令牌。该注入器解析了这些令牌，并把相应的服务注入到 heroServiceFactory ​ 工厂函数的参数中 理解了工厂提供给者后再回过头看， useValue ​ 、 useClass ​ 和 useExisting ​ 的区别就更简单了， provider ​ 就是在装饰器中通过 providers ​ 数组配置的元数据对象。 接口和依赖注入虽然 TypeScript 的 AppConfig 接口可以在类中提供类型支持，但它在依赖注入时却没有任何作用。在 TypeScript 中，接口只能作为类型检查，它没有可供 DI 框架使用的运行时表示形式或令牌。 当转译器把 TypeScript 转换成 JavaScript 时，接口就会消失，因为 JavaScript 没有接口。 由于 Angular 在运行期没有接口，所以该接口不能作为令牌，也不能注入它。 // Can&#x27;t use interface as provider token[&#123; provide: AppConfig, useValue: HERO_DI_CONFIG &#125;)]// Can&#x27;t inject using the interface as the parameter typeconstructor(private config: AppConfig)&#123; &#125; multi 多个依赖值当配置提供者时设置 multi 为 true 时，通过 @Inject(DIToken) ​ 参数注入获取的依赖值就会返回一个数组。 export declare interface ClassProvider extends ClassSansProvider &#123; /** * An injection token. (Typically an instance of `Type` or `InjectionToken`, but can be `any`). */ provide: any; /** * When true, injector returns an array of instances. This is useful to allow multiple * providers spread across many files to provide configuration information to a common token. */ multi?: boolean;&#125; 使用场景：内置 API ，比如： NG_VALUE_ACCESSOR ​、 HTTP_INTERCEPTORS ​、 APP_INITIALIZER ​ 等 @Component(&#123; selector: &quot;select&quot;, templateUrl: &quot;./select.component.html&quot;, changeDetection: ChangeDetectionStrategy.OnPush, providers: [ &#123; provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() =&gt; ThySelectComponent), multi: true, &#125;, ],&#125;)export class ThySelectComponent implements ControlValueAccessor &#123;&#125; 以上就是依赖注入者 provider 相关的介绍，理解了 factory 提供依赖值后再看其他类型就会简单很多，其他的类型就是 factory 之上高级的 API 而已，满足不同的场景需要，这是 Angular 依赖注入入门比较难懂的知识，那么接下来的多级注入器是另一个重要的知识点，这两部分都深入理解那么 Angular 依赖注入就不在是难点了。 参考Angular 依赖注入 - 全面解析","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"angular缓存页面、实现keepAlive效果","date":"2023-02-24T06:24:00.000Z","path":"2023/02/24/2023-02-24-angular-cache-page/","text":"场景：当在某个页面筛选了一些条件，然后需要跳到详情页面，此时返回原来的列表页，需要保持原来的筛选状态 Angular RouteReuseStrategy 路由复用策略abstract class RouteReuseStrategy &#123; /* 是否允许复用路由 */ abstract shouldDetach(route: ActivatedRouteSnapshot): boolean; /* 当路由离开时会触发，存储路由 */ abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void; /* 是否允许还原路由 */ abstract shouldAttach(route: ActivatedRouteSnapshot): boolean; /* 获取存储路由 */ abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle | null; /* 进入路由触发，是否同一路由时复用路由 */ abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;&#125; 路由复用策略方法执行顺序分布讲解假设我们从路由 A ——&gt; 路由 B shouldReuseRoute(future, curr) 决定是否复用路由? 根据切换的 future curr 的节点层级依次调用。 返回值为 true 时表示当前节点层级路由复用，然后继续下一路由节点调用，入参为切换的下一级路由（子级）的 future curr 路由的节点。 返回值为 false 时表示不在复用路由，并且不再继续调用此方法（future 路由不再复用，其子级路由也不会复用，所以不需要再询问下去）。 root 路由节点调用一次，非 root 路由节点调用两次这个方法，第一次比较父级节点，第二次比较当前节点， retrieve(route) 接上一步骤，当当前层级路由不需要复用的时候，调用一下这个方法，其子级路由也会调用一下 retrieve 方法。如果返回的是 null，那么当前路由对应的组件会实例化，这种行为一直持续到末级路由。 shouldDetach(route)对上一路由是否实现复用功能，如果返回 true，调用一下 store 方法存储路由组件，如果返回 false，那么先判断有没有层级路由，有的话继续执行 shouldDetach 方法，没有的话则跳过第四步骤，执行第五步骤 store(route, handle)接上一步骤，如果离开路由 A 的时候，shouldDetach 返回 true 了，那么离开路由 A 后，路由 A 引用的组件你就可以在这里存储起来，下一次回到路由 A 的时候，就可以拿到 shouldAttach(route)当前路由是不是允许还原回来？如果配置允许，返回 true，然后调用 retrieve 方法获取存储组件，反之返回 false，就此结束 retrieve(route)上一步返回 true 了，那么说明路由时允许还原的。我们在这一步骤里面，拿到我们之前为这个路由缓存的数据，返回即可。 store(route, handle)拿完后，再调用一次 store 方法，这里，就此，整个路由复用策略就结束了。 创建新路由策略实现 keepAlive 创建SimpleReuseStrategy文件 import &#123; RouteReuseStrategy, ActivatedRouteSnapshot, DetachedRouteHandle &#125; from &quot;@angular/router&quot;;export class SimpleReuseStrategy implements RouteReuseStrategy &#123; static cacheRouters = new Map&lt;string, DetachedRouteHandle&gt;(); /* ** 清除cachedroute: ** (this.routeReuseStrategy as AppRouteReuseStrategy).clearCachedRoute(&#x27;/factory/factoryManage&#x27;); */ public clearCachedRoute(key: string) &#123; const handle = this.cacheRouters.get(key); if (handle) &#123; (handle as any).componentRef.destroy(); &#125; this.cacheRouters.delete(key); &#125; public clearCacheOnNewUrl(url: string) &#123; this.cacheRouters.forEach((val, key) =&gt; &#123; if (url.indexOf(key) === -1) &#123; this.clearCachedRoute(key); &#125; &#125;); &#125; // one 进入路由触发，是否同一路由时复用路由 shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean &#123; return future.routeConfig === curr.routeConfig &amp;&amp; JSON.stringify(future.params) === JSON.stringify(curr.params); &#125; // 获取存储路由 retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle &#123; const url = this.getFullRouteURL(route); if (route.data.keep &amp;&amp; SimpleReuseStrategy.cacheRouters.has(url)) &#123; return SimpleReuseStrategy.cacheRouters.get(url); &#125; else &#123; return null; &#125; &#125; // 是否允许复用路由 shouldDetach(route: ActivatedRouteSnapshot): boolean &#123; return Boolean(route.data.keep); &#125; // 当路由离开时会触发，存储路由 store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle): void &#123; const url = this.getFullRouteURL(route); SimpleReuseStrategy.cacheRouters.set(url, handle); &#125; // 是否允许还原路由 shouldAttach(route: ActivatedRouteSnapshot): boolean &#123; const url = this.getFullRouteURL(route); return Boolean(route.data.keep) &amp;&amp; SimpleReuseStrategy.cacheRouters.has(url); &#125; // 获取当前路由url private getFullRouteURL(route: ActivatedRouteSnapshot): string &#123; const &#123; pathFromRoot &#125; = route; let fullRouteUrlPath: string[] = []; pathFromRoot.forEach((item: ActivatedRouteSnapshot) =&gt; &#123; fullRouteUrlPath = fullRouteUrlPath.concat(this.getRouteUrlPath(item)); &#125;); return `/$&#123;fullRouteUrlPath.join(&quot;/&quot;)&#125;`; &#125; private getRouteUrlPath(route: ActivatedRouteSnapshot) &#123; return route.url.map((urlSegment) =&gt; urlSegment.path); &#125;&#125; 在 providers 里注入 providers: [ &#123; provide: RouteReuseStrategy, useClass: SimpleReuseStrategy &#125;], 在路由上新增 keepAlive 属性 &#123; path: &#x27;cuttingTag&#x27;, component: CuttingTagComponent, data: &#123; keepAlive: true &#125; &#125; 参考彻底弄懂 Angular RouteReuseStrategy 路由复用策略github 源码参考","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"html中javascript的6种加载方式","date":"2023-02-24T05:58:50.000Z","path":"2023/02/24/2023-02-24-method-of-load-js/","text":"JS 的 6 种加载方式1）正常模式&lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; 这种情况下 JS 会阻塞 dom 渲染，浏览器必须等待 index.js 加载和执行完成后才能去做其它事情 2）async 模式&lt;script async src=&quot;index.js&quot;&gt;&lt;/script&gt; async 模式下，它的加载是异步的，JS 不会阻塞 DOM 的渲染，async 加载是无顺序的，当它加载结束，JS 会立即执行 使用场景：若该 JS 资源与 DOM 元素没有依赖关系，也不会产生其他资源所需要的数据时，可以使用 async 模式，比如埋点统计 3）defer 模式&lt;script defer src=&quot;index.js&quot;&gt;&lt;/script&gt; defer 模式下，JS 的加载也是异步的，defer 资源会在 DOMContentLoaded 事件触发之前执行，并且 defer 是有顺序的执行，不会阻塞 dom 解析 如果有多个设置了 defer 的 script 标签存在，则会按照引入的前后顺序执行，即便是后面的 script 资源先返回 所以 defer 可以用来控制 JS 文件的执行顺序，比如 element-ui.js 和 vue.js，因为 element-ui.js 依赖于 vue，所以必须先引入 vue.js，再引入 element-ui.js &lt;script defer src=&quot;vue.js&quot;&gt;&lt;/script&gt;&lt;script defer src=&quot;element-ui.js&quot;&gt;&lt;/script&gt; defer 使用场景：一般情况下都可以使用 defer，特别是需要控制资源加载顺序时 4）module 模式&lt;script type=&quot;module&quot;&gt; import &#123; a &#125; from &quot;./a.js&quot;;&lt;/script&gt; 在主流的现代浏览器中，script 标签的属性可以加上 type=&quot;module&quot;，浏览器会对其内部的 import 引用发起 HTTP 请求，获取模块内容。这时 script 的行为会像是 defer 一样，在后台下载，并且等待 DOM 解析 Vite 就是利用浏览器支持原生的 es module 模块，开发时跳过打包的过程，提升编译效率 5） preload&lt;link rel=&quot;preload&quot; as=&quot;script&quot; href=&quot;index.js&quot; /&gt; 值得关注的就是 as 属性，preload 的优先级顺序和这个属性指定的资源类型相关。举一个例子，假如我们指定了 as 的值是 style，也就是把它当做 css 资源，那它的优先级就会变得最高。但是也有一个例外：虽然 font 的优先级是最高，但把 as 的值指定为 font 并不会把此资源的优先级放到最高，文档专门为 font 的 preload 指定了优先级：位于第二级。目前来说，除了 font，其他都按照和资源优先级相同的规则。as 属性可以说是必须要设置的，除了上面可以给优先级排级别以外，还有一个原因：如果不设置的话，它会被作为一个 XHR 请求去触发，浏览器可能不能正确的认识到，我们其实已经把资源预加载了，这样子就会加载两次了，完全没有了优化的效果。不指定 as 浏览器也会有警告： preload 只会加载，真正执行要等到资源被用到的地方。 接下来再给大家介绍一个它的应用场景。 现在我们的文件是这样的： index.html|--main.js |--styles.css 我们有一个 main.js ，它会在 200 ms 后下载完，在它的内部会加载一段 CSS 来控制页面的样式，它也需要下载 200 ms。虽然 style.css 我们肯定会用到，但是浏览器必须要等下载、解析完 main.js 才开始下载 style.css，这就白白浪费了至少 200 ms。这里我们就可以把 style.css 用 preload 优化：把 style.css 标识为 preload 的资源。也不是所有的资源都适合用 preload，它只适合用于 page load 阶段的资源。毕竟，它的优先级还是很高的，乱用的话，一个是占请求线程，一个是占浏览器的缓存。如果我们 preload 的资源在 load 事件几秒后没有用，控制台还会警告我们。比如我们上面的例子，没有实际引用 style.css，就有下面的警告： preload 特点： 1）preload 加载的资源是在浏览器渲染机制之前进行处理的，并且不会阻塞 onload 事件； 2）preload 加载的 JS 脚本其加载和执行的过程是分离的，即 preload 会预加载相应的脚本代码，待到需要时自行调用； 6）prefetch&lt;link rel=&quot;prefetch&quot; as=&quot;script&quot; href=&quot;index.js&quot; /&gt; prefetch 是利用浏览器的空闲时间，加载页面将来可能用到的资源的一种机制；通常可以用于加载其他页面（非首页）所需要的资源，以便加快后续页面的打开速度prefetch 特点： 1）pretch 加载的资源可以获取非当前页面所需要的资源，并且将其放入缓存至少 5 分钟（无论资源是否可以缓存） 2）当页面跳转时，未完成的 prefetch 请求不会被中断 加载方式总结async、defer 是 script 标签的专属属性，对于网页中的其他资源，可以通过 link 的 preload、prefetch 属性来预加载 如今现代框架已经将 preload、prefetch 添加到打包流程中了，通过灵活的配置，去使用这些预加载功能，同时我们也可以审时度势地向 script 标签添加 async、defer 属性去处理资源，这样可以显著提升性能 参考性能优化之 preload、prefetch、preconnect 的区别与使用前端性能优化——首页资源压缩 63%、白屏时间缩短 86%","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"富文本编辑器Quill支持复制粘贴文字图片","date":"2022-10-11T03:54:06.000Z","path":"2022/10/11/2022-10-11-quill-support-word-img/","text":"在使用富文本编辑器时，通常 word 整体粘贴时，图片总是无法正常显示，图片地址会是 src=”//0”的情况，这主要时因为，我们整体粘贴时，实际上我我们粘贴过去的是一片 word 的 dom 字符串，其中编辑器会为我们过滤其他无用标签，保留了主要部分。由于粘贴时候 word 文档中图片部分实际上引用的是本地地址，由于浏览器和 js 限制无法读取或者操作本地文件，因此无法正常显示。如果是网络上复制粘贴的文档则可以正常显示。 一下是从 word 直接粘贴过来的效果一下是从网络上粘贴过来的效果 粘贴事件通常要解决从 word 中复制粘贴到富文本编辑器中，都离不开这个 paste 事件,我们简单分析一下这个事件。粘贴事件提供了一个 clipboardData 的属性，如果该属性有 items 属性，那么就可以查看 items 中是否有图片类型的数据了。clipboardData 的属性介绍： 属性 类型 说明 dropEffect String 默认是 none effectAllowed String 粘贴操作为空 List items DataTransferItemList 剪切板中的各项数据 types Array 剪切板中的数据类型 items 是一个 DataTransferItemList(浏览器基于 file 对象实现的方法，所以能够转换成 file 对象)对象，里面都是 DataTransferItem 类型的数据了。 items 的 DataTransferItem 有两个属性 kind 和 type。kind 一般为 string 或者 filetype 具体的数据类型，例如具体是哪种类型字符串或者哪种类型的文件，即 MIME-Type 方法 getAsFile 空 如果 kind 是 file，可以用该方法获取到文件 getAsString 回调函数 如果 kind 是 string，可以用该方法获取到字符串，字符串需要用回调函数得到，回调函数的第一个参数就是剪切板中的字符串 通常我们通过以上提供的属性就能够实现不论是从何处粘贴的内容,从这里我们也可以看到其冲粘贴的内容，这里简单实现一个单张图片粘贴的例子。 单张图片粘贴let quill = this.$refs.myQuillEditor.quill; quill.root.addEventListener( &quot;paste&quot;, (evt) =&gt; &#123; // 粘贴事件 if ( evt.clipboardData &amp;&amp; evt.clipboardData.files &amp;&amp; evt.clipboardData.files.length ) &#123; evt.preventDefault(); [].forEach.call(evt.clipboardData.files, (file) =&gt; &#123; if (!file.type.match(/^image\\/(gif|jpe?g|a?png|bmp)/i)) &#123; return; &#125; console.log(&#x27;单个图片粘贴&#x27;, file); // 转base64格式 const reader = new FileReader() reader.readAsDataURL(file) reader.onload = (e) =&gt; &#123; // 插入图片 quill.insertEmbed( quill.getSelection().index, &quot;image&quot;, reader.result ) &#125; reader.onerror = (error) =&gt;reject(error) // obsUpload(file, this.$refs.myQuillEditor); &#125;); &#125; 复制内容整体粘贴复制内容整体粘贴，我们通过上述的方法同样可以拿到其中内容。 let length = evt.clipboardData.items.length;for (let i = 0; i &lt; length; i++) &#123; var item = evt.clipboardData.items[i]; if (item.kind === &quot;string&quot;) &#123; item.getAsString(function (str) &#123; // str 是获取到的字符串 console.log(str); &#125;); &#125; else if (item.kind === &quot;file&quot;) &#123; var pasteFile = item.getAsFile(); console.log(pasteFile); &#125;&#125; 整体粘贴过来，kind 为 string，实际上我们拿到的是一个 html 文档。整体粘贴过来，kind 为 file，实际上我们拿到的是一个 file 文件对象。这里实际上和第一部粘贴单张图片处理方式一样。 整体粘贴如何实现从剪切板中提取出图片上述内容仅仅是作为了解内容，知道基本原理，下面这里才是重点。如果上面能解决你的单张图片粘贴问题，那么接下来才是实现整体粘贴提取图片的关键。我们来看看 clipboardData 提供的其他几个方法。 clearData(sDataFormat) 删除剪贴板中指定格式的数据。 getData(sDataFormat) 从剪贴板获取指定格式的数据。 setData(sDataFormat, sData) 给剪贴板赋予指定格式的数据。返回 true 表示操作成功。 这里我们重点讨论 getData 这个方法，其他方法请自行实践。getData 这个方法是 clipboardData 提供给我们快速从剪切板中提取内容的方法。其中常用参数： text/html 获取 html 内容 text/plain 获取文本内容 text/rtf 获取富媒体内容 (什么是 rtf 请自行查询资料,这里面就含有我们需要的图片信息) 我们需要结合 text/html 和 text/rtf 两种两种方法实现，对粘贴内容中图片的提取。通过 text/html 我们提取到图片之后，我们发现图片地址都是 file:/// 开始的本地文件，js 无法完成对本地文件的处理,无法做 base64 处理。浏览器会给出警告。接下来我们需要，从 html 文档中提取出是 file 格式的本地文件的 img, 然后讲这些图片替换成 loading 图片。然后就是如何把这些图片转换成对应的图片。在 QuillEditor 中提供一个 clipboard 配置项，我们通过这个配置项实现将图片替换成 loading 图片。 // 自定义粘贴内容过滤方法function customMatcherNode(node, delta) &#123; if (delta.ops &amp;&amp; delta.ops.length &gt; 0) &#123; delta.ops = delta.ops.map((item) =&gt; &#123; if (item.insert) &#123; if (item.insert.image) &#123; // 判断是否是网络地址 if (/file:\\/\\//.test(item.insert.image)) &#123; item.insert.image = &quot;https://img.zcool.cn/community/0196fa582abab6a84a0d304f899eaf.gif&quot;; &#125; &#125; return item; &#125; &#125;); &#125; return delta;&#125; 通过以上方法，我们实现讲了整体粘贴过来的内容换成 loading 图片。接下来，我们要讲对应的 loading 图片，替换成对应的真实图片。这些图片的对应的内容就保存在 getData(&#39;text/rtf&#39;)中，这里面是一种特殊 hex 格式的内容。我们需要对其进行转换和提取。才能拿到对应的 base64 图片。 从 rtf 中提取图片信息// rtf中提取图片信息function extractImageDataFromRtf(rtfData) &#123; if (!rtfData) &#123; return []; &#125; const regexPictureHeader = /&#123;\\\\pict[\\s\\S]+?(&#123;\\\\\\*\\\\blipuid\\s?[\\da-fA-F]+)[\\s&#125;]*/; const regexPicture = new RegExp( &quot;(?:(&quot; + regexPictureHeader.source + &quot;))([\\\\da-fA-F\\\\s]+)\\\\&#125;&quot;, &quot;g&quot; ); const images = rtfData.match(regexPicture); const result = []; if (images) &#123; for (const image of images) &#123; let imageType = false; if (image.includes(&quot;\\\\pngblip&quot;)) &#123; imageType = &quot;image/png&quot;; &#125; else if (image.includes(&quot;\\\\jpegblip&quot;)) &#123; imageType = &quot;image/jpeg&quot;; &#125; if (imageType) &#123; result.push(&#123; hex: image .replace(regexPictureHeader, &quot;&quot;) .replace(/[^\\da-fA-F]/g, &quot;&quot;), type: imageType, &#125;); &#125; &#125; &#125; return result;&#125; 利用正则从 rtf 内容中提取到图片的核心信息，得到数组。其中数组中保存的信息有 &#123; &quot;type&quot;: &quot;&quot;, //图片类型 &quot;hex&quot;: &quot;&quot; // hex字符串&#125; 将 hex 字符串转化为 base64 图片信息// 讲hex格式转化为base64function convertHexToBase64(hexString) &#123; return btoa( hexString .match(/\\w&#123;2&#125;/g) .map((char) =&gt; &#123; return String.fromCharCode(parseInt(char, 16)); &#125;) .join(&quot;&quot;) );&#125; 到这里核心的方法提取 rtf 内容到图片信息就处理完了。详细代码： console.log(&quot;批量粘贴&quot;);// const pastDom = evt.clipboardData.getData(&#x27;text/html&#x27;);const rtf = evt.clipboardData.getData(&quot;text/rtf&quot;);const hexStrings = extractImageDataFromRtf(rtf);// 获取base64图片数据const base64Images = hexStrings.map((hexObj) =&gt; &#123; return convertHexToBase64(hexObj.hex);&#125;);// 粘贴后处理粘贴内容setTimeout(() =&gt; &#123; const editorDom = this.$refs.myQuillEditor.quill.root; const editorImgs = editorDom.querySelectorAll( &#x27;img[src*=&quot;0196fa582abab6a84a0d304f899eaf.gif&quot;]&#x27; ); editorImgs.forEach((item, index) =&gt; &#123; item.src = `data:$&#123;hexStrings[index].type&#125;;base64,$&#123;base64Images[index]&#125;`; &#125;);&#125;, 200); 利用查找 quillEditor 编辑器中 loading 图片，然后遍历替换为 base64 图片格式。根据上述方法，大家可以自行根据实际情况在不同编辑器下修改代码，进一步完善上传到云存储也可调整替换图片的 src 的部分。异步后拿到路径之后修改完善。 转载富文本编辑器 word 整体粘贴实现图片自动展示(一)","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"whistle抓包工具","date":"2022-10-11T02:47:51.000Z","path":"2022/10/11/2022-10-11-whistle/","text":"一、whistle 简介whistle 是一款基于 Node.js 实现的，类似 Fiddler、Charles 的代理工具，可用于 HTTP、Websocket 等请求的抓取、编辑、重放等功能。 利用 whistle 的改包功能，在进行 HTTP(S) 请求时，可以轻松完成某些不具备测试条件或不易构造真实场景的测试工作，如异常场景、边界场景的测试等。 二、安装、启动、配置2.1 安装 Node.js由于 whistle 是基于 Node 实现的，因此需要预先安装 Node.js Node.js 官网（ https://nodejs.org/zh-cn/ ） 2.2 安装 whistle通过 npm 包管理工具进行安装 npm install -g whistle 1 2.3 启动 whistle安装好 whistle 后，打开命令行工具，执行如下启动命令 w2 start 1 启动成功后，会显示如下信息 ​ 【 whistle 成功启动状态 】 可通过访问本地端口访问 whistle 控制台 ​ 【 访问 whistle 页面 】 whistle 查看运行状态和停止命令分别如下 w2 status # 查看运行状态w2 stop # 停止运行 1 2 2.4 配置代理 （推荐）由于 whistle 是通过代理服务来进行工作的，因此需要给请求客户端配置 whistle 的代理，代理地址即 whistle 的监听地址（默认为 http://127.0.0.1:8899/ ）。 在进行 Web 测试时，推荐结合 SwitchyOmega 等浏览器（适用 Chrome、Firefox）代理插件来进行使用。如下图，在 Chrome 浏览器安装好扩展后，配置代理服务器为 whistle 地址，并将浏览器请求切换为 whistle 代理 ​ 【 SwitchyOmega 设置 whistle 代理情景模式 】 ​ 【 浏览器访问切换为 whistle 情景模式 】 此时浏览器发送的请求即可被 whistle 抓取 # ​ 【 whistle 抓取浏览器请求记录 】 2.5 抓取 HTTPS 请求（可选）抓取 HTTPS 请求仅需要进行证书配置，其余步骤与抓取 HTTP 相同。以下介绍 HTTPS 配置方法 2.5.1 下载 whistle 证书 &amp; 开启抓取 HTTPS 请求 在 whistle 控制台点击 【Network】-【 HTTPS 】选项，点击下载 CA 证书，并且勾选抓取 TUNNEL 请求（部分版本为 HTTPS 请求），如下图 ​ 【 whistle 配置开启抓取 HTTPS 请求 】 2.5.2 信任 whistle 证书由于 whistle 证书为自签证书，因此需要配置本地机器信任证书，否则浏览器会因为证书不安全而拦截 whistle 代理的 HTTPS 请求。 Mac 配置： 打开【钥匙串】（或默认打开下载的证书），右上角搜索 whistle 证书，然后右键证书弹出框中选择【显示简介】，在【信任】-【使用此证书时】选择 “始终信任” 即可，如下图 ​ 【 Mac 信任 whistle 证书 】 Windows 配置： 下载完证书后，双击打开，在对话框中点击【安装证书】，并将证书存储到 “受信任的根证书颁发机构”，确认完成即可，（Win10 配置）如下图 ​ 【 Windows10 信任 whistle 证书 】 2.5.3 验证抓取 HTTPS 请求完成上述两个步骤后，浏览器发起 HTTPS 请求，查看 whistle 控制台，可以看到正常抓取到 HTTPS 请求 ​ 【 抓取 HTTPS 请求 】 三、修改请求实例演示修改请求内容通常需要经过如下过程： Values： values 中允许自定义变量，以供在定义修改包内容时进行引用。 Rules： Rules 即定义修改包内容规则。 根据上面修改请求、响应的过程，下面简单演示几种常用修改包内容（完整的修改内容支持请参考 whistle 文档）。 3.1 修改请求3.1.1 修改请求方法修改请求方法模式如下 pattern method://newMethod 1 如 kyfw.12306.cn method://post 1 ​ 【 修改请求方法 】 如下在浏览器发起请求时，通过开发者工具抓包发现原始请求方法为 GET ​ 【 浏览器原始请求方法 】 请求经过 whistle 修改后，查看请求包内容，发现请求匹配模式站点的请求方法由 GET 改为 POST，如下图 ​ 【 请求方法经过 whistle 修改 】 3.1.2 修改请求头修改请求头模式如下 pattern reqHeaders://&#123;values&#125; 1 如 kyfw.12306.cn reqHeaders://&#123;new_headers&#125; 1 其中引用到的 values 变量 new_headers 定义如下 test-header1: value1upgrade-insecure-requests: 10 1 2 ​ 【 头部引用变量 new_headers 定义 】 ​ 【 浏览器原始请求头部 】 发起请求后，查看 whistle 抓包内容，对应头部发生改变，如下图 ​ 【 请求头部经过 whistle 修改 】 3.1.3 修改请求体修改请求体模式如下 pattern reqBody://&#123;values&#125; 1 如 kyfw.12306.cn reqBody://&#123;new_reqBody&#125; 1 引用变量 new_reqBody 定义如下 my new reqbody 1 发起请求后，抓起浏览器原始请求如下 ​ 【 浏览器原始无 body 请求包 】 whistle 抓取经修改后请求包内容如下 ​ 【 body 经过 whistle 修改请求包 】 3.2 修改响应3.2.1 修改响应状态码修改响应状态码模式如下 pattern statusCode://code 1 或 pattern replaceStatus://code 1 两者区别为，设置 statusCode 后不再发送请求，直接返回设置的状态码；而 replaceStatus 继续进行请求，并对响应的状态码进行替换。下面以 statusCode 为例，如 kyfw.12306.cn statusCode://500 1 修改状态码后，查看 whistle 及浏览器包内容均显示为修改的状态码 ​ 【 whistle 抓取修改响应状态码请求包 】 ​ 【 浏览器抓取原始请求包 】 3.2.2 修改响应头部修改请求体模式如下 pattern resHeaders://&#123;values&#125; 1 如 kyfw.12306.cn resHeaders://&#123;new_resHeaders&#125; 1 引用变量 new_resHeaders 定义如下 test-res-header: felix-test 1 ​ 【 自定义响应头部引用变量 new_resHeaders 定义 】 抓取请求内容，响应头部中包含 whistle 修改的内容 ​ 【 响应头部包含 whistle 修改内容 】 3.2.3 修改响应体修改请求体模式如下 pattern resBody://&#123;values&#125; 1 如 kyfw.12306.cn resBody://&#123;new_resBody&#125; 1 引用变量 new_resBody 定义如下 my response body 1 ​ 【 自定义响应体引用变量 new_resBody 定义 】 发起请求后抓取请求包内容，发现接口到响应 body 为修改后的内容 ​ 【 请求响应体为 whistle 修改内容 】 四、总结 跨平台性 得益于 Node.js 的跨平台性，whistle 在 Windows、Mac、Linux 均可以运行，相比于 Fiddler、Charles 等客户端工具而言，有更好的系统兼容性，降低了使用者在不同系统间的学习和使用成本，满足用户一个工具打天下的需求。 使用简单 whistle 所有安装配置工作可在 5 分钟之内完成（不考虑网络下载等因素影响），同时 whistle 具备详细的帮助说明文档，极大降低了用户上手的门槛，对初学者非常友好。 转载whistle 使用指南","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"tool","slug":"tool","permalink":"https://luckyship.github.io/tags/tool/"}]},{"title":"使用js选中元素，移动光标","date":"2022-09-22T01:58:25.000Z","path":"2022/09/22/2022-09-22-js-selection/","text":"// 删除之前所有的选区window.getSelection().removeAllRanges();let selection = window.getSelection();let range = document.createRange();range.selectNode(ele); // 需要选中的elementselection.addRange(range); 如果需要移动光标，可以使用: selection.collapseToEnd();selection.collapseToStart(); 如果需要选中所有子元素，可以使用: selection.selectAllChildren(ele);","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"Vuex核心原理","date":"2022-07-16T07:08:31.000Z","path":"2022/07/16/2022-07-16-vuex-theory/","text":"一、核心原理 Vuex 本质是一个对象 Vuex 对象有两个属性，一个是 install 方法，一个是 Store 这个类 install 方法的作用是将 store 这个实例挂载到所有的组件上，注意是同一个 store 实例。 Store 这个类拥有 commit，dispatch 这些方法，Store 类里将用户传入的 state 包装成 data，作为 new Vue 的参数，从而实现了 state 值的响应式。 二、基本准备工作我们先利用 vue-cli 建一个项目 删除一些不必要的组建后项目目录暂时如下： 已经把项目放到 github：github.com/Sunny-lucki… 可以卑微地要个 star 吗。有什么不理解的或者是建议欢迎评论提出 我们主要看下 App.vue,main.js,store/index.js 代码如下: App.vue &lt;template&gt; &lt;div id=&quot;app&quot;&gt; 123 &lt;/div&gt;&lt;/template&gt; store/index.js import Vue from &quot;vue&quot;;import Vuex from &quot;vuex&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); main.js import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;new Vue(&#123; store, render: (h) =&gt; h(App),&#125;).$mount(&quot;#app&quot;); 现在我们启动一下项目。看看项目初始化有没有成功。 ok，没毛病，初始化成功。 现在我们决定创建自己的 Vuex，于是创建 myVuex.js 文件 目前目录如下 再将 Vuex 引入 改成我们的 myVuex //store/index.jsimport Vue from &quot;vue&quot;;import Vuex from &quot;./myVuex&quot;; //修改代码Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); 三、剖析 Vuex 本质先抛出个问题，Vue 项目中是怎么引入 Vuex。 安装 Vuex，再通过import Vuex from &#39;vuex&#39;引入 先 var store = new Vuex.Store({…}),再把 store 作为参数的一个属性值，new Vue({store}) 通过 Vue.use(Vuex) 使得每个组件都可以拥有 store 实例 从这个引入过程我们可以发现什么？ 我们是通过 new Vuex.store({})获得一个 store 实例，也就是说，我们引入的 Vuex 中有 Store 这个类作为 Vuex 对象的一个属性。因为通过 import 引入的，实质上就是一个导出一个对象的引用。 所以我们可以初步假设 Class Store&#123;&#125;let Vuex = &#123; Store&#125; 我们还使用了 Vue.use(),而 Vue.use 的一个原则就是执行对象的 install 这个方法 所以，我们可以再一步 假设 Vuex 有有 install 这个方法。 class Store &#123;&#125;let install = function () &#123;&#125;;let Vuex = &#123; Store, install,&#125;; 到这里，你能大概地将 Vuex 写出来吗？ 很简单，就是将上面的 Vuex 对象导出，如下就是 myVuex.js //myVuex.jsclass Store &#123;&#125;let install = function () &#123;&#125;;let Vuex = &#123; Store, install,&#125;;export default Vuex; 我们执行下项目，如果没报错，说明我们的假设没毛病。 天啊，没报错。没毛病！ 四、分析 Vue.useVue.use(plugin); （1）参数 &#123; Object | Function;&#125;plugin; （2）用法 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。调用 install 方法时，会将 Vue 作为参数传入。install 方法被同一个插件多次调用时，插件也只会被安装一次。 （3）作用 注册插件，此时只需要调用 install 方法并将 Vue 作为参数传入即可。但在细节上有两部分逻辑要处理： 1、插件的类型，可以是 install 方法，也可以是一个包含 install 方法的对象。 2、插件只能被安装一次，保证插件列表中不能有重复的插件。 （4）实现 Vue.use = function (plugin) &#123; const installedPlugins = this._installedPlugins || (this._installedPlugins = []); if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this; &#125; // &lt;!-- 其他参数 --&gt; const args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &quot;function&quot;) &#123; plugin.install.apply(plugin, args); &#125; else if (typeof plugin === &quot;function&quot;) &#123; plugin.apply(null, plugin, args); &#125; installedPlugins.push(plugin); return this;&#125;; 1、在 Vue.js 上新增了 use 方法，并接收一个参数 plugin。 2、首先判断插件是不是已经别注册过，如果被注册过，则直接终止方法执行，此时只需要使用 indexOf 方法即可。 3、toArray 方法我们在就是将类数组转成真正的数组。使用 toArray 方法得到 arguments。除了第一个参数之外，剩余的所有参数将得到的列表赋值给 args，然后将 Vue 添加到 args 列表的最前面。这样做的目的是保证 install 方法被执行时第一个参数是 Vue，其余参数是注册插件时传入的参数。 4、由于 plugin 参数支持对象和函数类型，所以通过判断 plugin.install 和 plugin 哪个是函数，即可知用户使用哪种方式祖册的插件，然后执行用户编写的插件并将 args 作为参数传入。 5、最后，将插件添加到 installedPlugins 中，保证相同的插件不会反复被注册。(~~让我想起了曾经面试官问我为什么插件不会被重新加载！！！哭唧唧，现在总算明白了) 五、完善 install 方法我们前面提到 通过 Vue.use(Vuex) 使得每个组件都可以拥有 store 实例。 这是什么意思呢？？？ 来看 mian.js import Vue from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import store from &quot;./store&quot;;Vue.config.productionTip = false;new Vue(&#123; store, render: (h) =&gt; h(App),&#125;).$mount(&quot;#app&quot;); 我们可以发现这里只是将 store ，也就是 store/index.js 导出的 store 实例，作为 Vue 参数的一部分。 但是这里就是有一个问题咯，这里的 Vue 是根组件啊。也就是说目前只有根组件有这个 store 值，而其他组件是还没有的，所以我们需要让其他组件也拥有这个 store。 因此，install 方法我们可以这样完善 let install = function (Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (this.$options &amp;&amp; this.$options.store) &#123; // 如果是根组件 this.$store = this.$options.store; &#125; else &#123; //如果是子组件 this.$store = this.$parent &amp;&amp; this.$parent.$store; &#125; &#125;, &#125;);&#125;; 解释下代码： 参数 Vue，我们在第四小节分析 Vue.use 的时候，再执行 install 的时候，将 Vue 作为参数传进去。 mixin 的作用是将 mixin 的内容混合到 Vue 的初始参数 options 中。相信使用 vue 的同学应该使用过 mixin 了。 为什么是 beforeCreate 而不是 created 呢？因为如果是在 created 操作的话，$options已经初始化好了。 如果判断当前组件是根组件的话，就将我们传入的 store 挂在到根组件实例上，属性名为$store。 如果判断当前组件是子组件的话，就将我们根组件的$store也复制给子组件。注意是引用的复制，因此每个组件都拥有了同一个$store挂载在它身上。 这里有个问题，为什么判断当前组件是子组件，就可以直接从父组件拿到$store呢？这让我想起了曾经一个面试官问我的问题：父组件和子组件的执行顺序？ A：父 beforeCreate-&gt; 父 created -&gt; 父 beforeMounte -&gt; 子 beforeCreate -&gt;子 create -&gt;子 beforeMount -&gt;子 mounted -&gt; 父 mounted 可以得到，在执行子组件的 beforeCreate 的时候，父组件已经执行完 beforeCreate 了，那理所当然父组件已经有$store了。 六、实现 Vuex 的 state&lt;p&gt;&#123;&#123;this.$store.state.num&#125;&#125;&lt;/p&gt; 我们都知道，可以通过这个 语句获得 state 的值 但是我们在 Store 类里还没实现，显然，现在就这样取得话肯定报错。 前面讲过，我们是这样使用 Store 的 export default new Vuex.Store(&#123; state: &#123; num: 0, &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, modules: &#123;&#125;,&#125;); 也就是说，我们把这个对象 &#123; state: &#123; num: 0; &#125; , mutations: &#123; &#125; , actions: &#123; &#125; , modules: &#123; &#125;&#125; 当作参数了。 那我们可以直接在 Class Store 里，获取这个对象 class Store &#123; constructor(options) &#123; this.state = options.state || &#123;&#125;; &#125;&#125; 那这样是不是可以直接使用了呢？ 试一下呗！ //App.vue&lt;template&gt; &lt;div id=&quot;app&quot;&gt; 123 &lt;p&gt;&#123;&#123;this.$store.state.num&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 运行结果： 太赞了吧，怎么会这么简单。。。不敢相信。 哦不，当然没有这么简单，我们忽略了一点，state 里的值也是响应式的哦，我们这样可没有实现响应式。 曾经面试官问我 Vuex 和全局变量比有什么区别。这一点就是注意区别吧 那要怎么实现响应式呢？ 我们知道，我们 new Vue（）的时候，传入的 data 是响应式的，那我们是不是可以 new 一个 Vue，然后把 state 当作 data 传入呢？ 没有错，就是这样。 class Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); &#125;&#125; 现在是实现响应式了，但是我们怎么获得 state 呢？好像只能通过this.$store.vm.state了？但是跟我们平时用的时候不一样，所以，是需要转化下的。 我们可以给 Store 类添加一个 state 属性。这个属性自动触发 get 接口。 class Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); &#125; //新增代码 get state() &#123; return this.vm.state; &#125;&#125; 这是 ES6，的语法，有点类似于 Object.defineProperty 的 get 接口 成功实现。 七、实现 getter//myVuex.jsclass Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); // 新增代码 let getters = options.getter || &#123;&#125;; this.getters = &#123;&#125;; Object.keys(getters).forEach((getterName) =&gt; &#123; Object.defineProperty(this.getters, getterName, &#123; get: () =&gt; &#123; return getters[getterName](this.state); &#125;, &#125;); &#125;); &#125; get state() &#123; return this.vm.state; &#125;&#125; 我们把用户传进来的 getter 保存到 getters 数组里。 最有意思的是经常会有面试题问：为什么用 getter 的时候不用写括号。要不是我学到这个手写 Vuex，也不会想不明白，原来这个问题就像问我们平时写个变量，为什么不用括号一样。（如&#123;&#123;num&#125;&#125;,而不是&#123;&#123;num()&#125;&#125;） 原来就是利用了 Object.defineProperty 的 get 接口。 ok，现在来试一下，getter 可不可以使用。 //store/index.jsimport Vue from &quot;vue&quot;;import Vuex from &quot;./myVuex&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; num: 0, &#125;, // 新增测试代码 getter: &#123; getNum: (state) =&gt; &#123; return state.num; &#125;, &#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;); &lt;template&gt; &lt;div id=&quot;app&quot;&gt; 123 &lt;p&gt;state：&#123;&#123;this.$store.state.num&#125;&#125;&lt;/p&gt; &lt;p&gt;getter:&#123;&#123;this.$store.getters.getNum&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 完美。毫无事故。 八、实现 mutation//myVuex.jsclass Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); let getters = options.getter || &#123;&#125;; this.getters = &#123;&#125;; Object.keys(getters).forEach((getterName) =&gt; &#123; Object.defineProperty(this.getters, getterName, &#123; get: () =&gt; &#123; return getters[getterName](this.state); &#125;, &#125;); &#125;); //新增代码 let mutations = options.mutations || &#123;&#125;; this.mutations = &#123;&#125;; Object.keys(mutations).forEach((mutationName) =&gt; &#123; this.mutations[mutationName] = (arg) =&gt; &#123; mutations[mutationName](this.state, arg); &#125;; &#125;); &#125; get state() &#123; return this.vm.state; &#125;&#125; mutations 跟 getter 一样，还是用 mutations 对象将用户传入的 mutations 存储起来。 但是怎么触发呢？回忆一下，我们是怎么触发 mutations 的。 this.$store.commit(&#x27;incre&#x27;,1) 对，是这种形式的。可以看出 store 对象有 commit 这个方法。而 commit 方法触发了 mutations 对象中的某个对应的方法，因此我们可以给 Store 类添加 commit 方法 //myVuex.jsclass Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); let getters = options.getter || &#123;&#125;; this.getters = &#123;&#125;; Object.keys(getters).forEach((getterName) =&gt; &#123; Object.defineProperty(this.getters, getterName, &#123; get: () =&gt; &#123; return getters[getterName](this.state); &#125;, &#125;); &#125;); let mutations = options.mutations || &#123;&#125;; this.mutations = &#123;&#125;; Object.keys(mutations).forEach((mutationName) =&gt; &#123; this.mutations[mutationName] = (arg) =&gt; &#123; mutations[mutationName](this.state, arg); &#125;; &#125;); &#125; //新增代码 commit(method, arg) &#123; this.mutations[method](arg); &#125; get state() &#123; return this.vm.state; &#125;&#125; 好了，现在来测试一下。 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; 123 &lt;p&gt;state:&#123;&#123;this.$store.state.num&#125;&#125;&lt;/p&gt; &lt;p&gt;getter:&#123;&#123;this.$store.getters.getNum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;//新增测试代码&lt;script&gt; export default &#123; methods:&#123; add()&#123; this.$store.commit(&#x27;incre&#x27;,1) &#125; &#125; &#125;&lt;/script&gt; store/index.js //store/index.jsimport Vue from &quot;vue&quot;;import Vuex from &quot;./myVuex&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; num: 0, &#125;, getter: &#123; getNum: (state) =&gt; &#123; return state.num; &#125;, &#125;, // 新增测试代码 mutations: &#123; incre(state, arg) &#123; state.num += arg; &#125;, &#125;, actions: &#123;&#125;,&#125;); 运行成功。 九、实现 actions当会实现 mutations 后，那 actions 的实现也很简单，很类似，不信看代码： //myVuex.jsclass Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); let getters = options.getter || &#123;&#125;; this.getters = &#123;&#125;; Object.keys(getters).forEach((getterName) =&gt; &#123; Object.defineProperty(this.getters, getterName, &#123; get: () =&gt; &#123; return getters[getterName](this.state); &#125;, &#125;); &#125;); let mutations = options.mutations || &#123;&#125;; this.mutations = &#123;&#125;; Object.keys(mutations).forEach((mutationName) =&gt; &#123; this.mutations[mutationName] = (arg) =&gt; &#123; mutations[mutationName](this.state, arg); &#125;; &#125;); //新增代码 let actions = options.actions; this.actions = &#123;&#125;; Object.keys(actions).forEach((actionName) =&gt; &#123; this.actions[actionName] = (arg) =&gt; &#123; actions[actionName](this, arg); &#125;; &#125;); &#125; // 新增代码 dispatch(method, arg) &#123; this.actions[method](arg); &#125; commit(method, arg) &#123; console.log(this); this.mutations[method](arg); &#125; get state() &#123; return this.vm.state; &#125;&#125; 一毛一样，不过有一点需要解释下，就是这里为什么是传 this 进去。这个 this 代表的就是 store 实例本身 这是因为我们使用 actions 是这样使用的： actions: &#123; asyncIncre(&#123;commit&#125;,arg)&#123; setTimeout(()=&gt;&#123; commit(&#x27;incre&#x27;,arg) &#125;,1000) &#125;&#125;, 其实{commit} 就是对 this，即 store 实例的解构 。 那我们来测试一下。 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; 123 &lt;p&gt;state:&#123;&#123;this.$store.state.num&#125;&#125;&lt;/p&gt; &lt;p&gt;getter:&#123;&#123;this.$store.getters.getNum&#125;&#125;&lt;/p&gt; &lt;button @click=&quot;add&quot;&gt;+1&lt;/button&gt; &lt;button @click=&quot;asyncAdd&quot;&gt;异步+2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; methods: &#123; add() &#123; this.$store.commit(&quot;incre&quot;, 1); &#125;, asyncAdd() &#123; this.$store.dispatch(&quot;asyncIncre&quot;, 2); &#125;, &#125;, &#125;;&lt;/script&gt; store/index.js //store/index.jsimport Vue from &quot;vue&quot;;import Vuex from &quot;./myVuex&quot;;Vue.use(Vuex);export default new Vuex.Store(&#123; state: &#123; num: 0, &#125;, getter: &#123; getNum: (state) =&gt; &#123; return state.num; &#125;, &#125;, mutations: &#123; incre(state, arg) &#123; state.num += arg; &#125;, &#125;, //新增测试代码 actions: &#123; asyncIncre(&#123; commit &#125;, arg) &#123; setTimeout(() =&gt; &#123; commit(&quot;incre&quot;, arg); &#125;, 1000); &#125;, &#125;,&#125;); oh my god，居然出错了，它这里错误 说的是执行到这里发现这里的 this 为 undefined。 不过，不对啊，我们在实现 mutation 的时候也执行到这里了啊，而且执行成功了啊。 来分析一下： this.$store.commit(&quot;incre&quot;, 1); 执行这段代码的时候，执行 commit 的时候，this 是谁调用就指向谁，所以 this 指向$store。 this.$store.dispatch(&quot;asyncIncre&quot;, 2); 执行这段代码，就会执行 asyncIncre(&#123;commit&#125;,arg)&#123; setTimeout(()=&gt;&#123; commit(&#x27;incre&#x27;,arg) &#125;,1000)&#125; 发现问题了吧？？ 谁调用 commit？？是$store吗？并不是。所以要解决这个问题，我们必须换成箭头函数 //myVuex.jsclass Store &#123; constructor(options) &#123; this.vm = new Vue(&#123; data: &#123; state: options.state, &#125;, &#125;); let getters = options.getter || &#123;&#125;; this.getters = &#123;&#125;; Object.keys(getters).forEach((getterName) =&gt; &#123; Object.defineProperty(this.getters, getterName, &#123; get: () =&gt; &#123; return getters[getterName](this.state); &#125;, &#125;); &#125;); let mutations = options.mutations || &#123;&#125;; this.mutations = &#123;&#125;; Object.keys(mutations).forEach((mutationName) =&gt; &#123; this.mutations[mutationName] = (arg) =&gt; &#123; mutations[mutationName](this.state, arg); &#125;; &#125;); let actions = options.actions; this.actions = &#123;&#125;; Object.keys(actions).forEach((actionName) =&gt; &#123; this.actions[actionName] = (arg) =&gt; &#123; actions[actionName](this, arg); &#125;; &#125;); &#125; dispatch(method, arg) &#123; this.actions[method](arg); &#125; // 修改代码 commit = (method, arg) =&gt; &#123; console.log(method); console.log(this.mutations); this.mutations[method](arg); &#125;; get state() &#123; return this.vm.state; &#125;&#125; 再来测试 完美收官！！！！ 转载手写 Vuex 核心原理，再也不怕面试官问我 Vuex 原理","updated":"2025-08-02T05:46:04.180Z","tags":[]},{"title":"Vue原理","date":"2022-07-16T06:55:26.000Z","path":"2022/07/16/2022-07-16-vue-theory/","text":"vue 双向绑定原理 【原理题】 核心实现类:Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新 Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。 Watcher : 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种 Watcher 和 Dep 的关系watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。 依赖收集initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集initState 时,对侦听属性初始化时,触发 user watcher 依赖收集render()的过程,触发 render watcher 依赖收集re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。派发更新组件中对响应的数据进行了修改,触发 setter 的逻辑调用 dep.notify()遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。原理当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。 每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。 一句话总结: vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调 自己实现一个 Vue 的双向绑定 computed 的实现原理【原理题】computed 本质是一个惰性求值的观察者。 computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。 其内部通过 this.dirty 属性标记计算属性是否需要重新求值。 当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher, computed watcher 通过 this.dep.subs.length 判断有没有订阅者, 有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。) 没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。) computed 和 watch 有什么区别及运用场景?【原理题】 区别 computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。 【简单表达： 依赖缓存，依赖的值变化了才会自动变化】 watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。 【简单表达：watch 监听数变化，无缓存依赖，监听的值变化了他就变化】 运用场景 当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。 【不能放异步】 当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。 【可以放异步处理】 为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？【原理题】Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(Vue 为什么不能检测数组变动 )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组 push();pop();shift();unshift();splice();sort();reverse(); 由于只针对了以上 7 种方法进行了 hack 处理,所以其他数组的属性也是检测不到的,还是具有一定的局限性。 **Object.defineProperty 只能劫持对象的属性,**因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。 Vue 中的 key 到底有什么用？【原理题】回答： 【简单表达：为了防止就地复用！】 key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。) diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点. 更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。 更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1),源码如下: function createKeyToOldIdx(children, beginIdx, endIdx) &#123; let i, key; const map = &#123;&#125;; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key; if (isDef(key)) map[key] = i; &#125; return map;&#125; 谈一谈 nextTick 的原理【原理题】JS 运行机制 JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤: 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。主线程不断重复上面的第三步。 主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。 for (macroTask of macroTaskQueue) &#123; // 1. Handle current MACRO-TASK handleMacroTask(); // 2. Handle all MICRO-TASK for (microTask of microTaskQueue) &#123; handleMicroTask(microTask); &#125;&#125; 在浏览器环境中 : 常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate 常见的 micro task 有 MutationObsever 和 Promise.then 异步更新队列 可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。 如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。 然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout vue 的 nextTick 方法的实现原理: vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行 microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案 如何判断 dom 更新完成后，再执行 nextTick 后的函数实际上 dom 更新是实时的，所以不会阻塞，使用微任务后，可以保证所执行的方法在 dom 更新后 vue 是如何对数组方法进行变异的 ?【原理题】我们先来看看源码 const arrayProto = Array.prototype;export const arrayMethods = Object.create(arrayProto);const methodsToPatch = [&#x27;push&#x27;, &#x27;pop&#x27;, &#x27;shift&#x27;, &#x27;unshift&#x27;, &#x27;splice&#x27;, &#x27;sort&#x27;, &#x27;reverse&#x27;];/** * Intercept mutating methods and emit events */methodsToPatch.forEach(function (method) &#123; // cache original method const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) &#123; const result = original.apply(this, args); const ob = this.__ob__; let inserted; switch (method) &#123; case &#x27;push&#x27;: case &#x27;unshift&#x27;: inserted = args; break; case &#x27;splice&#x27;: inserted = args.slice(2); break; &#125; if (inserted) ob.observeArray(inserted); // notify change ob.dep.notify(); return result; &#125;);&#125;);/** * Observe a list of Array items. */Observer.prototype.observeArray = function observeArray(items) &#123; for (var i = 0, l = items.length; i &lt; l; i++) &#123; observe(items[i]); &#125;&#125;; 简单来说,Vue 通过原型拦截的方式重写了数组的 7 个方法,首先获取到这个数组的 ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update Vue 组件 data 为什么必须是函数 ?【原理题】new Vue()实例中,data 可以直接是一个对象,为什么在 vue 组件中,data 必须是一个函数呢?因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。 所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。 谈谈 Vue 事件机制,手写$on,$off,$emit,$once 【原理题】Vue 事件机制 本质上就是 一个 发布-订阅 模式的实现。 class Vue &#123; constructor() &#123; // 事件通道调度中心 this._events = Object.create(null); &#125; $on(event, fn) &#123; if (Array.isArray(event)) &#123; event.map(item =&gt; &#123; this.$on(item, fn); &#125;); &#125; else &#123; (this._events[event] || (this._events[event] = [])).push(fn); &#125; return this; &#125; $once(event, fn) &#123; function on() &#123; this.$off(event, on); fn.apply(this, arguments); &#125; on.fn = fn; this.$on(event, on); return this; &#125; $off(event, fn) &#123; if (!arguments.length) &#123; this._events = Object.create(null); return this; &#125; if (Array.isArray(event)) &#123; event.map(item =&gt; &#123; this.$off(item, fn); &#125;); return this; &#125; const cbs = this._events[event]; if (!cbs) &#123; return this; &#125; if (!fn) &#123; this._events[event] = null; return this; &#125; let cb; let i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1); break; &#125; &#125; return this; &#125; $emit(event) &#123; let cbs = this._events[event]; if (cbs) &#123; const args = [].slice.call(arguments, 1); cbs.map(item =&gt; &#123; args ? item.apply(this, args) : item.call(this); &#125;); &#125; return this; &#125;&#125; 说说 Vue 的渲染过程 【原理题】调用 compile 函数,生成 render 函数字符串 ,编译过程如下: parse 函数解析 template,生成 ast(抽象语法树) optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)generate 函数生成 render 函数字符串 调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素 聊聊 keep-alive 的实现原理和缓存策略 【原理题】export default &#123; name: &#x27;keep-alive&#x27;, abstract: true, // 抽象组件属性 ,它在组件实例建立父子关系的时候会被忽略,发生在 initLifecycle 的过程中 props: &#123; include: patternTypes, // 被缓存组件 exclude: patternTypes, // 不被缓存组件 max: [String, Number], // 指定缓存大小 &#125;, created() &#123; this.cache = Object.create(null); // 缓存 this.keys = []; // 缓存的VNode的键 &#125;, destroyed() &#123; for (const key in this.cache) &#123; // 删除所有缓存 pruneCacheEntry(this.cache, key, this.keys); &#125; &#125;, mounted() &#123; // 监听缓存/不缓存组件 this.$watch(&#x27;include&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; matches(val, name)); &#125;); this.$watch(&#x27;exclude&#x27;, val =&gt; &#123; pruneCache(this, name =&gt; !matches(val, name)); &#125;); &#125;, render() &#123; // 获取第一个子元素的 vnode const slot = this.$slots.default; const vnode: VNode = getFirstComponentChild(slot); const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions; if (componentOptions) &#123; // name不在inlcude中或者在exlude中 直接返回vnode // check pattern const name: ?string = getComponentName(componentOptions); const &#123; include, exclude &#125; = this; if ( // not included (include &amp;&amp; (!name || !matches(include, name))) || // excluded (exclude &amp;&amp; name &amp;&amp; matches(exclude, name)) ) &#123; return vnode; &#125; const &#123; cache, keys &#125; = this; // 获取键，优先获取组件的name字段，否则是组件的tag const key: ?string = vnode.key == null ? // same constructor may get registered as different local components // so cid alone is not enough (#3269) componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : &#x27;&#x27;) : vnode.key; // 命中缓存,直接从缓存拿vnode 的组件实例,并且重新调整了 key 的顺序放在了最后一个 if (cache[key]) &#123; vnode.componentInstance = cache[key].componentInstance; // make current key freshest remove(keys, key); keys.push(key); &#125; // 不命中缓存,把 vnode 设置进缓存 else &#123; cache[key] = vnode; keys.push(key); // prune oldest entry // 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个 if (this.max &amp;&amp; keys.length &gt; parseInt(this.max)) &#123; pruneCacheEntry(cache, keys[0], keys, this._vnode); &#125; &#125; // keepAlive标记位 vnode.data.keepAlive = true; &#125; return vnode || (slot &amp;&amp; slot[0]); &#125;,&#125;; 原理 获取 keep-alive 包裹着的第一个子组件对象及其组件名根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例根据组件 ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值,超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到,这里不细说 LRU 缓存淘汰算法 LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据,其核心思想是“如果数据最近被访问过,那么将来被访问的几率也更高”。 keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0] vm.$set()实现原理是什么? 【原理题】受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。 由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。 那么 Vue 内部是如何解决对象新增属性不能响应的问题的呢? export function set(target: Array | Object, key: any, val: any): any &#123; // target 为数组 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 修改数组的长度, 避免索引&gt;数组长度导致splice()执行有误 target.length = Math.max(target.length, key); // 利用数组的splice变异方法触发响应式 target.splice(key, 1, val); return val; &#125; // target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val; &#125; // 以上都不成立, 即开始给target创建一个全新的属性 // 获取Observer实例 const ob = (target: any).__ob__; // target 本身就不是响应式数据, 直接赋值 if (!ob) &#123; target[key] = val; return val; &#125; // 进行响应式处理 defineReactive(ob.value, key, val); ob.dep.notify(); return val;&#125; 如果目标是数组,使用 vue 实现的变异方法 splice 实现响应式如果目标是对象,判断属性存在,即为响应式,直接赋值如果 target 本身就不是响应式,直接赋值如果属性不是响应式,则调用 defineReactive 方法进行响应式处理 Vue.use 方法的实现原理Vue.use(plugin); （1）参数 plugin &#123; Object | Function;&#125; （2）用法 安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。调用 install 方法时，会将 Vue 作为参数传入。install 方法被同一个插件多次调用时，插件也只会被安装一次。 关于如何上开发 Vue 插件，请看这篇文章，非常简单，不用两分钟就看完：如何开发 Vue 插件？ （3）作用 注册插件，此时只需要调用 install 方法并将 Vue 作为参数传入即可。但在细节上有两部分逻辑要处理： 1、插件的类型，可以是 install 方法，也可以是一个包含 install 方法的对象。 2、插件只能被安装一次，保证插件列表中不能有重复的插件。 （4）实现 Vue.use = function (plugin) &#123; const installedPlugins = this._installedPlugins || (this._installedPlugins = []); if (installedPlugins.indexOf(plugin) &gt; -1) &#123; return this; &#125; // 其他参数 const args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &#x27;function&#x27;) &#123; plugin.install.apply(plugin, args); &#125; else if (typeof plugin === &#x27;function&#x27;) &#123; plugin.apply(null, plugin, args); &#125; installedPlugins.push(plugin); return this;&#125;; 1、在 Vue 对象 上新增了 use 方法，并接收一个参数 plugin。 2、首先判断插件是不是已经别注册过，如果被注册过，则直接终止方法执行，此时只需要使用 indexOf 方法即可。 3、toArray 方法我们在就是将类数组转成真正的数组。使用 toArray 方法得到 arguments。除了第一个参数之外，剩余的所有参数将得到的列表赋值给 args，然后将 Vue 添加到 args 列表的最前面。这样做的目的是保证 install 方法被执行时第一个参数是 Vue，其余参数是注册插件时传入的参数。 4、由于 plugin 参数支持对象和函数类型，所以通过判断 plugin.install 和 plugin 哪个是函数，即可知用户使用哪种方式祖册的插件，然后执行用户编写的插件并将 args 作为参数传入。 5、最后，将插件添加到 installedPlugins 中，保证相同的插件不会反复被注册。 Vuex 的原理vuex 本质是挂载一个名为 store 的 vm 组件在 Vue 的上下文环境 1.所以 this.$store 都是执行绑定的同一个 sotre 2.同时 state 因为在 vm 组件里面的 data, data 是使用new Vue()去创建一个 Vue 组件–所以具备响应式 为什么一定要用 mutation 中修改 statestate 修改的源码–mutation操作是调用_withCommit _withCommit (fn) &#123; // 保存之前的提交状态 const committing = this._committing // 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告 this._committing = true // 执行state的修改操作 fn() // 修改完成，还原本次修改之前的状态 this._committing = committing&#125; Vuex 核心原理","updated":"2025-08-02T05:46:04.180Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"angular 路由","date":"2022-07-09T02:59:05.000Z","path":"2022/07/09/2022-07-09-angular-router/","text":"路由注册&lt;router-outlet&gt;&lt;/router-outlet&gt;是 angular 路由的占位元素，表示要把对应的路由组件渲染到router-outlet中使用angular router的项目，需使用&lt;a routerLink=&quot;/crisis-center&quot;&gt;Crisis Center&lt;/a&gt;的形式，才能在 angular 内部跳转 html &lt;h1&gt;Angular Router&lt;/h1&gt;&lt;nav&gt; &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot; ariaCurrentWhenActive=&quot;page&quot;&gt;Crisis Center&lt;/a&gt; &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot; ariaCurrentWhenActive=&quot;page&quot;&gt;Heroes&lt;/a&gt;&lt;/nav&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 把 RouterModule.forRoot() 注册到 AppModule 的 imports 数组中，能让该 Router 服务在应用的任何地方都能使用。 module import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; FormsModule &#125; from &#x27;@angular/forms&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;import &#123; CrisisListComponent &#125; from &#x27;./crisis-list/crisis-list.component&#x27;;import &#123; HeroListComponent &#125; from &#x27;./hero-list/hero-list.component&#x27;;const appRoutes: Routes = [ &#123; path: &#x27;crisis-center&#x27;, component: CrisisListComponent &#125;, &#123; path: &#x27;heroes&#x27;, component: HeroListComponent &#125;,];@NgModule(&#123; imports: [ BrowserModule, FormsModule, RouterModule.forRoot( appRoutes, &#123; enableTracing: true &#125; // &lt;-- debugging purposes only ), ], declarations: [AppComponent, HeroListComponent, CrisisListComponent], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; forRoot在一个 angular 项目中只能出现一次，如果想在其他模块中在引入子路由，应使用forChild 配置路由跳转规则添加一个 redirect 路由，把最初的相对 URL（&#39;&#39;）转换成所需的默认路径（/heroes）。&#39;**&#39;表示没有任何匹配时，跳转到对应的没有页面提示 const appRoutes: Routes = [ &#123; path: &#x27;crisis-center&#x27;, component: CrisisListComponent &#125;, &#123; path: &#x27;heroes&#x27;, component: HeroListComponent &#125;, &#123; path: &#x27;&#x27;, redirectTo: &#x27;/heroes&#x27;, pathMatch: &#x27;full&#x27; &#125;, &#123; path: &#x27;**&#x27;, component: PageNotFoundComponent &#125;,]; 路由模块声明一个路由文件 src/app/app-routing.module.ts import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; RouterModule, Routes &#125; from &#x27;@angular/router&#x27;;import &#123; CrisisListComponent &#125; from &#x27;./crisis-list/crisis-list.component&#x27;;import &#123; HeroListComponent &#125; from &#x27;./hero-list/hero-list.component&#x27;;import &#123; PageNotFoundComponent &#125; from &#x27;./page-not-found/page-not-found.component&#x27;;const appRoutes: Routes = [ &#123; path: &#x27;crisis-center&#x27;, component: CrisisListComponent &#125;, &#123; path: &#x27;heroes&#x27;, component: HeroListComponent &#125;, &#123; path: &#x27;&#x27;, redirectTo: &#x27;/heroes&#x27;, pathMatch: &#x27;full&#x27; &#125;, &#123; path: &#x27;**&#x27;, component: PageNotFoundComponent &#125;,];@NgModule(&#123; imports: [ RouterModule.forRoot( appRoutes, &#123; enableTracing: true &#125; // &lt;-- debugging purposes only ), ], exports: [RouterModule],&#125;)export class AppRoutingModule &#123;&#125; src/app/app.module.ts import &#123; NgModule &#125; from &#x27;@angular/core&#x27;;import &#123; BrowserModule &#125; from &#x27;@angular/platform-browser&#x27;;import &#123; FormsModule &#125; from &#x27;@angular/forms&#x27;;import &#123; AppComponent &#125; from &#x27;./app.component&#x27;;import &#123; AppRoutingModule &#125; from &#x27;./app-routing.module&#x27;;import &#123; CrisisListComponent &#125; from &#x27;./crisis-list/crisis-list.component&#x27;;import &#123; HeroListComponent &#125; from &#x27;./hero-list/hero-list.component&#x27;;import &#123; PageNotFoundComponent &#125; from &#x27;./page-not-found/page-not-found.component&#x27;;@NgModule(&#123; imports: [BrowserModule, FormsModule, AppRoutingModule], declarations: [AppComponent, HeroListComponent, CrisisListComponent, PageNotFoundComponent], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 路由参数&#123; path: &#x27;hero/:id&#x27;, component: HeroDetailComponent &#125; &lt;a [routerLink]=&quot;[&#x27;/hero&#x27;, hero.id]&quot;&gt;&lt;/a&gt; 如何在对应的组件中拿到 id 的参数 import &#123; Router, ActivatedRoute, ParamMap &#125; from &#x27;@angular/router&#x27;;import &#123; switchMap &#125; from &#x27;rxjs/operators&#x27;;constructor( private route: ActivatedRoute, private router: Router, private service: HeroService) &#123;&#125;ngOnInit() &#123; this.hero$ = this.route.paramMap.pipe( switchMap((params: ParamMap) =&gt; this.service.getHero(params.get(&#x27;id&#x27;)!)) );&#125; 当这个 map 发生变化时，paramMap 会从更改后的参数中获取 id 参数。 当用户从一个详情列表跳转到另一个详情列表中时，angular 会复用这个组件，所以需要订阅 router 对象的变化，才能出发详情列表路由参数的变化 activateRouter监听ActivatedRoute也能拿到路由的参数值 constructor(private activatedRoute: ActivatedRoute)&#123;&#125;this.activatedRoute.params.subscribe(params =&gt; &#123; this.deviceId = params.deviceId;&#125;); sanpshot本应用不需要复用 HeroDetailComponent。用户总是会先返回英雄列表，再选择另一位英雄。所以，不存在从一个英雄详情导航到另一个而不用经过英雄列表的情况。这意味着路由器每次都会创建一个全新的 HeroDetailComponent 实例。 假如你很确定这个 HeroDetailComponent 实例永远不会被复用，你可以使用 snapshot。 ngOnInit() &#123; const id = this.route.snapshot.paramMap.get(&#x27;id&#x27;)!; this.hero$ = this.service.getHero(id);&#125; 用这种技术，snapshot 只会得到这些参数的初始值。如果路由器可能复用该组件，那么就该用 paramMap 可观察对象的方式。本教程的示例应用中就用了 paramMap 可观察对象。 第二路由使用 2 个router-outlet，但是彼此并不互相影响 &lt;div [@routeAnimation]=&quot;getAnimationData()&quot;&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt;&lt;/div&gt;&lt;router-outlet name=&quot;popup&quot;&gt;&lt;/router-outlet&gt; 注册第二路由module &#123; path: &#x27;compose&#x27;, component: ComposeMessageComponent, outlet: &#x27;popup&#x27;&#125;, 如何跳转到第二路由 &lt;a [routerLink]=&quot;[&#123; outlets: &#123; popup: [&#x27;compose&#x27;] &#125; &#125;]&quot;&gt;Contact&lt;/a&gt; 因为第二路由与主路由不相互影响，即使在主路由发生变化时，第二路由显示的组件也不会消失，所以适用于：需要一直显示的组件，比如弹窗，需要在不同的页面都显示 那么如何清除第二路由 closePopup() &#123; // Providing a `null` value to the named outlet // clears the contents of the named outlet this.router.navigate([&#123; outlets: &#123; popup: null &#125;&#125;]);&#125; 路由守卫 守卫接口 详情 CanActivate 导航到某路由时介入 CanActivateChild 导航到某个子路由时介入 CanDeactivate 从当前路由离开时介入 Resolve 在某路由激活之前获取路由数据 CanLoad 导航到某个异步加载的特性模块时介入 守卫返回的值 详情 true 导航过程会继续 false 导航过程就会终止，且用户留在原地。 UrlTree 取消当前导航，并开始导航到所返回的 UrlTree const crisisCenterRoutes: Routes = [ &#123; path: &#x27;crisis-center&#x27;, component: CrisisCenterComponent, children: [ &#123; path: &#x27;&#x27;, component: CrisisListComponent, children: [ &#123; path: &#x27;:id&#x27;, component: CrisisDetailComponent, canDeactivate: [CanDeactivateGuard], resolve: &#123; crisis: CrisisDetailResolverService, &#125;, &#125;, &#123; path: &#x27;&#x27;, component: CrisisCenterHomeComponent, &#125;, ], &#125;, ], &#125;,]; 路由懒加载&#123; path: &#x27;admin&#x27;, loadChildren: () =&gt; import(&#x27;./admin/admin.module&#x27;).then(m =&gt; m.AdminModule),&#125;, 预加载这项配置会让 Router 预加载器立即加载所有惰性加载路由（带 loadChildren 属性的路由）。 RouterModule.forRoot(appRoutes, &#123; enableTracing: true, // &lt;-- debugging purposes only preloadingStrategy: PreloadAllModules,&#125;); 参考angular router","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"typescript中private、public、protected、static、abstract、readonly","date":"2022-05-01T10:25:34.000Z","path":"2022/05/01/2022-05-01-typescript-type-of-var/","text":"字段名 范围 private 类内部 public （默认）类内部和外部、及其子类都可访问 protected 类内部和其子类（区别与 public，即当前类实例化不可访问） static 存在于类本身而不是类的实例上 abstract 定义抽象类和在抽象类内部定义抽象方法，做为其它派生类的基类使用，一般不会直接被实例化 readonly 只读属性 多个关键字可以同时使用默认不写都为 public构造函数被标记成 [protected]。 这意味着这个类不能在包含它的类外被实例化，但是能被继承class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&#x27;Howard&#x27;, &#x27;Sales&#x27;);let john = new Person(&#x27;John&#x27;); // 错误: &#x27;Person&#x27; 的构造函数是被保护的. [readonly] 关键字将属性设置为只读的class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(&#x27;Man with the 8 strong legs&#x27;);dad.name = &#x27;Man with the 3-piece suit&#x27;; // 错误! name 是只读的. [static] 关键字，使得属性存在于类本身而不是类的实例上class Test &#123; static $name: string = &#x27;bob&#x27;;&#125;console.log(Test.$name); // bob [abstract]关键字是用于定义抽象类和在抽象类内部定义抽象方法，做为其它派生类的基类使用，一般不会直接被实例化abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log(&#x27;roaming the earch...&#x27;); &#125;&#125; abstract 和 protected 区别abstract 关键字方法属性必须被[子类]定义，当前类不可实例化，子类实例可直接输出；protected 关键字方法属性仅可被当前类和子类使用，不可直接输出 abstract class Father &#123; protected name: string = &#x27;bob&#x27;; abstract age: number = 12;&#125;class Son1 extends Father &#123; age: number; sayName() &#123; console.log(this.name); &#125;&#125;class Son2 extends Son1 &#123; age: number; sayName() &#123; console.log(this.name); &#125;&#125;const s1 = new Son1();const s2 = new Son2();console.log(s1.name, s2.name); // Errorconsole.log(s1.age, s2.age);console.log(s1.sayName(), s2.sayName());","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://luckyship.github.io/tags/typescript/"}]},{"title":"前端debugger技巧","date":"2022-03-13T13:26:16.000Z","path":"2022/03/13/2022-03-13-frontend-debugger/","text":"导言开发环境 debug 是每个程序员上岗的必备技能。生产环境呢？虽然生产环境 debug 是一件非常不优雅的行为，但是由于种种原因，我们又不得不这么干。 那我们今天讲一讲如何使用 chrome 在生产环境进行 debug 。 生产环境 debug 步骤生产环境 debug 需要几步？这问题和“把大象装进冰箱拢共分几步”一样简单。 第一步，把冰箱门打开。F12 打开 devTools； 第二步，把大象装进冰箱。找到需要 debug 的前端文件，格式化，打断点，调试上下文，定位问题； 第三步，关闭冰箱门。解决问题。 如何快速定位错误是前端还是后端接口返回的？在把大象装进冰箱之前，先初步判断下，是否真的需要由你将大象装进冰箱。 首先我们需要判断，错误是前端还是后端报的，那么如何快速判断？ 方案一：根据对代码的实现的了解，判断报错属于前端还是后端。这个方案前提是需要你对代码实现很熟悉，也是最简单的方式。 方案二：前端代码全局搜索关键字，工程代码里搜索/控制台打开搜索。对应工程 gitlab 或者 vscode 或者 devTools global search 里去进行全局搜索。 方案三：翻阅 network 面板中的请求。翻阅 network 面板中的请求，看下返回的 response 是否携带错误提示，有则表示后端返回的；如果报错的接口刚好是以非200 的状态返回，或者是由新的操作触发调用接口，我们很快就能查找到对应的接口 方案四：使用 network search 进行搜索。但是很多情况，接口业务错误会以 http status 200 的状态码返回，如果此时请求了大量的接口（举个例子：进入页面调用了大量的接口，其中有一个接口返回了错误信息），那么除了逐个翻阅 network 这种低效的方式，chrome devTools 还提供了 network search 面板这种更便捷的方式，可以搜索接口详细信息（包括详细的返回信息），返回匹配结果。 如何打开 network search 面板？ 在 network 面板中，按快捷键 ⌘ + F（Mac）、 CTRL + F（Windows）可呼出 network search 面板。如果确定需要你把大象装进冰箱，那把大象装进冰箱的技巧有哪些？ 如何快速定位到问题相关的代码global search ，全局搜素关键字，再定位到关键的代码chrome devTools 的 global search 是一个非常实用的一个功能，当你不知道需要调试的代码在哪个文件时，当你是一个非常大的系统，引用了很多的资源文件，你可以使用 global search 进行搜索关键字，这个操作会搜索所有加载进来的资源，点击搜索结果，就可以使用 source 面板打开对应的资源文件，然后格式化代码，再然后在当前的文件内 再次搜索关键字，打断点。 打开 global search 快捷键： ⌘ + ⌥ + F （Mac），CTRL + SHIFT + F （Windows） 看下图例子，我们随便找个页面根据提示搜索代码： 可以尝试使用哪些关键字进行搜索： (1) 页面存在明确的报错信息，且已经明确该错误文案是写在前端代码中错误信息文案。提示信息在 coding 过程中一般是使用 字符串，压缩混淆过程中一般是不会进行处理的，会保留原文，当然代码打包构建过程中，对代码压缩混淆也可以选择对中文进行 unicode 转码，此时如果关键字是中文，就需要先转码再搜索了。 (2) 已知相关代码中存在的编译混淆后依然还保留的的关键代码，会向外暴露的方法名； 如何 debug 混淆后的 js ？生产环境的 js 基本上都是混淆过的（点击了解前端代码的压缩混淆 (https://todo.com/)），压缩混淆的优点就不赘述了，压缩混淆后随之来的是生产环境调试的难度，虽然通过打断点，勉强还能看的懂，但是已经很反人类了。 我们用一个最简单的 demo ，对比一下代码生产环境构建编译前后的差距。 这里选择用 vue-cli 创建了一个最简单的 demo ，看下源代码和编译后的代码。 源代码： 构建编译后的代码（此处关闭了 sourceMap ）： 这里我们看到构建编译后的代码做了压缩混淆，出现了出现了大量大的 a 、b 、 c 、 d 替换了原有的函数方法名、变量名，编译后的代码已经不是能通过单纯的读代码码能读懂的了。但是我们通过 debug ，大概还是能看得懂。 那么有没有方式使用本地的 sourceMap 调试生产环境的代码？答案当然是有的。 如何在生产环境使用本地 sourceMap 调试？第一步：打开混淆代码 第二步：右键 -&gt; 选择【Add source map】 第三步：输入本地 sourceMap 的地址（此处需要启用一个静态资源服务，可以使用 http-server (https://www.npmjs.com/package/http-server)），完成。本地代码执行构建命令，注意需要打开 sourceMap 配置，编译产生出构建后的代码，此时构建后的结果会包含 sourceMap 文件。 关联上 sourceMap 后，我们就可以看到 sources -&gt; page 面板上的变化了 如何在 chrome 中修改代码并调试？开发环境中，我们可以直接在 IDE 中修改代码，代码的变更就直接更新到了浏览器中了。那么生产环境，我们可以直接在 chrome 中修改代码，然后立马看代码修改后的效果吗？ 当然，你想要的 chrome devTools 都有。chrome devTools 提供了 local overrides 能力。 local overrides 如何工作的？指定修改后的文件的本地保存目录，当修改完代码保存的时候，就会将修改后的文件保存到你指定的目录目录下，当再次加载页面的时候，对应的文件不再读取网络上的文件，而是读取存储在本地修改过的文件。 local overrides 如何使用？首先，打开 sources 下的 overrides 面板； 然后，点击【select folder overrides】选择修改后的文件存储地址； 再然后，点击顶部的授权，确认同意； 最后，我们就可以打开文件修改，修改完成后保存，重新刷新页面后，修改后的代码就被执行到了。 ⚠️ 注意，原 js 文件直接 format 是无法修改的；在代码 format 之前先添加无效代码进行代码变更进行保存，然后再 format 就可以修改 总结chrome 调试技巧远远当然不只这些，以上只是生产环境 debug 的小技巧，祝愿大家用不到，最好的 bug 处理方式当然是事前，在上线前得到就解决；如果真的发生问题，如果做好监控和日志，在问题发生的第一时间发现并解决。","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"算法中的时间复杂度","date":"2022-03-13T06:50:11.000Z","path":"2022/03/13/2022-03-13-time-complexity/","text":"如何计算时间复杂度我们来看一道题目： 力扣题目链接 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。 示例： 输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 暴力破解这道题目暴力解法当然是 两个 for 循环，然后不断的寻找符合条件的子序列，时间复杂度很明显是$O(n^2)$。 代码如下： class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int result = INT32_MAX; // 最终的结果 int sum = 0; // 子序列的数值之和 int subLength = 0; // 子序列的长度 for (int i = 0; i &lt; nums.size(); i++) &#123; // 设置子序列起点为i sum = 0; for (int j = i; j &lt; nums.size(); j++) &#123; // 设置子序列终止位置为j sum += nums[j]; if (sum &gt;= s) &#123; // 一旦发现子序列和超过了s，更新result subLength = j - i + 1; // 取子序列的长度 result = result &lt; subLength ? result : subLength; break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break &#125; &#125; &#125; // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列 return result == INT32_MAX ? 0 : result; &#125;&#125;; 滑动窗口接下来就开始介绍数组操作中另一个重要的方法：滑动窗口。 所谓滑动窗口，就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。 var minSubArrayLen = function (target, nums) &#123; // 长度计算一次 const len = nums.length; let l = (r = sum = 0), res = len + 1; // 子数组最大不会超过自身 while (r &lt; len) &#123; sum += nums[r++]; // 窗口滑动 while (sum &gt;= target) &#123; // r始终为开区间 [l, r) res = res &lt; r - l ? res : r - l; sum -= nums[l++]; &#125; &#125; return res &gt; len ? 0 : res;&#125;; 时间复杂度：$O(n)$ 空间复杂度：$O(1)$ 为什么时间复杂度是$O(n)$。不要以为 for 里放一个 while 就以为是$O(n^2)$啊， 主要是看每一个元素被操作的次数，每个元素在滑动窗后进来操作一次，出去操作一次，每个元素都是被被操作两次，所以时间复杂度是 2 × n 也就是$O(n)$。 而暴力破解，最坏的情况，最后一个元素每个循环都要被用到，所以是 $O(n^2)$","updated":"2025-08-02T05:46:04.179Z","tags":[]},{"title":"Vite介绍","date":"2022-02-26T02:42:45.000Z","path":"2022/02/26/2022-02-26-vite/","text":"Vite 是什么？Vite是新一代的前端构建工具，在尤雨溪开发Vue3.0的时候诞生。类似于Webpack+ Webpack-dev-server。其主要利用浏览器ESM特性导入组织代码，在服务器端按需编译返回，完全跳过了打包这个概念，服务器随起随用。生产中利用Rollup作为打包工具，号称下一代的前端构建工具。 Vite有如下特点： 快速的冷启动: No Bundle + esbuild 预构建 即时的模块热更新: 基于ESM的HMR，同时利用浏览器缓存策略提升速度 真正的按需加载: 利用浏览器ESM支持，实现真正的按需加载 Vite 和传统打包方式的对比 VS WebapckWebpack是近年来使用量最大，同时社区最完善的前端打包构建工具，新出的5.x版本对构建细节进行了优化，在部分场景下打包速度提升明显。Webpack在启动时，会先构建项目模块的依赖图，如果在项目中的某个地方改动了代码，Webpack则会对相关的依赖重新打包，随着项目的增大，其打包速度也会下降。 Vite相比于Webpack而言，没有打包的过程，而是直接启动了一个开发服务器 devServer。Vite劫持浏览器的HTTP请求，在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再返回给浏览器(整个过程没有对文件进行打包编译)。所以编译速度很快。 VS SnowPackSnowpack 首次提出利用浏览器原生ESM能力的打包工具，其理念就是减少或避免整个bundle的打包。默认在 dev 和 production 环境都使用 unbundle 的方式来部署应用。但是它的构建时却是交给用户自己选择，整体的打包体验显得有点支离破碎。 而 Vite 直接整合了 Rollup，为用户提供了完善、开箱即用的解决方案，并且由于这些集成，也方便扩展更多的高级功能。 两者较大的区别是在需要bundle打包的时候Vite 使用 Rollup 内置配置，而 Snowpack 通过其他插件将其委托给 Parcel/``webpack。 前置知识ESM在了解Vite之前，需要先了解下ESM ESM是JavaScript提出的官方标准化模块系统，不同于之前的CJS，AMD，CMD等等，ESM提供了更原生以及更动态的模块加载方案，最重要的就是它是浏览器原生支持的，也就是说我们可以直接在浏览器中去执行import，动态引入我们需要的模块，而不是把所有模块打包在一起。 目前ESM模块化已经支持 92%以上的浏览器，而且且作为 ECMA 标准，未来会有更多浏览器支持ECMA规范 当我们在使用模块开发时，其实就是在构建一张模块依赖关系图，当模块加载时，就会从入口文件开始，最终生成完整的模块实例图。 ESM的执行可以分为三个步骤： 构建: 确定从哪里下载该模块文件、下载并将所有的文件解析为模块记录 实例化: 将模块记录转换为一个模块实例，为所有的模块分配内存空间，依照导出、导入语句把模块指向对应的内存地址。 运行：运行代码，将内存空间填充 从上面实例化的过程可以看出，ESM使用实时绑定的模式，导出和导入的模块都指向相同的内存地址，也就是值引用。而CJS采用的是值拷贝，即所有导出值都是拷贝值。 EsbuildVite底层使用Esbuild实现对.``ts、jsx、.``js代码文件的转化，所以先看下什么是es-build。 Esbuild是一个JavaScript Bundler 打包和压缩工具，它提供了与Webpack、Rollup等工具相似的资源打包能力。可以将JavaScript 和TypeScript代码打包分发在网页上运行。但其打包速度却是其他工具的 10 ～ 100 倍。 目前他支持以下的功能： 加载器 压缩 打包 Tree shaking Source map生成 esbuild总共提供了四个函数：transform、build、buildSync、Service。有兴趣的可以移步官方文档了解。 Rollup在生产环境下，Vite使用Rollup来进行打包 Rollup是基于ESM的JavaScript打包工具。相比于其他打包工具如Webpack，他总是能打出更小、更快的包。因为 Rollup 基于 ESM 模块，比 Webpack 和 Browserify 使用的 CommonJS模块机制更高效。Rollup的亮点在于同一个地方，一次性加载。能针对源码进行 Tree Shaking(去除那些已被定义但没被使用的代码)，以及 Scope Hoisting 以减小输出文件大小提升运行性能。 Rollup分为build（构建）阶段和output generate（输出生成）阶段。主要过程如下： 获取入口文件的内容，包装成module，生成抽象语法树 对入口文件抽象语法树进行依赖解析 生成最终代码 写入目标文件 如果你的项目（特别是类库）只有JavaScript，而没有其他的静态资源文件，使用Webpack就有点大才小用了。因为Webpack 打包的文件的体积略大，运行略慢，可读性略低。这时候Rollup也不失为一个好选择。 这里想对 Rollp 进行更深入的学习可以看看官网的介绍。 核心原理详细阐述下： 当声明一个 script标签类型为 module 时,如 &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;复制代码 当浏览器解析资源时，会往当前域名发起一个GET请求main.js文件 // main.jsimport &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;createApp(App).mount(&#x27;#app&#x27;)复制代码 请求到了main.js文件，会检测到内部含有import引入的包，又会import 引用发起HTTP请求获取模块的内容文件，如App.vue、vue文件 Vite其核心原理是利用浏览器现在已经支持ES6的import,碰见import就会发送一个HTTP请求去加载文件，Vite启动一个 koa 服务器拦截这些请求，并在后端进行相应的处理将项目中使用的文件通过简单的分解与整合，然后再以ESM格式返回返回给浏览器。Vite整个过程中没有对文件进行打包编译，做到了真正的按需加载，所以其运行速度比原始的webpack开发编译速度快出许多！ 基于 ESM 的 Dev server在Vite出来之前，传统的打包工具如Webpack是先解析依赖、打包构建再启动开发服务器，Dev Server 必须等待所有模块构建完成，当我们修改了 bundle模块中的一个子模块， 整个 bundle 文件都会重新打包然后输出。项目应用越大，启动时间越长。 而Vite利用浏览器对ESM的支持，当 import 模块时，浏览器就会下载被导入的模块。先启动开发服务器，当代码执行到模块加载时再请求对应模块的文件,本质上实现了动态加载。灰色部分是暂时没有用到的路由，所有这部分不会参与构建过程。随着项目里的应用越来越多，增加route，也不会影响其构建速度。 基于 ESM 的 HMR 热更新目前所有的打包工具实现热更新的思路都大同小异：主要是通过WebSocket创建浏览器和服务器的通信监听文件的改变，当文件被修改时，服务端发送消息通知客户端修改相应的代码，客户端对应不同的文件进行不同的操作的更新。 VS WebpackWebpack: 重新编译，请求变更后模块的代码，客户端重新加载 Vite: 请求变更的模块，再重新加载 Vite 通过 chokidar 来监听文件系统的变更，只用对发生变更的模块重新加载， 只需要精确的使相关模块与其临近的 HMR边界连接失效即可，这样HMR 更新速度就不会因为应用体积的增加而变慢而 Webpack 还要经历一次打包构建。所以 HMR 场景下，Vite 表现也要好于 Webpack。 核心流程Vite整个热更新过程可以分成四步 创建一个websocket服务端和client文件，启动服务 通过chokidar监听文件变更 当代码变更后，服务端进行判断并推送到客户端 客户端根据推送的信息执行不同操作的更新 整体流程图： 启动热更新：createWebSocketServer在 Vite`` dev server 启动之前，Vite 会为 HMR 做一些准备工作：比如创建websocket服务，利用chokidar创建一个监听对象 watcher 用于对文件修改进行监听等等，具体核心代码： 源码位置：packages/vite/src/node/server/index.ts export async function createServer( inlineConfig: InlineConfig = &#123;&#125;): Promise&lt;ViteDevServer&gt; &#123; .... const ws = createWebSocketServer(httpServer, config, httpsOptions) const &#123; ignored = [], ...watchOptions &#125; = serverConfig.watch || &#123;&#125; const watcher = chokidar.watch(path.resolve(root), &#123; ignored: [ &#x27;**/node_modules/**&#x27;, &#x27;**/.git/**&#x27;, ...(Array.isArray(ignored) ? ignored : [ignored]) ], ignoreInitial: true, ignorePermissionErrors: true, disableGlobbing: true, ...watchOptions &#125;) as FSWatcher .... watcher.on(&#x27;change&#x27;, async (file) =&gt; &#123; &#125;) watcher.on(&#x27;add&#x27;, (file) =&gt; &#123; &#125;) watcher.on(&#x27;unlink&#x27;, (file) =&gt; &#123; &#125;) ... return server&#125;复制代码 createWebSocketServer这个方法主是创建WebSocket服务并对错误进行一些处理，最后返回封装好的on、off、 send 和 close 方法，用于后续服务端推送消息和关闭服务。 源码位置：packages/vite/src/node/server/ws.ts export function createWebSocketServer( server: Server | null, config: ResolvedConfig, httpsOptions?: HttpsServerOptions): WebSocketServer &#123; let wss: WebSocket let httpsServer: Server | undefined = undefined // 热更新配置 const hmr = isObject(config.server.hmr) &amp;&amp; config.server.hmr const wsServer = (hmr &amp;&amp; hmr.server) || server // 普通模式 if (wsServer) &#123; wss = new WebSocket(&#123; noServer: true &#125;) wsServer.on(&#x27;upgrade&#x27;, (req, socket, head) =&gt; &#123; // 监听通过vite客户端发送的websocket消息，通过HMR_HEADER区分 if (req.headers[&#x27;sec-websocket-protocol&#x27;] === HMR_HEADER) &#123; wss.handleUpgrade(req, socket as Socket, head, (ws) =&gt; &#123; wss.emit(&#x27;connection&#x27;, ws, req) &#125;) &#125; &#125;) &#125; else &#123; // 中间件模式 // vite dev server in middleware mode wss = new WebSocket(websocketServerOptions) &#125; wss.on(&#x27;connection&#x27;, (socket) =&gt; &#123; ... &#125;) // 错误处理 wss.on(&#x27;error&#x27;, (e: Error &amp; &#123; code: string &#125;) =&gt; &#123; ... &#125;) // 返回 return &#123; on: wss.on.bind(wss), off: wss.off.bind(wss), send(payload: HMRPayload) &#123; ... &#125;, close() &#123; ... &#125; &#125;&#125;复制代码 执行热更新：moduleGraph+handleHMRUpdate 模块接收到文件改动执行的回调，这里主要两个操作：moduleGraph.onFileChange修改文件的缓存和handleHMRUpdate执行热更新 源码位置：packages/vite/src/node/server/index.ts watcher.on(&#x27;change&#x27;, async file =&gt; &#123; file = normalizePath(file); if (file.endsWith(&#x27;/package.json&#x27;)) &#123; return invalidatePackageData(packageCache, file); &#125; // invalidate module graph cache on file change moduleGraph.onFileChange(file); if (serverConfig.hmr !== false) &#123; try &#123; await handleHMRUpdate(file, server); &#125; catch (err) &#123; ws.send(&#123; type: &#x27;error&#x27;, err: prepareError(err), &#125;); &#125; &#125;&#125;);复制代码; 3.2.2.2.1 moduleGraph moduleGraph 是Vite定义的用来记录整个应用的模块依赖图的类，除此之外还有moduleNode。 源码位置：packages/vite/src/node/server/moduleGraph.ts moduleGraph是由一系列 map 组成，而这些map分别是url、id、file等与ModuleNode的映射，而ModuleNode 是 Vite中定义的最小模块单位。通过这两个类可以构建下面的模块依赖图： 可以看看moduleGraph.``onFileChange这个函数：主要是用来清空被修改文件对应的ModuleNode对象的 transformResult 属性，使之前的模块已有的转换缓存失效。这块也就是Vite在热更新里的缓存机制。可以看看官网的介绍。 源码位置：packages/vite/src/node/server/moduleGraph.ts onFileChange(file: string): void &#123; const mods = this.getModulesByFile(file) if (mods) &#123; const seen = new Set&lt;ModuleNode&gt;() mods.forEach((mod) =&gt; &#123; this.invalidateModule(mod, seen) &#125;) &#125; &#125; invalidateModule(mod: ModuleNode, seen: Set&lt;ModuleNode&gt; = new Set()): void &#123; mod.info = undefined mod.transformResult = null mod.ssrTransformResult = null invalidateSSRModule(mod, seen) &#125; 3.2.2.2.2 handleHMRUpdate handleHMRUpdate 模块主要是监听文件的更改，进行处理和判断通过WebSocket给客户端发送消息通知客户端去请求新的模块代码。 源码位置：packages/vite/packages/vite/src/node/server/hmr.ts 客户端：websocket 通信和更新处理客户端：当我们配置了热更新且不是ssr的时候，Vite底层在处理 html 的时候会把HMR相关的客户端代码写入在我们的代码中，如下： 当接收到服务端推送的消息，通过不同的消息类型做相应的处理，如(connected、update、custom…)，在实际开发热更新中使用最频繁的是update(动态加载热更新模块)和full-reload(刷新整个页面)事件。 源码位置：packages/vite/packages/vite/src/client/client.ts 核心代码实现 优化：浏览器的缓存策略提高响应速度同时，Vite 还利用HTTP加速整个页面的重新加载。设置响应头使得依赖模块(dependency module)进行强缓存，而源码文件通过设置 304 Not Modified 而变成可依据条件而进行更新。 若需要对依赖代码模块做改动可手动操作使缓存失效: vite --force复制代码 或者手动删除 node_modules/.``vite 中的缓存文件。 基于 esbuild 的依赖预编译优化为什么需要预构建？ 支持commonJS依赖 上面提到Vite是基于浏览器原生支持ESM的能力实现的，但要求用户的代码模块必须是ESM模块，因此必须将commonJs的文件提前处理，转化成 ESM 模块并缓存入 node_modules/.vite 减少模块和请求数量 除此之外，我们常用的lodash工具库，里面有很多包通过单独的文件相互导入，而 lodash-es这种包会有几百个子模块，当代码中出现 import &#123; debounce &#125; from &#39;lodash-es&#39; 会发出几百个 HTTP 请求，这些请求会造成网络堵塞，影响页面的加载。 Vite 将有许多内部模块的 ESM 依赖关系转换为单个模块，以提高后续页面加载性能。 通过预构建 lodash-es 成为一个模块，也就只需要一个 HTTP 请求了！ 为什么使用Esbuild? 引用尤大的一句话：“快”就一个字 这是Esbuild首页的图。新一代的打包工具，提供了与Webpack、Rollup、Parcel 等工具相似的资源打包能力，但在时速上达到 10 ～ 100 倍的差距，耗时是Webpack2%~3% 编译运行 VS 解释运行 大多数前端打包工具都是基于 JavaScript 实现的，大家都知道JavaScript是解释型语言，边运行边解释。而 Esbuild 则选择使用 Go 语言编写，该语言可以编译为原生代码,在编译的时候都将语言转为机器语言，在启动的时候直接执行即可，在 CPU 密集场景下，Go 更具性能优势。 多线程 VS 单线程 JavaScript 本质上是一门单线程语言，直到引入 WebWorker 之后才有可能在浏览器、Node 中实现多线程操作。就我对Webpack的源码理解，其源码也并未使用 WebWorker 提供的多线程能力。而GO天生的多线程优势。 对构建流程进行了优化，充分利用 CPU 资源 实现原理？Vite预编译之后，将文件缓存在node_modules/.vite/文件夹下。根据以下地方来决定是否需要重新执行预构建。 package.json中：dependencies发生变化 包管理器的lockfile 如果想强制让Vite重新预构建依赖，可以使用--force启动开发服务器，或者直接删掉node_modules/.vite/文件夹。 核心代码实现 通过createServer创建server对象后，当服务器启动会执行httpServer.listen方法 在执行createServer时，Vite底层会重写server.listen方法:首先调用插件的buildStart再执行runOptimize()方法 runOptimize()调用optimizeDeps()和createMissingImporterRegisterFn()方法 const runOptimize = async () =&gt; &#123; if (config.cacheDir) &#123; server._isRunningOptimizer = true try &#123; server._optimizeDepsMetadata = await optimizeDeps( config, config.server.force || server._forceOptimizeOnRestart ) &#125; finally &#123; server._isRunningOptimizer = false &#125; server._registerMissingImport = createMissingImporterRegisterFn(server) &#125; &#125;if (!middlewareMode &amp;&amp; httpServer) &#123; let isOptimized = false // overwrite listen to run optimizer before server start const listen = httpServer.listen.bind(httpServer) httpServer.listen = (async (port: number, ...args: any[]) =&gt; &#123; if (!isOptimized) &#123; try &#123; await container.buildStart(&#123;&#125;) await runOptimize() isOptimized = true &#125; catch (e) &#123; httpServer.emit(&#x27;error&#x27;, e) return &#125; &#125; return listen(port, ...args) &#125;) as any&#125; else &#123; await container.buildStart(&#123;&#125;) await runOptimize()&#125;复制代码 optimizeDeps()主要是根据配置文件生成hash，获取上次预购建的内容(存放在_metadata.json文件)。如果不是强预构建就对比_metadata.json文件的hash和新生成的hash：一致就返回_metadata.json文件的内容，否则清空缓存文件调用Esbuild构建模块再次存入_metadata.json文件 整体的流程图核心代码都在packages/``vite``/``src``/``node``/optimizer/index.ts里面 自动搜寻依赖主要模块：esbuildScanPlugin 预构建编译主要模块：esbuildDepPlugin 基于 Rollup 的 PluginsVite 从 preact 的 WMR 中得到了启发，将Vite Plugins继承Rollup`` Plugins `` ``API，在其基础上进行了一些扩展(如Vite特有的钩子等)，同时Vite也基于Rollup plugins机制提供了强大的插件API。目前和 Vite 兼容或者内置的插件，可以查看vite-rollup-plugins Vite 插件是什么使用Vite插件可以扩展Vite能力，通过暴露一些构建打包过程的一些时机配合工具函数，让用户可以自定义地写一些配置代码，执行在打包过程中。比如解析用户自定义的文件输入，在打包代码前转译代码，或者查找。 在实际的实现中，Vite 仅仅需要基于Rollup设计的接口进行扩展，在保证兼容 Rollup插件的同时再加入一些Vite特有的钩子和属性来进行扩展。 Vite 独有钩子对于各个钩子的具体使用可以移步这里 config：可以在Vite被解析之前修改Vite的相关配置。钩子接收原始用户配置config和一个描述配置环境的变量env configResolved：解析Vite配置后调用，配置确认 configureserver：主要用来配置开发服务器，为dev-server添加自定义的中间件 transformindexhtml：主要用来转换index.html，钩子接收当前的 HTML 字符串和转换上下文 handlehotupdate：执行自定义HMR更新，可以通过ws往客户端发送自定义的事件 通用钩子这里举一些常用的通用钩子，其余的通用钩子可以移步这里 服务启动时调用一次 options: 获取、操纵Rollup选项 buildstart：开始创建 在每个传入模块请求时被调用 resolveId: 创建自定义确认函数，可以用来定位第三方依赖 load：可以自定义加载器，可用来返回自定义的内容 transform：在每个传入模块请求时被调用，主要是用来转换单个模块 服务关闭时调用一次 buildend：在服务器关闭时被调用 closeBundle 钩子的调用顺序引用@young 村长的一个图: Vite的官网可以看出：Vite插件可以用一个 enforce 属性（类似于 Webpack加载器）来调整它的应用顺序。enforce 的值可以是pre 或 post。解析后的插件将按照以下顺序排列： Alias enforce:&#39;pre&#39;的自定义插件 Vite核心插件 没有enforce的自定义插件 Vite构建用的插件 enforce:&#39;post&#39;的自定义插件 Vite后置构建插件 自定义插件 编写插件代码 export default function myVitePlugin () &#123; // 定义vite插件唯一id const virtualFileId = &#x27;@my-vite-plugin&#x27; // 返回的整个插件对象 return &#123; // 必须的，将会显示在 warning 和 error 中 name: &#x27;vite-plugin&#x27;, // 钩子 // config config: (config, env) =&gt; (&#123; console.log(&#x27;config&#x27;,config) return &#123;&#125; &#125;), // 确认config configResolved: config =&gt; (&#123;&#125;), options: options =&gt; (&#123;&#125;), buildStart: options =&gt; (&#123;&#125;), transformIndexHtml: (html, ctx) =&gt; (&#123; return html &#125;), //确认 resolveId: (source, importer) =&gt; (&#123;&#125;), // 转换 transform: (code, id) =&gt; (&#123;&#125;) &#125;&#125;复制代码 引入插件：vite.config.js/ts 中引用 // vite.config.js/tsimport myVitePlugin from &#x27;...&#x27;export default defineConfig&#123; plugins:[vue(),myVitePlugin()]&#125;复制代码 总结最后总结下Vite相关的优缺点： 优点： 快速的冷启动: 采用No Bundle和esbuild预构建，速度远快于Webpack 高效的热更新：基于ESM实现，同时利用HTTP头来加速整个页面的重新加载，增加缓存策略 真正的按需加载: 基于浏览器ESM的支持，实现真正的按需加载 缺点 生态：目前Vite的生态不如Webapck，不过我觉得生态也只是时间上的问题。 生产环境由于esbuild对css和代码分割不友好使用Rollup进行打包 Vite.js虽然才在构建打包场景兴起，但在很多场景下基本都会优于现有的解决方案。如果有生态、想要丰富的loader、plugins的要求可以考虑成熟的Webpack。在其余情况下，Vite.js不失为一个打包构建工具的好选择。 附录 官方文档 Esbuild官网 Vite 插件 API Rollup官方文档 Rollup - Next-generation ES6 module bundler - Interview with Rich Harris Vite源码 Vite2 插件开发指南 转载深入理解 Vite 核心原理","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"常用正则表达式","date":"2022-02-23T15:02:24.000Z","path":"2022/02/23/2022-02-23-common-regex/","text":"校验字符的表达式 汉字：^[\\u4e00-\\u9fa5]&#123;0,&#125;$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 长度为 3-20 的所有字符：^.&#123;3,20&#125;$ 由 26 个英文字母组成的字符串：^[A-Za-z]+$ 由 26 个大写英文字母组成的字符串：^[A-Z]+$ 由 26 个小写英文字母组成的字符串：^[a-z]+$ 由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26 个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w&#123;3,20&#125;$ 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 可以输入含有^%&amp;&#39;,;=?$\\&quot;等字符：[^%&amp;&#39;,;=?$\\x22]+ 禁止输入含有~的字符：[^~\\x22]+ 校验数字的表达式 数字：^[0-9]*$ n 位的数字：^\\d&#123;n&#125;$ 至少 n 位的数字：^\\d&#123;n,&#125;$ m-n 位的数字：^\\d&#123;m,n&#125;$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(\\.[0-9]&#123;1,2&#125;)?$ 带 1-2 位小数的正数或负数：^(\\-)?\\d+(\\.\\d&#123;1,2&#125;)$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(\\.[0-9]&#123;2&#125;)?$ 有 1~3 位小数的正实数：^[0-9]+(\\.[0-9]&#123;1,3&#125;)?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 特殊需求表达式 Email 地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(\\.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+\\.? InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\(\\d&#123;3,4&#125;-)|\\d&#123;3.4&#125;-)?\\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)：\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125; 电话号码正则表达式（支持手机号码，3-4 位区号，7-8 位直播号码，1－4 位分机号）: ((\\d&#123;11&#125;)|^((\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)|(\\d&#123;4&#125;|\\d&#123;3&#125;)-(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;)|(\\d&#123;7,8&#125;)-(\\d&#123;4&#125;|\\d&#123;3&#125;|\\d&#123;2&#125;|\\d&#123;1&#125;))$) 身份证号(15 位、18 位数字)，最后一位是校验位，可能为数字或字符 X：(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$) 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]&#123;8,10&#125;$ 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在 8-10 之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125; 一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?[1-9]|1[0-2])$ 一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有 1 位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 备注：这就是最终结果了,别忘了”+”可以用”*“替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml 文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\\u4e00-\\u9fa5] 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1)) 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) HTML 标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\\s*|\\s*$或(^\\s*)|(\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯 QQ 号：[1-9][0-9]&#123;4,&#125; (腾讯 QQ 号从 10000 开始) 中国邮政编码：[1-9]\\d&#123;5&#125;(?!\\d) (中国邮政编码为 6 位数字) IPv4 地址：((2(5[0-5]|[0-4]\\d))|[0-1]?\\d&#123;1,2&#125;)(\\.((2(5[0-5]|[0-4]\\d))|[0-1]?\\d&#123;1,2&#125;))&#123;3&#125;","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"regex","slug":"regex","permalink":"https://luckyship.github.io/tags/regex/"}]},{"title":"chrome插件开发指南","date":"2022-02-20T14:54:27.000Z","path":"2022/02/20/2022-02-20-chrome-extend-develop/","text":"什么是 chrome extensionsChrome Extensions，中文名叫 “Chrome 浏览器扩展程序”。引用官方文档的描述，翻译一下就是 “可以修改和增强浏览器功能的 H5 小程序”。它的入口在浏览器窗口的右上角，地址栏的最右边 入门manifest.jsonmanifest.json 是整个插件扩展程序中最重要的一个描述文件，这个 json 格式的文件包含了你整个扩展程序的一些重要描述，比如 “扩展程序名称”、“扩展程序图标”、“权限申请” 等。 &#123; // Required &quot;manifest_version&quot;: 2, // manifest 版本号，这里都写 2 就好了，从 Google Chrome 18 开始，就开始升级到 2 版本了 &quot;name&quot;: &quot;My Extension&quot;, &quot;version&quot;: &quot;1.0.0&quot;, // 扩展程序版本，这个是自定义的，建议参考 semver 规范(http://semver.org/) // Recommended &quot;default_locale&quot;: &quot;zh&quot;, // 默认语言，具体可以看 i18n 文档(https://developer.chrome.com/extensions/i18n) &quot;description&quot;: &quot;A plain text description&quot;, // 项目描述 &quot;icons&quot;: &#123; // icon，不同的位置支持不同大小的 icon，具体看文档(https://developer.chrome.com/extensions/manifest/icons) &quot;128&quot;: &quot;icons/icon_128.png&quot;, &quot;48&quot;: &quot;icons/icon_48.png&quot;, &quot;16&quot;: &quot;icons/icon_16.png&quot; &#125;, // Pick one (or none) &quot;browser_action&quot;: &#123; // 多数都是使用这个，插件扩展程序针对的是浏览器行为（图标是在地址栏外面） &quot;default_icon&quot;: &quot;icons/24.png&quot;, // 最佳大小为19*19，地址栏上的插件扩展程序的 icon（一般作为主入口） &quot;default_popup&quot;: &quot;popup.html&quot;, // 点击插件扩展程序 icon 后弹出来的窗口的主页面 html &quot;default_title&quot;: &quot;extentsions demo&quot; // 当鼠标放到扩展程序图标上时显示的文字 &#125;, &quot;page_action&quot;: &#123; // 插件扩展程序针对的是页面行为（图标是在地址栏里面的） ... &#125;, // Optional &quot;author&quot;: ..., &quot;automation&quot;: ..., &quot;background&quot;: &#123; // Recommended &quot;persistent&quot;: false &#125;, &quot;background&quot;: &#123; &quot;scripts&quot;: [&quot;eventPage.js&quot;], &quot;persistent&quot;: false &#125;, &quot;chrome_settings_overrides&quot;: &#123;...&#125;, &quot;chrome_ui_overrides&quot;: &#123; &quot;bookmarks_ui&quot;: &#123; &quot;remove_bookmark_shortcut&quot;: true, &quot;remove_button&quot;: true &#125; &#125;, &quot;chrome_url_overrides&quot;: &#123;...&#125;, &quot;commands&quot;: &#123;...&#125;, &quot;content_capabilities&quot;: ..., &quot;content_scripts&quot;: [&#123;...&#125;], &quot;content_security_policy&quot;: &quot;policyString&quot;, &quot;converted_from_user_script&quot;: ..., &quot;current_locale&quot;: ..., &quot;declarative_net_request&quot;: ..., &quot;devtools_page&quot;: &quot;devtools.html&quot;, &quot;event_rules&quot;: [&#123;...&#125;], &quot;externally_connectable&quot;: &#123; &quot;matches&quot;: [&quot;*://*.example.com/*&quot;] &#125;, &quot;file_browser_handlers&quot;: [...], &quot;file_system_provider_capabilities&quot;: &#123; &quot;configurable&quot;: true, &quot;multiple_mounts&quot;: true, &quot;source&quot;: &quot;network&quot; &#125;, &quot;homepage_url&quot;: &quot;http://path/to/homepage&quot;, &quot;import&quot;: [&#123;&quot;id&quot;: &quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;&#125;], &quot;incognito&quot;: &quot;spanning, split, or not_allowed&quot;, &quot;input_components&quot;: ..., &quot;key&quot;: &quot;publicKey&quot;, &quot;minimum_chrome_version&quot;: &quot;versionString&quot;, &quot;nacl_modules&quot;: [...], &quot;oauth2&quot;: ..., &quot;offline_enabled&quot;: true, &quot;omnibox&quot;: &#123; &quot;keyword&quot;: &quot;aString&quot; &#125;, &quot;optional_permissions&quot;: [&quot;tabs&quot;], &quot;options_page&quot;: &quot;options.html&quot;, &quot;options_ui&quot;: &#123; &quot;chrome_style&quot;: true, &quot;page&quot;: &quot;options.html&quot; &#125;, &quot;permissions&quot;: [&quot;tabs&quot;], &quot;platforms&quot;: ..., &quot;plugins&quot;: [...], &quot;requirements&quot;: &#123;...&#125;, &quot;sandbox&quot;: [...], &quot;short_name&quot;: &quot;Short Name&quot;, &quot;signature&quot;: ..., &quot;spellcheck&quot;: ..., &quot;storage&quot;: &#123; &quot;managed_schema&quot;: &quot;schema.json&quot; &#125;, &quot;system_indicator&quot;: ..., &quot;tts_engine&quot;: &#123;...&#125;, &quot;update_url&quot;: &quot;http://path/to/updateInfo.xml&quot;, &quot;version_name&quot;: &quot;aString&quot;, &quot;web_accessible_resources&quot;: [...]&#125; 学做一个 demo manifestjson(该文本文件需要用 UTF8 字符集保存) &#123; &quot;name&quot;: &quot;第一个Chrome插件&quot;, &quot;manifest_version&quot;: 2, &quot;version&quot;: &quot;1.0&quot;, &quot;description&quot;: &quot;我的第一个Chrome插件，还不错吧&quot;, &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;1.png&quot; &#125;, &quot;content_scripts&quot;: [ &#123; &quot;matches&quot;: [&quot;https://www.baidu.com/&quot;], &quot;js&quot;: [&quot;test.js&quot;] &#125; ]&#125; test.js alert(&#x27;Hello World&#x27;);document.body.style.backgroundColor = &#x27;gray&#x27;; content_scripts 是运行在打开页面的脚本，可以拿到整个页面的 DOM 对象，所以可以利用该脚本对页面进行操作。 添加图片 1.png 打开 chrome，打开菜单，找到扩展程序选项更多工具&gt;扩展程序路径下。点击加载已解压的扩展程序，添加文件夹就 OK 啦！ 常用 api bookmarks: 书签管理接口，可以对浏览器的书签进行增删改查等管理 tabs: 标签管理接口，可以对浏览器的标签进行增删改查等管理 contextMenus: 右键菜单管理 cookies: 浏览器 cookie 的管理 notifications: 消息通知 desktopCapture: 可针对 “窗口” 或者 ”标签“ 的截图接口 i18n: 国际化（多语言支持） 程序发布和分享打包扩展程序，第一次打包只需要设置根目录，打包完成后会生成.crx 和.pem 密钥文件(版本的迭代需要此文件，否则则会生成新的程序文件)，将.crx 文件发给其他人拖入扩展程序页面即可安装。 发布到 chrome 商店当一切准备就绪，就可以准备发布上线了，Chrome 有个官方的插件扩展程序市场，还自带了发布和更新等一体化管理的流程，非常方便。传送门：Chrome 商店 dashboard 注意，上传的是 zip 而不是生成的 crx 文件，具体参考：https://developer.chrome.com/webstore/publish 常见问题 引入外部 js 时报 Refused to load the script 的问题 &lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt; 解决方案：修改 content_security_policy，把对应的域名加上去即可，比如以上的问题可以解决： &#123; &quot;content_security_policy&quot;: &quot;https://code.jquery.com&quot;&#125; 以上表示允许 https://code.jquery.com 域名下的外部 js 的引入。 2. Chrome 插件扩展程序是开源的方式安装的，可以去安装目录通过扩展程序 ID 来找到源码。正常情况下，Chrome 插件扩展程序的默认安装目录如下： Windows XP：C:\\Documents and Settings\\用户名\\Local Settings\\Application Data\\Google\\Chrome\\User Data\\Default\\Extensions Windows7：C:\\Users\\用户名\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Extensions Mac：~/Library/Application Support/Google/Chrome/Default/Extensions Ubuntu：~/.config/google-chrome/Default/Extensions如果在这些不同操作系统中的默认安装位置没找到插件，那么还有一种方法可以查询到。 地址栏访问 chrome:version找到 “个人资料路径”，该路径下的 extensions 文件夹就是 Chrome 插件扩展程序的安装路径了安装路径下的插件扩展程序，是以 ID 为目录区分的地址栏访问 chrome://extensions/，可以查看每个插件扩展程序的 ID 高级教程-chrome 插件合集项目地址 参考资料官方文档","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"nginx 问答","date":"2022-02-12T11:14:39.000Z","path":"2022/02/12/2022-02-12-nginx-question/","text":"什么是 Nginx？Nginx 是一个 轻量级/高性能的反向代理 Web 服务器，他实现非常高效的反向代理、负载平衡，他可以处理 2-3 万并发连接数，官方监测能支持 5 万并发，现在中国使用 nginx 网站用户有很多，例如：新浪、网易、 腾讯等。 为什么要用 Nginx？跨平台、配置简单、方向代理、高并发连接：处理 2-3 万并发连接数，官方监测能支持 5 万并发，内存消耗小：开启 10 个 nginx 才占 150M 内存 ，nginx 处理静态文件好，耗费内存少， 而且 Nginx 内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。 使用 Nginx 的话还能： 节省宽带：支持 GZIP 压缩，可以添加浏览器本地缓存 稳定性高：宕机的概率非常小 接收用户请求是异步的 为什么 Nginx 性能这么高？因为他的事件处理机制：异步非阻塞事件处理机制：运用了 epoll 模型，提供了一个队列，排队解决 Nginx 怎么处理请求的？nginx 接收一个请求后，首先由 listen 和 server_name 指令匹配 server 模块，再匹配 server 模块里的 location，location 就是实际地址 server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点 listen 80； # 提供服务的端口，默认80 server_name localhost； # 提供服务的域名主机名 location / &#123; # 第一个location区块开始 root html； # 站点的根目录，相当于Nginx的安装目录 index index.html index.htm； # 默认的首页文件，多个用空格分开 &#125; # 第一个location区块结果 &#125; 什么是正向代理和反向代理？ 正向代理就是一个人发送一个请求直接就到达了目标的服务器 反方代理就是请求统一被 Nginx 接收，nginx 反向代理服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了 使用“反向代理服务器的优点是什么?反向代理服务器可以隐藏源服务器的存在和特征。它充当互联网云和 web 服务器之间的中间层。这对于安全方面来说是很好的，特别是当您使用 web 托管服务时。 Nginx 的优缺点？优点： 占内存小，可实现高并发连接，处理响应快 可实现 http 服务器、虚拟主机、方向代理、负载均衡 Nginx 配置简单 可以不暴露正式的服务器 IP 地址 缺点： 动态处理差：nginx 处理静态文件好,耗费内存少，但是处理动态页面则很鸡肋，现在一般前端用 nginx 作为反向代理抗住压力， Nginx 应用场景？ http 服务器。Nginx 是一个 http 服务可以独立提供 http 服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站，例如个人网站使用的虚拟机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用 nginx 做反向代理。并且多台服务器可以平均分担负载，不会应为某台服务器负载高宕机而某台服务器闲置的情况。 nginz 中也可以配置安全管理、比如可以使用 Nginx 搭建 API 接口网关,对每个接口服务进行拦截。 Nginx 目录结构有哪些？[root@localhost ~]# tree /usr/local/nginx/usr/local/nginx├── client_body_temp├── conf # Nginx所有配置文件的目录│ ├── fastcgi.conf # fastcgi相关参数的配置文件│ ├── fastcgi.conf.default # fastcgi.conf的原始备份文件│ ├── fastcgi_params # fastcgi的参数文件│ ├── fastcgi_params.default│ ├── koi-utf│ ├── koi-win│ ├── mime.types # 媒体类型│ ├── mime.types.default│ ├── nginx.conf # Nginx主配置文件│ ├── nginx.conf.default│ ├── scgi_params # scgi相关参数文件│ ├── scgi_params.default│ ├── uwsgi_params # uwsgi相关参数文件│ ├── uwsgi_params.default│ └── win-utf├── fastcgi_temp # fastcgi临时数据目录├── html # Nginx默认站点目录│ ├── 50x.html # 错误页面优雅替代显示文件，例如当出现502错误时会调用此页面│ └── index.html # 默认的首页文件├── logs # Nginx日志目录│ ├── access.log # 访问日志文件│ ├── error.log # 错误日志文件│ └── nginx.pid # pid文件，Nginx进程启动后，会把所有进程的ID号写到此文件├── proxy_temp # 临时目录├── sbin # Nginx命令目录│ └── nginx # Nginx的启动命令├── scgi_temp # 临时目录└── uwsgi_temp # 临时目录 Nginx 配置文件 nginx.conf 有哪些属性模块?orker_processes 1； # worker进程的数量events &#123; # 事件区块开始 worker_connections 1024； # 每个worker进程支持的最大连接数&#125; # 事件区块结束http &#123; # HTTP区块开始 include mime.types； # Nginx支持的媒体类型库文件 default_type application/octet-stream； # 默认的媒体类型 sendfile on； # 开启高效传输模式 keepalive_timeout 65； # 连接超时 server &#123; # 第一个Server区块开始，表示一个独立的虚拟主机站点 listen 80； # 提供服务的端口，默认80 server_name localhost； # 提供服务的域名主机名 location / &#123; # 第一个location区块开始 root html； # 站点的根目录，相当于Nginx的安装目录 index index.html index.htm； # 默认的首页文件，多个用空格分开 &#125; # 第一个location区块结果 error_page 500502503504 /50x.html； # 出现对应的http状态码时，使用50x.html回应客户 location = /50x.html &#123; # location区块开始，访问50x.html root html； # 指定对应的站点目录为html &#125; &#125; ...... Nginx 静态资源?静态资源访问，就是存放在 nginx 的 html 页面，我们可以自己编写 如何用 Nginx 解决前端跨域问题？使用 Nginx 转发请求。把跨域的接口写成调本域的接口，然后将这些接口转发到真正的请求地址。 Nginx 虚拟主机怎么配置?1、基于域名的虚拟主机，通过域名来区分虚拟主机——应用：外部网站 2、基于端口的虚拟主机，通过端口来区分虚拟主机——应用：公司内部网站，外部网站的管理后台 3、基于 ip 的虚拟主机。 基于虚拟主机配置域名 需要建立/data/www /data/bbs 目录，windows 本地 hosts 添加虚拟机 ip 地址对应的域名解析；对应域名网站目录下新增 index.html 文件； #当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/www目录下文件server &#123; listen 80; server_name www.lijie.com; location / &#123; root data/www; index index.html index.htm; &#125;&#125;#当客户端访问www.lijie.com,监听端口号为80,直接跳转到data/bbs目录下文件server &#123; listen 80; server_name bbs.lijie.com; location / &#123; root data/bbs; index index.html index.htm; &#125;&#125; 基于端口的虚拟主机 使用端口来区分，浏览器使用域名或 ip 地址:端口号 访问 #当客户端访问www.lijie.com,监听端口号为8080,直接跳转到data/www目录下文件server &#123; listen 8080; server_name 8080.lijie.com; location / &#123; root data/www; index index.html index.htm; &#125;&#125;#当客户端访问www.lijie.com,监听端口号为80直接跳转到真实ip服务器地址 127.0.0.1:8080server &#123; listen 80; server_name www.lijie.com; location / &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm; &#125;&#125; location 的作用是什么？location 指令的作用是根据用户请求的 URI 来执行不同的应用，也就是根据用户请求的网站 URL 进行匹配，匹配成功即进行相关的操作。更多面试题，欢迎关注公众号 Java 面试题精选 location 的语法能说出来吗？ 注意：~ 代表自己输入的英文字母 匹配符 匹配规则 优先级 = 精确匹配 1 ^~ 以某个字符串开头 2 ~ 区分大小写的正则匹配 3 ~* 不区分大小写的正则匹配 4 !~ 区分大小写不匹配的正则 5 !~* 不区分大小写不匹配的正则 6 / 通用匹配，任何请求都会匹配到 7 Location 正则案例 示例： #优先级1,精确匹配，根路径location =/ &#123; return 400;&#125;#优先级2,以某个字符串开头,以av开头的，优先匹配这里，区分大小写location ^~ /av &#123; root /data/av/;&#125;#优先级3，区分大小写的正则匹配，匹配/media*****路径location ~ /media &#123; alias /data/static/;&#125;#优先级4 ，不区分大小写的正则匹配，所有的****.jpg|gif|png 都走这里location ~* .*\\.(jpg|gif|png|js|css)$ &#123; root /data/av/;&#125;#优先7，通用匹配location / &#123; return 403;&#125; 限流怎么做的？Nginx 限流就是限制用户请求速度，防止服务器受不了 限流有 3 种 正常限制访问频率（正常流量） 突发限制访问频率（突发流量） 限制并发连接数 Nginx 的限流都是基于漏桶流算法，底下会说道什么是桶铜流 实现三种限流算法1、正常限制访问频率（正常流量）： 限制一个用户发送的请求，我 Nginx 多久接收一个请求。 Nginx 中使用 ngx_http_limit_req_module 模块来限制的访问频率，限制的原理实质是基于漏桶算法原理来实现的。在 nginx.conf 配置文件中可以使用 limit_req_zone 命令及 limit_req 命令限制单个 IP 的请求处理频率。 #定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;#绑定限流维度server&#123; location/seckill.html&#123; limit_req zone=zone; proxy_pass http://lj_seckill; &#125;&#125; 1r/s 代表 1 秒一个请求，1r/m 一分钟接收一个请求， 如果 Nginx 这时还有别人的请求没有处理完，Nginx 就会拒绝处理该用户请求。 2、突发限制访问频率（突发流量）： 限制一个用户发送的请求，我 Nginx 多久接收一个。 上面的配置一定程度可以限制访问频率，但是也存在着一个问题：如果突发流量超出请求被拒绝处理，无法处理活动时候的突发流量，这时候应该如何进一步处理呢？ Nginx 提供 burst 参数结合 nodelay 参数可以解决流量突发的问题，可以设置能处理的超过设置的请求数外能额外处理的请求数。我们可以将之前的例子添加 burst 参数以及 nodelay 参数： #定义限流维度，一个用户一分钟一个请求进来，多余的全部漏掉limit_req_zone $binary_remote_addr zone=one:10m rate=1r/m;#绑定限流维度server&#123; location/seckill.html&#123; limit_req zone=zone burst=5 nodelay; proxy_pass http://lj_seckill; &#125;&#125; 为什么就多了一个 burst=5 nodelay; 呢，多了这个可以代表 Nginx 对于一个用户的请求会立即处理前五个，多余的就慢慢来落，没有其他用户的请求我就处理你的，有其他的请求的话我 Nginx 就漏掉不接受你的请求 3、 限制并发连接数 Nginx 中的 ngx_http_limit_conn_module 模块提供了限制并发连接数的功能，可以使用 limit_conn_zone 指令以及 limit_conn 执行进行配置。接下来我们可以通过一个简单的例子来看下： http &#123; limit_conn_zone $binary_remote_addr zone=myip:10m; limit_conn_zone $server_name zone=myServerName:10m;&#125;server &#123; location / &#123; limit_conn myip 10; limit_conn myServerName 100; rewrite / http://www.lijie.net permanent; &#125;&#125; 上面配置了单个 IP 同时并发连接数最多只能 10 个连接，并且设置了整个虚拟服务器同时最大并发数最多只能 100 个链接。当然，只有当请求的 header 被服务器处理后，虚拟服务器的连接数才会计数。 刚才有提到过 Nginx 是基于漏桶算法原理实现的，实际上限流一般都是基于漏桶算法和令牌桶算法实现的。接下来我们来看看两个算法的介绍： 漏桶流算法和令牌桶算法知道？漏桶算法 漏桶算法是网络世界中流量整形或速率限制时经常使用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。 也就是我们刚才所讲的情况。漏桶算法提供的机制实际上就是刚才的案例：突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。 令牌桶算法 令牌桶算法是网络流量整形和速率限制中最常使用的一种算法。典型情况下，令牌桶算法用来控制发送到网络上的数据的数目，并允许突发数据的发送。Google 开源项目 Guava 中的 RateLimiter 使用的就是令牌桶控制算法。 令牌桶算法的机制如下：存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，令牌就会一直产生直至装满整个令牌桶。更多面试题，欢迎关注公众号 Java 面试题精选 为什么要做动静分离？ Nginx 是当下最热的 Web 容器，网站优化的重要点在于静态化网站，网站静态化的关键点则是是动静分离，动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们则根据静态资源的特点将其做缓存操作。 让静态的资源只走静态资源服务器，动态的走动态的服务器 Nginx 的静态处理能力很强，但是动态处理能力不足，因此，在企业中常用动静分离技术。 对于静态资源比如图片，js，css 等文件，我们则在反向代理服务器 nginx 中进行缓存。这样浏览器在请求一个静态资源时，代理服务器 nginx 就可以直接处理，无需将请求转发给后端服务器 tomcat。 若用户请求的动态文件，比如 servlet,jsp 则转发给 Tomcat 服务器处理，从而实现动静分离。这也是反向代理服务器的一个重要的作用。 Nginx 怎么做的动静分离？只需要指定路径对应的目录。location/可以使用正则表达式匹配。并指定对应的硬盘中的目录。如下：（操作都是在 Linux 上） location /image/ &#123; root /usr/local/static/; autoindex on;&#125; 1.创建目录 mkdir /usr/local/static/image 2.进入目录 cd /usr/local/static/image 3.放一张照片上去 1.jpg 4.重启 nginx sudo nginx -s reload 打开浏览器 输入 server_name/image/1.jpg 就可以访问该静态图片了 Nginx 负载均衡的算法怎么实现的?策略有哪些?为了避免服务器崩溃，大家会通过负载均衡的方式来分担服务器压力。将对台服务器组成一个集群，当用户访问时，先访问到一个转发服务器，再由转发服务器将访问分发到压力更小的服务器。 Nginx 负载均衡实现的策略有以下五种： 1 轮询(默认)每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某个服务器宕机，能自动剔除故障系统。 upstream backserver &#123; server 192.168.0.12; server 192.168.0.13; &#125; 2 权重 weightweight 的值越大分配 到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。其次是为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。 upstream backserver &#123; server 192.168.0.12 weight=2; server 192.168.0.13 weight=8; &#125; 权重越高，在被访问的概率越大，如上例，分别是 20%，80%。 3 ip_hash( IP 绑定)每个请求按访问 IP 的哈希结果分配，使来自同一个 IP 的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的 session 共享问题 upstream backserver &#123; ip_hash; server 192.168.0.12:88; server 192.168.0.13:80; &#125; 4 fair(第三方插件)必须安装 upstream_fair 模块。 对比 weight、ip_hash 更加智能的负载均衡算法，fair 算法可以根据页面大小和加载时间长短智能地进行负载均衡，响应时间短的优先分配。 upstream backserver &#123; server server1; server server2; fair; &#125; 哪个服务器的响应速度快，就将请求分配到那个服务器上。 5、url_hash(第三方插件)必须安装 Nginx 的 hash 软件包 按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。 upstream backserver &#123; server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32; &#125; Nginx 配置高可用性怎么配置？当上游服务器(真实访问服务器)，一旦出现故障或者是没有及时相应的话，应该直接轮训到下一台服务器，保证服务器的高可用 Nginx 配置代码： server &#123; listen 80; server_name www.lijie.com; location / &#123; ### 指定上游服务器负载均衡服务器 proxy_pass http://backServer; ###nginx与上游服务器(真实访问的服务器)超时时间 后端服务器连接的超时时间_发起握手等候响应超时时间 proxy_connect_timeout 1s; ###nginx发送给上游服务器(真实访问的服务器)超时时间 proxy_send_timeout 1s; ### nginx接受上游服务器(真实访问的服务器)超时时间 proxy_read_timeout 1s; index index.html index.htm; &#125; &#125; Nginx 怎么判断别 IP 不可访问？# 如果访问的ip地址为192.168.9.115,则返回403if ($remote_addr = 192.168.9.115) &#123; return 403; &#125; 怎么限制浏览器访问？## 不允许谷歌浏览器访问 如果是谷歌浏览器返回500if ($http_user_agent ~ Chrome) &#123; return 500; &#125; Rewrite 全局变量是什么？- $args ： #这个变量等于请求行中的参数，同$query_string- $content_length ： 请求头中的Content-length字段。- $content_type ： 请求头中的Content-Type字段。- $document_root ： 当前请求在root指令中指定的值。- $host ： 请求主机头字段，否则为服务器名称。- $http_user_agent ： 客户端agent信息- $http_cookie ： 客户端cookie信息- $limit_rate ： 这个变量可以限制连接速率。- $request_method ： 客户端请求的动作，通常为GET或POST。- $remote_addr ： 客户端的IP地址。- $remote_port ： 客户端的端口。- $remote_user ： 已经经过Auth Basic Module验证的用户名。- $request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。- $scheme ： HTTP方法（如http，https）。- $server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。- $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。- $server_name ： 服务器名称。- $server_port ： 请求到达服务器的端口号。- $request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。- $uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。- $document_uri ： 与$uri相同 转载盘点那些关于 Nginx 的常考面试题","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"nginx","slug":"nginx","permalink":"https://luckyship.github.io/tags/nginx/"},{"name":"review","slug":"review","permalink":"https://luckyship.github.io/tags/review/"}]},{"title":"nginx使用场景","date":"2022-02-12T10:06:38.000Z","path":"2022/02/12/2022-02-12-nginx-use/","text":"nginx 使用场景分为： http 服务器 静态服务器 反向代理 负载均衡 动静分离 一：HTTP 服务器Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用 Nginx 来做服务器，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。 1、 首先在文档根目录 Docroot(/usr/local/var/www)下创建 html 目录, 然后在 html 中放一个 test.html; 2、 配置 nginx.conf 中的 server user mengday staff;http &#123; server &#123; listen 80; server_name localhost; client_max_body_size 1024M; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; &#125;&#125; 3、访问测试 http://localhost/ 指向/usr/local/var/www/index.html, index.html 是安装 nginx 自带的 html http://localhost/test.html 指向/usr/local/var/www/html/test.html 注意：如果访问图片出现 403 Forbidden 错误，可能是因为 nginx.conf 的第一行 user 配置不对，默认是#user nobody;是注释的，linux 下改成 user root; macos 下改成 user 用户名 所在组; 然后重新加载配置文件或者重启，再试一下就可以了， 用户名可以通过 who am i 命令来查看。 4、指令简介 server : 用于定义服务，http 中可以有多个 server 块 listen : 指定服务器侦听请求的 IP 地址和端口，如果省略地址，服务器将侦听所有地址，如果省略端口，则使用标准端口 server_name : 服务名称，用于配置域名 location : 用于配置映射路径 uri 对应的配置，一个 server 中可以有多个 location, location 后面跟一个 uri,可以是一个正则表达式, / 表示匹配任意路径, 当客户端访问的路径满足这个 uri 时就会执行 location 块里面的代码 root : 根路径，当访问 http://localhost/test.html，“/test.html”会匹配到”/“uri, 找到 root 为/usr/local/var/www/html，用户访问的资源物理地址=root + uri = /usr/local/var/www/html + /test.html=/usr/local/var/www/html/test.html index : 设置首页，当只访问 server_name 时后面不跟任何路径是不走 root 直接走 index 指令的；如果访问路径中没有指定具体的文件，则返回 index 设置的资源，如果访问 http://localhost/html/ 则默认返回 index.html 5、location uri 正则表达式 . ： 匹配除换行符以外的任意字符? ： 重复0次或1次+ ： 重复1次或更多次* ： 重复0次或更多次\\d ：匹配数字^ ： 匹配字符串的开始$ ： 匹配字符串的结束&#123;n&#125; ： 重复n次&#123;n,&#125; ： 重复n次或更多次[c] ： 匹配单个字符c[a-z] ： 匹配a-z小写字母的任意一个(a|b|c) : 属线表示匹配任意一种情况，每种情况使用竖线分隔，一般使用小括号括括住，匹配符合a字符 或是b字符 或是c字符的字符串\\ 反斜杠：用于转义特殊字符小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。正则里面容易让人困惑的是\\转义特殊字符。 二： 静态服务器在公司中经常会遇到静态服务器，通常会提供一个上传的功能，其他应用如果需要静态资源就从该静态服务器中获取。 1、在/usr/local/var/www 下分别创建 images 和 img 目录，分别在每个目录下放一张 test.jpg http &#123; server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; # 默认location location / &#123; root /usr/local/var/www/html; index index.html index.htm; &#125; location ^~ /images/ &#123; root $doc_root; &#125; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; &#125;&#125; 自定义变量使用 set 指令，语法 set 变 量 名 值 ; 引 用 使 用 变量名 值; 引用使用 变量名值;引用使用变量名; 这里自定义了 doc_root 变量。 静态服务器 location 的映射一般有两种方式： 使用路径，如 /images/ 一般图片都会放在某个图片目录下， 使用后缀，如 .jpg、.png 等后缀匹配模式 访问 http://localhost/test.jpg 会映射到$doc_root/img 访问 http://localhost/images/test.jpg 当同一个路径满足多个 location 时，优先匹配优先级高的 location，由于^~ 的优先级大于 ~, 所以会走/images/对应的 location 常见的 location 路径映射路径有以下几种： = 进行普通字符精确匹配。也就是完全匹配。^~ 前缀匹配。如果匹配成功，则不再匹配其他location。~ 表示执行一个正则匹配，区分大小写~* 表示执行一个正则匹配，不区分大小写/xxx/ 常规字符串路径匹配/ 通用匹配，任何请求都会匹配到 location 优先级当一个路径匹配多个 location 时究竟哪个 location 能匹配到时有优先级顺序的，而优先级的顺序于 location 值的表达式类型有关，和在配置文件中的先后顺序无关。相同类型的表达式，字符串长的会优先匹配。 以下是按优先级排列说明： 等号类型（=）的优先级最高。一旦匹配成功，则不再查找其他匹配项，停止搜索。 ^~类型表达式，不属于正则表达式。一旦匹配成功，则不再查找其他匹配项，停止搜索。 正则表达式类型（~ ~*）的优先级次之。如果有多个 location 的正则能匹配的话，则使用正则表达式最长的那个。 常规字符串匹配类型。按前缀匹配。 / 通用匹配，如果没有匹配到，就匹配通用的 优先级搜索问题：不同类型的 location 映射决定是否继续向下搜索 等号类型、^~类型：一旦匹配上就停止搜索了，不会再匹配其他 location 了 正则表达式类型(~ ~*）,常规字符串匹配类型/xxx/ : 匹配到之后，还会继续搜索其他其它 location，直到找到优先级最高的，或者找到第一种情况而停止搜索 location 优先级从高到底： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ,* 正则顺序) &gt; (location 部分起始路径) &gt; (/) location = / &#123; # 精确匹配/，主机名后面不能带任何字符串 / [ configuration A ]&#125;location / &#123; # 匹配所有以 / 开头的请求。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration B ]&#125;location /documents/ &#123; # 匹配所有以 /documents/ 开头的请求，匹配符合以后，还要继续往下搜索。 # 但是如果有更长的同类型的表达式，则选择更长的表达式。 # 如果有正则表达式可以匹配，则优先匹配正则表达式。 [ configuration C ]&#125;location ^~ /images/ &#123; # 匹配所有以 /images/ 开头的表达式，如果匹配成功，则停止匹配查找，停止搜索。 # 所以，即便有符合的正则表达式location，也不会被使用 [ configuration D ]&#125;location ~* \\.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif jpg jpeg结尾的请求。 # 但是 以 /images/开头的请求，将使用 Configuration D，D具有更高的优先级 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，还会继续往下搜索 [ configuration F ]&#125;location = /test.htm &#123; root /usr/local/var/www/htm; index index.htm;&#125;注意：location的优先级与location配置的位置无关 三： 反向代理反向代理应该是 Nginx 使用最多的功能了，反向代理(Reverse Proxy)方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。反向代理通过 proxy_pass 指令来实现。 启动一个 Java Web 项目，端口号为 8081 server &#123; listen 80; server_name localhost; location / &#123; proxy_pass http://localhost:8081; proxy_set_header Host $host:$server_port; # 设置用户ip地址 proxy_set_header X-Forwarded-For $remote_addr; # 当请求服务器出错去寻找其他服务器 proxy_next_upstream error timeout invalid_header http_500 http_502 http_503; &#125;&#125; 当我们访问 localhost 的时候，就相当于访问 localhost:8081 了 四：负载均衡负载均衡也是 Nginx 常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如 Web 服务器、FTP 服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有 2 台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而 Nginx 目前支持自带 3 种负载均衡策略，还有 2 种常用的第三方策略。 负载均衡通过 upstream 指令来实现。 1 RR(round robin :轮询 默认)：每个请求按时间顺序逐一分配到不同的后端服务器，也就是说第一次请求分配到第一台服务器上，第二次请求分配到第二台服务器上，如果只有两台服务器，第三次请求继续分配到第一台上，这样循环轮询下去，也就是服务器接收请求的比例是 1:1， 如果后端服务器 down 掉，能自动剔除。轮询是默认配置，不需要太多的配置 同一个项目分别使用 8081 和 8082 端口启动项目 upstream web_servers &#123; server localhost:8081; server localhost:8082;&#125;server &#123; listen 80; server_name localhost; #access_log logs/host.access.log main; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; &#125; 访问地址仍然可以获得响应 http://localhost/api/user/login?username=zhangsan&amp;password=111111 ，这种方式是轮询的 2 权重指定轮询几率，weight 和访问比率成正比, 也就是服务器接收请求的比例就是各自配置的 weight 的比例，用于后端服务器性能不均的情况,比如服务器性能差点就少接收点请求，服务器性能好点就多处理点请求。 upstream test &#123; server localhost:8081 weight=1; server localhost:8082 weight=3; server localhost:8083 weight=4 backup;&#125; 示例是 4 次请求只有一次被分配到 8081 上，其他 3 次分配到 8082 上。backup 是指热备，只有当 8081 和 8082 都宕机的情况下才走 8083 3 ip_hash上面的 2 种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候(采用了 session 保存数据)，这时候就有一个很大的很问题了，比如把登录信息保存到了 session 中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用 iphash 了，iphash 的每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 upstream test &#123; ip_hash; server localhost:8080; server localhost:8081;&#125; 4 fair(第三方)按后端服务器的响应时间来分配请求，响应时间短的优先分配。这个配置是为了更快的给用户响应 upstream backend &#123; fair; server localhost:8080; server localhost:8081;&#125; 5 url_hash(第三方)按访问 url 的 hash 结果来分配请求，使每个 url 定向到同一个后端服务器，后端服务器为缓存时比较有效。 在 upstream 中加入 hash 语句，server 语句中不能写入 weight 等其他的参数，hash_method 是使用的 hash 算法 upstream backend &#123; hash $request_uri; hash_method crc32; server localhost:8080; server localhost:8081;&#125; 以上 5 种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过 fair 和 url_hash 需要安装第三方模块才能使用。 五：动静分离动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。 upstream web_servers &#123; server localhost:8081; server localhost:8082;&#125;server &#123; listen 80; server_name localhost; set $doc_root /usr/local/var/www; location ~* \\.(gif|jpg|jpeg|png|bmp|ico|swf|css|js)$ &#123; root $doc_root/img; &#125; location / &#123; proxy_pass http://web_servers; # 必须指定Header Host proxy_set_header Host $host:$server_port; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root $doc_root; &#125; &#125; 六：其他1.return 指令返回 http 状态码 和 可选的第二个参数可以是重定向的 URL location /permanently/moved/url &#123; return 301 http://www.example.com/moved/here;&#125; 2 rewrite 指令重写 URI 请求 rewrite，通过使用 rewrite 指令在请求处理期间多次修改请求 URI，该指令具有一个可选参数和两个必需参数。 第一个(必需)参数是请求 URI 必须匹配的正则表达式。 第二个参数是用于替换匹配 URI 的 URI。 可选的第三个参数是可以停止进一步重写指令的处理或发送重定向(代码 301 或 302)的标志 location /users/ &#123; rewrite ^/users/(.*)$ /show?user=$1 break;&#125; 3 error_page 指令使用 error_page 指令，您可以配置 NGINX 返回自定义页面以及错误代码，替换响应中的其他错误代码，或将浏览器重定向到其他 URI。 在以下示例中，error_page 指令指定要返回 404 页面错误代码的页面(/404.html)。 error_page 404 /404.html; 4 日志访问日志：需要开启压缩 gzip on; 否则不生成日志文件，打开 log_format、access_log 注释 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;access_log /usr/local/etc/nginx/logs/host.access.log main;gzip on; 5 deny 指令# 禁止访问某个目录location ~* \\.(txt|doc)$&#123; root $doc_root; deny all;&#125; 6 内置变量nginx 的配置文件中可以使用的内置变量以美元符$开始，也有人叫全局变量。其中，部分预定义的变量的值是可以改变的。 - $args ： #这个变量等于请求行中的参数，同$query_string- $content_length ： 请求头中的Content-length字段。- $content_type ： 请求头中的Content-Type字段。- $document_root ： 当前请求在root指令中指定的值。- $host ： 请求主机头字段，否则为服务器名称。- $http_user_agent ： 客户端agent信息- $http_cookie ： 客户端cookie信息- $limit_rate ： 这个变量可以限制连接速率。- $request_method ： 客户端请求的动作，通常为GET或POST。- $remote_addr ： 客户端的IP地址。- $remote_port ： 客户端的端口。- $remote_user ： 已经经过Auth Basic Module验证的用户名。- $request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。- $scheme ： HTTP方法（如http，https）。- $server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。- $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。- $server_name ： 服务器名称。- $server_port ： 请求到达服务器的端口号。- $request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。- $uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。- $document_uri ： 与$uri相同 转载nginx 应用场景","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"nginx","slug":"nginx","permalink":"https://luckyship.github.io/tags/nginx/"}]},{"title":"http请求头-什么是CSP","date":"2022-02-11T13:30:32.000Z","path":"2022/02/11/2022-02-11-CSP/","text":"一、简介CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。 CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。 两种方法可以启用 CSP。一种是通过 HTTP 头信息的Content-Security-Policy的字段。 Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;;style-src cdn.example.org third-party.org; child-src https: 另一种是通过网页的&lt;meta&gt;标签。 &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;/&gt; 上面代码中，CSP 做了如下配置。 脚本：只信任当前域名 &lt;object&gt;标签：不信任任何 URL，即不加载任何资源 样式表：只信任cdn.example.org和third-party.org 框架（frame）：必须使用 HTTPS 协议加载 其他资源：没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 Chrome 的报错信息。 Firefox 的报错信息。 二、限制选项CSP 提供了很多限制选项，涉及安全的各个方面。 2.1 资源加载限制以下选项限制各类资源的加载。 **script-src**：外部脚本 **style-src**：样式表 **img-src**：图像 **media-src**：媒体文件（音频和视频） **font-src**：字体文件 **object-src**：插件（比如 Flash） **child-src**：框架 **frame-ancestors**：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;） **connect-src**：HTTP 连接（通过 XHR、WebSockets、EventSource 等） **worker-src**：worker脚本 **manifest-src**：manifest 文件 2.2 default-srcdefault-src用来设置上面各个选项的默认值。 Content-Security-Policy: default-src &#x27;self&#x27; 上面代码限制所有的外部资源，都只能从当前域名加载。 如果同时设置某个单项限制（比如font-src）和default-src，前者会覆盖后者，即字体文件会采用font-src的值，其他资源依然采用default-src的值。 2.3 URL 限制有时，网页会跟其他 URL 发生联系，这时也可以加以限制。 **frame-ancestors**：限制嵌入框架的网页 **base-uri**：限制&lt;base#href&gt; **form-action**：限制&lt;form#action&gt; 2.4 其他限制其他一些安全相关的功能，也放在了 CSP 里面。 **block-all-mixed-content**：HTTPS 网页不得加载 HTTP 资源（浏览器已经默认开启） **upgrade-insecure-requests**：自动将网页上所有加载外部资源的 HTTP 链接换成 HTTPS 协议 **plugin-types**：限制可以使用的插件格式 **sandbox**：浏览器行为的限制，比如不能有弹出窗口等。 2.5 report-uri有时，我们不仅希望防止 XSS，还希望记录此类行为。report-uri就用来告诉浏览器，应该把注入行为报告给哪个网址。 Content-Security-Policy: default-src &#x27;self&#x27;; ...; report-uri /my_amazing_csp_report_parser; 上面代码指定，将注入行为报告给/my_amazing_csp_report_parser这个 URL。 浏览器会使用POST方法，发送一个 JSON 对象，下面是一个例子。 &#123; &quot;csp-report&quot;: &#123; &quot;document-uri&quot;: &quot;http://example.org/page.html&quot;, &quot;referrer&quot;: &quot;http://evil.example.com/&quot;, &quot;blocked-uri&quot;: &quot;http://evil.example.com/evil.js&quot;, &quot;violated-directive&quot;: &quot;script-src &#x27;self&#x27; https://apis.google.com&quot;, &quot;original-policy&quot;: &quot;script-src &#x27;self&#x27; https://apis.google.com; report-uri http://example.org/my_amazing_csp_report_parser&quot; &#125;&#125; 三、Content-Security-Policy-Report-Only除了Content-Security-Policy，还有一个Content-Security-Policy-Report-Only字段，表示不执行限制选项，只是记录违反限制的行为。 它必须与report-uri选项配合使用。 Content-Security-Policy-Report-Only: default-src &#x27;self&#x27;; ...; report-uri /my_amazing_csp_report_parser; 四、选项值每个限制选项可以设置以下几种值，这些值就构成了白名单。 主机名：example.org，https://example.com:443 路径名：example.org/resources/js/ 通配符：*.example.org，*://*.example.com:*（表示任意协议、任意子域名、任意端口） 协议名：https:、data: 关键字&#39;self&#39;：当前域名，需要加引号 关键字&#39;none&#39;：禁止加载任何外部资源，需要加引号 多个值也可以并列，用空格分隔。 Content-Security-Policy: script-src &#x27;self&#x27; https://apis.google.com 如果同一个限制选项使用多次，只有第一次会生效。 # 错误的写法script-src https://host1.com; script-src https://host2.com# 正确的写法script-src https://host1.com https://host2.com 如果不设置某个限制选项，就是默认允许任何值。 五、script-src 的特殊值除了常规值，script-src还可以设置一些特殊值。注意，下面这些值都必须放在单引号里面。 **&#39;unsafe-inline&#39;**：允许执行页面内嵌的&amp;lt;script&gt;标签和事件监听函数 **unsafe-eval**：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。 nonce 值：每次 HTTP 回应给出一个授权 token，页面内嵌脚本必须有这个 token，才会执行 hash 值：列出允许执行的脚本代码的 Hash 值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。 nonce 值的例子如下，服务器发送网页的时候，告诉浏览器一个随机生成的 token。 Content-Security-Policy: script-src &#x27;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#x27; 页面内嵌脚本，必须有这个 token 才能执行。 &lt;script nonce=&quot;EDNnf03nceIOfn39fn3e9h3sdfa&quot;&gt; // some code&lt;/script&gt; hash 值的例子如下，服务器给出一个允许执行的代码的 hash 值。 Content-Security-Policy: script-src &#x27;sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=&#x27; 下面的代码就会允许执行，因为 hash 值相符。 &lt;script&gt; alert(&#x27;Hello, world.&#x27;);&lt;/script&gt; 注意，计算 hash 值的时候，&lt;script&gt;标签不算在内。 除了script-src选项，nonce 值和 hash 值还可以用在style-src选项，控制页面内嵌的样式表。 六、注意点（1）script-src和object-src是必设的，除非设置了default-src。 因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。 （2）script-src不能使用unsafe-inline关键字（除非伴随一个 nonce 值），也不能允许设置data:URL。 下面是两个恶意攻击的例子。 &lt;img src=&quot;x&quot; onerror=&quot;evil()&quot; /&gt;&lt;script src=&quot;data:text/javascript,evil()&quot;&gt;&lt;/script&gt; （3）必须特别注意 JSONP 的回调函数。 &lt;script src=&quot;/path/jsonp?callback=alert(document.domain)&quot;&gt;&lt;/script&gt; 上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。 参考Content Security Policy 入门","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"html","slug":"html","permalink":"https://luckyship.github.io/tags/html/"}]},{"title":"前端模拟接口返回数据","date":"2021-11-30T09:01:46.000Z","path":"2021/11/30/2021-11-30-mock/","text":"Mock.js 是一个用于模拟数据的 JavaScript 库，常常被用于前端开发和单元测试。 在进行 Angular 项目开发时，经常需要与后端 API 进行交互，但是由于后端开发进度可能不同步，或者接口还未完成，需要模拟数据来进行前端开发或者测试。这个时候，我们可以使用 Mock.js 来解决这个问题。 为什么使用 Mock.js 解耦：在前端开发过程中，我们往往需要依赖后端接口进行开发，但是后端接口可能还没有开发完成，或者有一些状态码（如 404、500）无法通过正常访问。如果不使用 Mock.js 模拟数据，那么就会出现很多问题，开发工作量也会增加。使用 Mock.js 可以解耦前后端，即使后端接口还没有开发完成，也可以继续进行前端开发。 省时间：使用 Mock.js 可以快速生成数据，提高前端开发效率。 测试：使用 Mock.js 可以方便地进行单元测试和功能测试。 如何使用 Mock.js 模拟 API 请求安装 Mock.js$ npm install mockjs# 不安装ts中会报错$ npm install @types/mockjs 创建 mock 数据文件在项目根目录下创建mock文件夹，在该文件夹下创建data.js文件： import Mock from &quot;mockjs&quot;;// GET请求Mock.mock(&quot;/api/getData&quot;, &quot;get&quot;, () =&gt; &#123; return Mock.mock(&#123; &quot;data|10&quot;: [ &#123; name: &quot;@cname&quot;, &quot;age|20-30&quot;: 1, &quot;id|+1&quot;: 1, &#125;, ], &#125;);&#125;);// POST请求Mock.mock(&quot;/api/postData&quot;, &quot;post&quot;, (options) =&gt; &#123; const &#123; body &#125; = options; return Mock.mock(&#123; data: `hello, $&#123;JSON.parse(body).name&#125;!`, &#125;);&#125;); 在上面的代码中，我们分别对/api/getData和/api/postData进行了 GET 和 POST 请求的模拟。其中，Mock.mock方法可以用来生成符合指定格式的随机数据。 在 Angular 中使用 Mock.js我们可以在app.module.ts文件中创建一个HttpInterceptor来拦截 API 请求，并通过 Mock.js 返回模拟数据。 import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; HttpEvent, HttpHandler, HttpInterceptor, HttpRequest &#125; from &quot;@angular/common/http&quot;;import &#123; Observable &#125; from &quot;rxjs&quot;;import &#123; environment &#125; from &quot;../environments/environment&quot;;import &#123; MockService &#125; from &quot;./mock.service&quot;;@Injectable()export class MockInterceptor implements HttpInterceptor &#123; constructor(private mockService: MockService) &#123;&#125; intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; &#123; if (environment.useMock) &#123; // 判断是否开启Mock.js const mockData = this.mockService.getMockData(req); if (mockData) &#123; const response = new ResponseOptions(&#123; body: mockData &#125;); return Observable.of(new HttpResponse(response)); &#125; &#125; return next.handle(req); &#125;&#125; 在上述代码中，我们通过MockService来获取 Mock.js 返回的数据，并将其返回给前端。 接下来，在app.module.ts文件中引入该HttpInterceptor： import &#123; NgModule &#125; from &quot;@angular/core&quot;;import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; HttpClientModule, HTTP_INTERCEPTORS &#125; from &quot;@angular/common/http&quot;;import &#123; AppComponent &#125; from &quot;./app.component&quot;;import &#123; MockService &#125; from &quot;./mock.service&quot;;import &#123; MockInterceptor &#125; from &quot;./mock.interceptor&quot;;@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, HttpClientModule], providers: [ MockService, &#123; provide: HTTP_INTERCEPTORS, useClass: MockInterceptor, multi: true, &#125;, ], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 在上述代码中，我们将MockService和MockInterceptor作为提供者，并将MockInterceptor注册为全局的拦截器。 示例我们可以在app.component.ts文件中进行 API 请求的测试： import &#123; Component, OnInit &#125; from &quot;@angular/core&quot;;import &#123; HttpClient &#125; from &quot;@angular/common/http&quot;;@Component(&#123; selector: &quot;app-root&quot;, templateUrl: &quot;./app.component.html&quot;, styleUrls: [&quot;./app.component.css&quot;],&#125;)export class AppComponent implements OnInit &#123; title = &quot;Mock.js Demo&quot;; data: any; name: string; constructor(private http: HttpClient) &#123;&#125; ngOnInit(): void &#123; this.http.get(&quot;/api/getData&quot;).subscribe((res) =&gt; &#123; this.data = res[&quot;data&quot;]; &#125;); &#125; postData() &#123; this.http.post(&quot;/api/postData&quot;, &#123; name: this.name &#125;).subscribe((res) =&gt; &#123; alert(res[&quot;data&quot;]); &#125;); &#125;&#125; 在上述代码中，我们通过HttpClient进行 API 请求，分别请求了/api/getData和/api/postData。其中，GET 请求会在页面初始化时自动发送，而 POST 请求则需要手动调用。 总结通过引入 Mock.js，我们可以轻松地模拟后端 API 接口的请求与响应，从而提高前端开发效率。在使用 Angular 开发的过程中，我们可以通过创建HttpInterceptor拦截 API 请求，并使用 Mock.js 返回模拟数据的方式来实现该功能。","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"ng-template、ng-container、ng-content 的用法","date":"2021-11-30T08:51:34.000Z","path":"2021/11/30/2021-11-30-angular-container-template-content/","text":"ng-containerng-container：此标签不渲染成 DOM；默认显示标签内部内容，也可以使用结构型指令（ngIf、ngFor…） 官网详细介绍：https://angular.cn/guide/structural-directives eg：代码块 &lt;ng-container&gt; &lt;p&gt;Hello World !!!&lt;/p&gt;&lt;/ng-container&gt; 网页渲染结果 &lt;p _ngcontent-vkg-c0=&quot;&quot;&gt;Hello World !!!&lt;/p&gt; ng-contentng-content：父组件调用子组件时，将父组件内容投射到子组件指定位置（子组件中 ng-content 所在位置）；类似 VUE 中的插槽。分为默认投射，具名投射。 1）默认投射 - 子组件中只有一个 ng-content 时：eg 父组件中引入子组件 &lt;app-child-com&gt; &lt;p&gt;- parent component content !!! -&lt;/p&gt;&lt;/app-child-com&gt; 子组件 &lt;p&gt;child component content - begin&lt;/p&gt;&lt;ng-content&gt;&lt;/ng-content&gt;&lt;p&gt;child component content - end&lt;/p&gt; 显示效果 child component content - begin- parent component content !!!- child component content - end 2）具名投射 - 子组件有多个 ng-content，需要指定名字进行指定位置投射：eg 父组件内容 &lt;app-child-com&gt; &lt;header&gt;header - parent component content !!! -&lt;/header&gt; &lt;div id=&quot;demo&quot;&gt;id selector - parent component content !!! -&lt;/div&gt; &lt;div name=&quot;demo&quot;&gt;name - parent component content !!! -&lt;/div&gt;&lt;/app-child-com&gt; 子组件内容 &lt;p&gt;child component content&lt;/p&gt;&lt;ng-content select=&quot;header&quot;&gt;&lt;/ng-content&gt;&lt;p&gt;child component content&lt;/p&gt;&lt;ng-content select=&quot;#demo&quot;&gt;&lt;/ng-content&gt;&lt;p&gt;child component content&lt;/p&gt;&lt;ng-content select=&quot;[name=demo]&quot;&gt;&lt;/ng-content&gt; 使用 select 属性，支持 CSS 选择器 ng-templateng-template：模板元素，默认情况内部元素不可见。使用方法： 方法一：使用 ngIf 属性，值为 true 显示内容&lt;ng-template [ngIf]=&quot;condition&quot;&gt; &lt;p&gt;Hello World !!!&lt;/p&gt;&lt;/ng-template&gt; 扩展：以下代码会转换为以上代码显示 &lt;p *ngIf=&quot;condition&quot;&gt;Hello World !!!&lt;/p&gt; 方法二： 使用 ViewContainerRef，TemplateRef，ViewChild：eg组件 HTML &lt;!-- myTpl：模板引用变量；name1：模板输入变量；name：输入变量值；foo：默认输入变量 --&gt;&lt;ng-template #myTpl let-name1=&quot;name&quot; let-foo&gt; &lt;p&gt;调用的模板数据：&#123;&#123; name1 &#125;&#125; -- &#123;&#123; foo &#125;&#125;&lt;/p&gt;&lt;/ng-template&gt; 组件 TS，以上代码默认不起任何作用，不会渲染 DOM // Angular8 必填 &#123;static: boolean&#125; 属性true：变更检测之前解析查询结果；反之 // 获取指定模板（myTpl）引用 tpl@ViewChild(&#x27;myTpl&#x27;, &#123;static: true&#125;) tpl: TemplateRef&lt;any&gt;;constructor( private viewContainer: ViewContainerRef) &#123; &#125;// $implicit：默认输入变量取值ngOnInit() &#123; this.viewContainer.createEmbeddedView(this.tpl, &#123; $implicit: &quot;Hello&quot;, name: &#x27;World&#x27; &#125;);&#125; 效果，显示模板内容 方法三：使用 ngTemplateOutlet 结构型指令：eg组件 HTML &lt;!-- myTpl：模板引用变量；context：输入对象数据 --&gt;&lt;div&gt;&lt;ng-container *ngTemplateOutlet=&quot;myTpl; context: context&quot;&gt;&lt;/ng-container&gt;&lt;/div&gt;&lt;!-- myTpl：模板引用变量；name1：模板输入变量；name：输入变量值；foo：默认输入变量 --&gt;&lt;ng-template #myTpl let-name1=&quot;name&quot; let-foo&gt; &lt;p&gt;调用的模板数据：&#123;&#123; name1 &#125;&#125; -- &#123;&#123; foo &#125;&#125;&lt;/p&gt;&lt;/ng-template&gt; 组件 TS context = &#123; $implicit: &quot;World&quot;, name: &quot;liyq&quot; &#125;; 可以将指定模板插入到指定位置，TS 中只需要定义数据 方法四：使用自定义结构型指令，和 ngIf 类似：eg1）ng g d unless 创建一个名为 unless 的结构型指令 unless.directive.ts import &#123; Directive, TemplateRef, ViewContainerRef, Input &#125; from &#x27;@angular/core&#x27;;@Directive(&#123; selector: &#x27;[appUnless]&#x27;&#125;)export class UnlessDirective &#123; constructor( private templateRef: TemplateRef&lt;any&gt;, private viewContainer: ViewContainerRef ) &#123; &#125; // 必须使用 set 方法 @Input() set appUnless(condition: boolean) &#123; if(!condition) &#123; // 下面是渲染模板数据的核心 this.viewContainer.createEmbeddedView(this.templateRef); &#125; &#125;&#125; 组件 HTML &lt;!-- 模板渲染结果和 condition 的 Boolean 值没有关系，主要的作用为作为参数传递给自定义的结构指令 --&gt;&lt;ng-template [appUnless]=&quot;condition&quot;&gt; &lt;p&gt;使用结构型指令调用模板&lt;/p&gt;&lt;/ng-template&gt;","updated":"2025-08-02T05:46:04.179Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"webpack配置","date":"2021-10-26T07:15:01.000Z","path":"2021/10/26/2021-10-26-webpack-interview/","text":"随着现代前端开发的复杂度和规模越来越庞大，已经不能抛开工程化来独立开发了，如 react 的 jsx 代码必须编译后才能在浏览器中使用；又如 sass 和 less 的代码浏览器也是不支持的。 而如果摒弃了这些开发框架，那么开发的效率将大幅下降。在众多前端工程化工具中，webpack 脱颖而出成为了当今最流行的前端构建工具。 然而大多数的使用者都只是单纯的会使用，而并不知道其深层的原理。希望通过以下的面试题总结可以帮助大家温故知新、查缺补漏，知其然而又知其所以然。 问题一览 webpack 与 grunt、gulp 的不同？ 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？ 有哪些常见的 Loader？他们是解决什么问题的？ 有哪些常见的 Plugin？他们是解决什么问题的？ Loader 和 Plugin 的不同？ webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？ webpack 的热更新是如何做到的？说明其原理？ 如何利用 webpack 来优化前端性能？（提高性能和体验） 如何提高 webpack 的构建速度？ 怎么配置单页应用？怎么配置多页应用？ npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？ 如何在 vue 项目中实现按需加载？ 问题解答1. webpack 与 grunt、gulp 的不同？三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。 grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个 web 的构建流程。 webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。 所以总结一下： 从构建思路来说 gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工 对于知识背景来说 gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路 2. 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack 适用于大型复杂的前端站点构建 rollup 适用于基础库的打包，如 vue、react parcel 适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel 3.有哪些常见的 Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 4.有哪些常见的 Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 5.Loader 和 Plugin 的不同？不同的作用 Loader直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。 Plugin直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入。 6.webpack 的构建流程是什么?从读取配置到输出文件这个过程尽量说全Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 7.是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？Loader 像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。 编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。 相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 8.webpack 的热更新是如何做到的？说明其原理？webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： 首先要知道 server 端和 client 端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 9.如何利用 webpack 来优化前端性能？（提高性能和体验）用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css 利用CDN加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数–optimize-minimize 来实现 提取公共代码。 10.如何提高 webpack 的构建速度？ 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码 通过 externals 配置来提取常用库 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 使用 Happypack 实现多线程加速编译 使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码 11.怎么配置单页应用？怎么配置多页应用？单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 12.npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。 NPM 模块需要注意以下问题： 要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。 Npm 包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI 组件类的模块应该将依赖的其它资源文件，例如.css 文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化： CommonJS 模块化规范的解决方案： 设置 output.libraryTarget=’commonjs2’使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用 输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。 Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc 文件，为其加入 transform-runtime 插件 不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。 对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下： 13.如何在 vue 项目中实现按需加载？Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在.babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过 import(*)语句来控制加载时机，webpack 内置了对于 import(*)的解析，会将 import(*)中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到 import(*)语句时，会去加载 Chunk 对应生成的文件。import()会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill webpack 示例const path = require(&quot;path&quot;);const webpack = require(&quot;webpack&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const OptimizeCssAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);const AddAssetHtmlWebpackPlugin = require(&quot;add-asset-html-webpack-plugin&quot;);const TerserWebpackPlugin = require(&quot;terser-webpack-plugin&quot;); // 用terser-webpack-plugin替换掉uglifyjs-webpack-plugin解决uglifyjs不支持es6语法问题const WorkboxWebpackPlugin = require(&quot;workbox-webpack-plugin&quot;);process.env.NODE_ENV = &quot;production&quot;; // 定义nodejs环境变量，设置browserslist使用哪个参数/** * 开发环境性能优化： * 优化打包速度： * # HMR * 优化代码调试： * # source-map * * 生产环境性能优化： * 1. 优化打包构建速度 * # oneOf * # babel缓存 * # 多进程打包 * # externals (CDN链接) * # dll * * * 2. 优化代码运行时的性能 * # 缓存（hash/chunkhash/contenthash） * # tree shaking 去除代码中没有用的代码，减少打包体积 * # 代码分割 * # 懒加载、预加载 * # pwa * # *//** * 缓存：最终确定使用contenthash * 1. babel缓存：--&gt; 让第二次打包构建速度更快 * cacheDirectory: true * 2. 文件资源缓存：--&gt; 让代码上线运行缓存使用 * hash 使用hash值做缓存，文件资源缓存，每次webpack构建打包生成的hash值 * 问题： 重新打包所有缓存失效，css和js同时使用一个hash * chunkhash: 根据chunk生成的hash值，如果打包来源一个chunk，则hash值一样 * 问题：css是js中被引入的，所以同属于一个chunk * contenthash: 根据文件的内容生成hash，不同的文件hash值不一样 *//** * tree shaking: 去除无用代码，减少打包体积 * 前提：1. 必须使用ES6模块化；2. 开启production模式 * 在package.json中配置 * &quot;sideEffects&quot;: false, // 所有代码都没有副作用（都可以进行tree shaking) * 问题：可能把css/@babel/polyfill （副作用）文件干掉 * &quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;*.less&quot;] // 不会把css文件当副作用文件 *//** * PWA: 渐进式网络开发应用程序（离线可访问） * workbox --&gt; workbox-webpack-plugin *//** * 多进程 * 进程启动大概600ms,进程通信也有开销，只有工作销毁时间比较长才需要多进程打包 * js代码： 使用 thread-loader 在最后使用该loader *//** * DLL: 对某些第三方的库（jQuery, react, vue...）进行单独打包 * 需要新创建一个配置文件webpack.dll.js * 运行webpack 默认查找webpack.config.js文件 * 运行webpack.dll.js需要制定配置文件 --&gt; webpack --config webpack.dll.js * module.exports = &#123; entry: &#123; // 最终打包生成的[name] jquery: [&#x27;jquery&#x27;] &#125;, output: &#123; path: path.join(__dirname, &#x27;dll&#x27;), filename: &#x27;[name].js&#x27;, library: &#x27;[name]_[hash]&#x27; &#125;, plugins: &#123; // 打包生成一个manifest.json文件--&gt;提供和jquery的映射 new webpack.DllPlugin(&#123; name: &#x27;[name]_[hash]&#x27;, // 映射库的暴露的内容的名称 path: path.join(__dirname, &#x27;dll/manifest.json&#x27;) // 输出文件路径 &#125;) &#125;&#125;; */// 复用cssloaderconst commonCssLoader = [ // &#x27;style-loader&#x27;, // 创建style标签，将js中的样式资源进行插入，添加到head中生效 MiniCssExtractPlugin.loader, // 替换&#x27;style-loader&#x27;，提取js中的css成单独文件 &quot;css-loader&quot;, // 将css文件变成commonjs模块加载到js中，里面内容是样式字符串 &#123; /**还需要再package.json这两年个定义 browserslist * &quot;browserslist&quot;: &#123; * &quot;development&quot;: [ * &quot;last 1 chrome version&quot;, * &quot;last 1 firefox version&quot;, * &quot;last 1 safari version&quot;, * ], * &quot;production&quot;: [ * &quot;&gt;0.2%&quot;, * &quot;not dead&quot;, * &quot;not op_mini all&quot; * ] * &#125; * */ loader: &quot;postcss-loader&quot;, options: &#123; ident: &quot;postcss&quot;, plugins: () =&gt; &#123; require(&quot;postcss-preset-env&quot;)(); &#125;, &#125;, &#125;,];module.exports = &#123; // 入口起点 entry: path.join(__dirname, &quot;src/index.js&quot;), // 单入口 // entry: &#123; // 多入口：几个入口就有几个bundle // app: path.join(__dirname, &#x27;src/index.js&#x27;), // &#125;, // 输出 output: &#123; // 输出文件目录 path: path.join(__dirname, &quot;dist&quot;), // 文件名称 filename: &quot;js/[name].[contenthash:10].js&quot;, // 所有资源引入公共路径前缀--&gt; 用于生产环境 publicPath: &quot;/&quot;, chunkFilename: &quot;js/[name].[contenthash:10]_chunk.js&quot;, // 非入口chunk的名称 library: &quot;[name]&quot;, // 整个库向外暴露的变量名 libraryTarget: &quot;window&quot;, // 变量名添加到哪一个上 browser; &#x27;global&#x27;(node)/&#x27;commonjs&#x27; &#125;, /** * 代码分割：chunk表示一个文件 chunk表示一个文件 * 1. 将node_modules中的代码单独打包成一个chunk最终输出 * 2. 自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk */ optimization: &#123; // 配置生产环境的 minimizer: [ // 配置生产环境的压缩方案：js和css new TerserWebpackPlugin(&#123; cache: true, // 开启缓存 parallel: true, // 开启多进程打包 sourceMap: true, &#125;), ], // 一定要加: 将当前模块的记录其他模块的hash单独打包成为一个runtime // 解决：修改a文件导致b文件的contenthash变化 runtimeChunk: &#123; name: entrypoint =&gt; `runtime-$&#123;entrypoint.name&#125;`, &#125;, splitChunks: &#123; chunks: &quot;all&quot;, minSize: 30 * 1024, // 分割的chunk最小为30kb，小于30kb不提取 maxSize: 0, // 无最大的限制 minChunks: 1, // 要提取的chunk最少被引用一次 maxAsyncRequests: 5, // 按需加载时并行加载的文件的最大数量 maxInitialRequests: 3, // 入口js文件最大并行请求数量 automaticNameDelimiter: &quot;~&quot;, // 名称连接符 name: true, // 可以使用命名规则 cacheGroups: &#123; // 分割chunk的组 // node_modules文件会被打包到vendors组的chunk中 // 满足上面的公共规则 vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10, // 优先级 &#125;, default: &#123; minChunks: 2, // 要提取的chunk至少被引用2次 prority: -20, reuseExistingChunk: true, // 如果当前要打包的模块和之前已经被提取的模块是用一个就会复用，不会重新打包模块 &#125;, &#125;, &#125;, &#125;, externals: &#123; // 使用CDN: 拒绝jQuery被打包进来（忽略的库名，npm包名），需要手动引入进来使用CDN，速度更快 // 不适用CDN可以使用DLL jquery: &quot;jquery&quot;, &#125;, // 解析模块的规则 resolve: &#123; // 配置解析模块的路径别名: 简写路径，缺点是路径没有提示 alias: &#123; $css: path.join(__dirname, &quot;src/css&quot;), &#125;, // 配置省略文件路径的后缀名 extensions: [&quot;.js&quot;, &quot;.json&quot;, &quot;.jsx&quot;], // 告诉webpack 解析模块去哪个目录找 modules: [&quot;node_modules&quot;], &#125;, module: &#123; rules: [ &#123; /** 语法检查：--&gt;eslint-loader eslint * 只检查源代码, 设置检查规则package.json 中的 eslintConfig * &quot;eslintConfig&quot;: &#123; * &quot;extends&quot;: &quot;airbnb-base&quot; * &#125; * airbnb--&gt; eslint eslint-config-airbnb-base eslint-plugin-import */ test: &quot;/.js$/&quot;, loader: &quot;eslint-loader&quot;, enforce: &quot;pre&quot;, // pre: 优先执行; post: 推迟执行 exculde: /node_modules/, // 排除一些文件 include: path.join(__dirname, &quot;src&quot;), // 只检查src目录下的 options: &#123; fix: true, &#125;, &#125;, // 以下loader只会匹配一个，注意不能有两个配置处理同一种类型的文件 &#123; oneOf: [ &#123; /** js兼容性处理： * 1. 基本js兼容性: --&gt; babel-loader @babel/core @babel/preset-env * 问题：只能转换基本语法，如promise不能转换 * 2. 全部js兼容性处理：--&gt; @babel/polyfill * 在index.js 中 import &#x27;@babel/polyfill&#x27;既可 * 问题：将所有兼容性代码全部引入，体积太大 * 3. 需要做兼容性处理的就做：按需加载 --&gt; core-js * */ test: &quot;/.js$/&quot;, exclude: &quot;/node_modules/&quot;, use: [ &#123; loader: &quot;thread-loader&quot;, // 开启多进程打包 options: &#123; workers: 2, &#125;, &#125;, &#123; loader: &quot;babel-loader&quot;, options: &#123; // 预设：指示babel做怎么样的兼容性处理 presets: [ &quot;@babel/preset-env&quot;, // 方法1 &#123; // 方法3-按需加载（不能使用方法2 @babel/polyfill） useBuiltIns: &quot;usage&quot;, corejs: &#123; // 指定core-js版本 version: 3, &#125;, // 兼容的浏览器版本 targets: &#123; chrome: &quot;60&quot;, firefox: &quot;60&quot;, ie: &quot;9&quot;, safari: &quot;10&quot;, egde: &quot;17&quot;, &#125;, &#125;, ], // 开启babel缓存，第二次构建时会读取之前的缓存 cacheDirectory: true, &#125;, &#125;, ], &#125;, &#123; // 处理css资源 test: &quot;/.css$/&quot;, use: [ // use数组中loader 执行顺序：从右向左，从下向上依次执行 ...commonCssLoader, ], &#125;, &#123; // 处理less资源 test: &quot;/.less$/&quot;, use: [ // 需要下载 --&gt; less-loader less ...commonCssLoader, &quot;less-loader&quot;, // 将less文件编译成css文件 ], &#125;, &#123; // 处理图片资源 test: /\\.(png|jpg|jpeg|gif|svg)$/, // 默认处理不了html中的img图片 // 下载-- &gt; url-loader file-loader loader: &quot;url-loader&quot;, options: &#123; outputPath: &quot;img/&quot;, // 图片输出的路径 limit: 5 * 1024, // 图片大小小于5kb，就会被base64处理，优点：减少请求数量；缺点：图片体积会更大 // url-loader默认使用es6模块化解析，html-loader引入图片是commonjs，解析会出问题 esModule: false, &#125;, &#125;, &#123; test: &quot;/.html$/&quot;, // 处理html中的umg图片（负责引入img，从而被url-loader处理） // 下载 --&gt; html-loader loader: &quot;html-loader&quot;, &#125;, &#123; // 打包其他资源（除了html/js/css以外资源) exclude: /\\.(css|js|html|less)$/, loader: &quot;file-loader&quot;, options: &#123; name: &quot;[name].[contenthash:10].[ext]&quot;, &#125;, &#125;, ], &#125;, ], &#125;, plugins: [ // 默认创建空的HTML，自动引入打包输出的所有资源 new HtmlWebpackPlugin(&#123; // 复制template的html文件，自动引入打包输出的所有资源 template: &quot;src/index.html&quot;, // html压缩 minify: &#123; collapseWhitespace: true, // 移除空格 removeComments: true, //移除注释 &#125;, &#125;), // css提取成单独文件 new MiniCssExtractPlugin(&#123; filename: &quot;css/[name].[contenthash:10].css&quot;, &#125;), // 压缩css new OptimizeCssAssetsPlugin(), new WorkboxWebpackPlugin(&#123; /** * 1. 帮助serviceworker快速启动 * 2. 删除旧的 serviceworker * 生产一个serviceworker配置文件 */ clientClaim: true, skipWaiting: true, &#125;), // 告诉webpack 哪些库不参与打包, 同时使用时的名称也得改变 new webpack.DllReferencePlugin(&#123; manifest: path.join(__dirname, &quot;dll/manifest.json&quot;), &#125;), // 将某个文件打包输出出去，并在html中自动引入该资源 new AddAssetHtmlWebpackPlugin(&#123; filename: path.join(__dirname, &quot;dll/jquery.js&quot;), &#125;), ], mode: &quot;development&quot;, // &#x27;production&#x27;, // 生产环境自动压缩js代码 devServer: &#123; // 开发服务器：自动化编译，自动化刷新浏览器等 contentBase: path.join(__dirname, &quot;dist&quot;), watchContentBase: true, // 检视contentBase目录下的所有文件，一点文件变化就reload watchOptions: &#123; // 忽略监视文件 ignored: /node_modules/, &#125;, compress: true, // 启动gzip压缩 port: 3000, // 指定端口号 host: &quot;0.0.0.0&quot;, // 指定域名 localhost open: true, hot: true, // 热替换 开启HMR功能 stats: &#123; colors: true &#125;, clientLogLevel: &quot;none&quot;, // 不要显示启动服务器日志信息 quiet: true, // 除一些基本启动信息以外，其他内容不要展示 overlay: false, //如果出错不要全屏提示 // 服务器代理，解决开发环境的跨域问题 prxoy: &#123; // 一旦接受到/api/xxx 穷奇就会转发到另一个服务器3000 &quot;/api&quot;: &#123; target: &quot;http://localhost:3000&quot;, // 发生请求时，请求路径重写，去掉api pathRewrite: &#123; &quot;^api&quot;: &quot;&quot;, &#125;, &#125;, &#125;, &#125;, devtool: &quot;source-map&quot;, // &#x27;eval-source-map&#x27;&#125;; 参考关于 webpack 的面试题","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"ReDos攻击","date":"2021-10-25T09:52:43.000Z","path":"2021/10/25/2021-10-25-ReDos/","text":"ReDoS 原理概述DFA对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA要翻来覆去吃字符、吐字符，速度慢，但是特性(如:分组、替换、分割)丰富。NFA支持 惰性(lazy)、回溯(backtracking)、反向引用(backreference)，NFA缺省应用greedy模式，NFA可能会陷入递归险境导致性能极差。 说明我们定义一个正则表达式^(a+)+$来对字符串aaaaX匹配。使用NFA的正则引擎，必须经历2^4=16次尝试失败后才能否定这个匹配。同理字符串为aaaaaaaaaaX就要经历2^10=1024次尝试。如果我们继续增加a的个数为 20 个、30 个或者更多，那么这里的匹配会变成指数增长。 下面我们以python语言为例子来进行代码的演示: #!/usr/bin/env python# coding: utf-8import reimport timedef exp(target_str): &quot;&quot;&quot; &quot;&quot;&quot; s1 = time.time() flaw_regex = re.compile(&#x27;^(a+)+$&#x27;) flaw_regex.match(target_str) s2 = time.time() print(&quot;Consuming time: %.4f&quot; % (s2-s1))if __name__ == &#x27;__main__&#x27;: str_list = ( &#x27;aaaaaaaaaaaaaaaaX&#x27;, # 2^16 &#x27;aaaaaaaaaaaaaaaaaaX&#x27;, # 2^18 &#x27;aaaaaaaaaaaaaaaaaaaaX&#x27;, # 2^20 &#x27;aaaaaaaaaaaaaaaaaaaaaaX&#x27;, # 2^22 &#x27;aaaaaaaaaaaaaaaaaaaaaaaaX&#x27;, # 2^24 &#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaX&#x27;, # 2^26 &#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX&#x27;, # 2^36 ) for evil_str in str_list: print(&#x27;Current: %s&#x27; % evil_str) exp(evil_str) print(&#x27;--&#x27;*40) 把上面的代码保存成redos.py文件并执行这个 py 脚本文件: $ python redos.pyCurrent: aaaaaaaaaaaaaaaaXConsuming time: 0.0043--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaXConsuming time: 0.0175--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaaaXConsuming time: 0.0678--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaaaaaXConsuming time: 0.2370--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaaaaaaaXConsuming time: 0.9842--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaaaaaaaaaXConsuming time: 4.1069--------------------------------------------------------------------------------Current: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaX 输出到最后一行貌似程序卡住了 总结每个恶意的正则表达式模式应该包含： 使用重复分组构造 在重复组内会出现 重复 交替重叠 有缺陷的正则表达式会包含如下部分： (a+)+ ([a-zA-Z]+)* (a|aa)+ (a|a?)+ (.*a)&#123;x&#125; | for x &gt; 10 注意: 这里的a是个泛指 实例下面我们来展示一些实际业务场景中会用到的缺陷正则。 英文的个人名字: Regex: ^[a-zA-Z]+(([\\&#39;\\,\\.\\-][a-zA-Z ])?[a-zA-Z]*)*$ Payload: aaaaaaaaaaaaaaaaaaaaaaaaaaaa! Java Classname Regex: ^(([a-z])+.)+[A-Z]([a-z])+$ Payload: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa! Email 格式验证 Regex: ^([0-9a-zA-Z]([-.\\w]*[0-9a-zA-Z])*@(([0-9a-zA-Z])+([-\\w]*[0-9a-zA-Z])*\\.)+[a-zA-Z]&#123;2,9&#125;)$ Payload: a@aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa! 多个邮箱地址验证 Regex: ^[a-zA-Z]+(([\\&#39;\\,\\.\\-][a-zA-Z ])?[a-zA-Z]*)*\\s+&amp;lt;(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w&#123;2,3&#125;)&amp;gt;$|^(\\w[-._\\w]*\\w@\\w[-._\\w]*\\w\\.\\w&#123;2,3&#125;)$ Payload: aaaaaaaaaaaaaaaaaaaaaaaa! 复数验证 Regex: ^\\d*[0-9](|.\\d*[0-9]|)*$ Payload: 1111111111111111111111111! 模式匹配 Regex: ^([a-z0-9]+([\\-a-z0-9]*[a-z0-9]+)?\\.)&#123;0,&#125;([a-z0-9]+([\\-a-z0-9]*[a-z0-9]+)?)&#123;1,63&#125;(\\.[a-z0-9]&#123;2,7&#125;)+$ Payload: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa! 使用python来进行测试有缺陷的正则示例: $ python -c &quot;import re;re.match(&#39;^[a-zA-Z]+(([\\&#39;\\,\\.\\-][a-zA-Z ])?[a-zA-Z]*)*$&#39;, &#39;aaaaaaaaaaaaaaaaaaaaaaaaaaaa!&#39;)&quot; ReDoS 防范哪里会用到Regex, 几乎在我们的网络程序与设备资源的任何位置都会用到。如: WAF、Web前端、Web后端、DB数据库等。 常见位置客户端 浏览器 移动设备 服务器端 防范手段防范手段只是为了降低风险而不能百分百消除 ReDoS 这种威胁。当然为了避免这种威胁的最好手段是尽量减少正则在业务中的使用场景或者多做测试, 增加服务器的性能监控等。 降低正则表达式的复杂度, 尽量少用分组 严格限制用户输入的字符串长度(特定情况下) 使用单元测试、fuzzing 测试保证安全 使用静态代码分析工具, 如: sonar 添加服务器性能监控系统, 如: zabbix 参考浅析 ReDoS前端 ReDOS 攻击","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"regex","slug":"regex","permalink":"https://luckyship.github.io/tags/regex/"}]},{"title":"commonJS、AMD、CMD、UMD、ES6 module","date":"2021-10-25T08:04:18.000Z","path":"2021/10/25/2021-10-25-moudle/","text":"commonJS 特点： 1、模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。2、模块加载会阻塞接下来代码的执行，需要等到模块加载完成才能继续执行——同步加载。 环境：服务器环境 应用：nodejs 的模块规范是参照 commonJS 实现的。 语法： 1、导入：require(‘路径’)2、导出：module.exports 和 exports 注意：module.exports 和 exports 的的区别是 exports 只是对 module.exports 的一个引用，相当于 Node 为每个模块提供一个 exports 变量，指向 module.exports。这等同在每个模块头部，有一行var exports = module.exports;这样的命令。 demo // a.js// 相当于这里还有一行：var exports = module.exports;代码exports.a = &#x27;Hello world&#x27;; // 相当于：module.exports.a = &#x27;Hello world&#x27;;// b.jsvar moduleA = require(&#x27;./a.js&#x27;);console.log(moduleA.a); // 打印出hello world AMD 特点： 1、异步加载2、管理模块之间的依赖性，便于代码的编写和维护。 环境：浏览器环境 应用：requireJS 是参照 AMD 规范实现的 语法： 1、导入：require([‘模块名称’], function (‘模块变量引用’){// 代码});3、导出：define(function (){return ‘值’); demo // a.jsdefine(function () &#123; return &#123; a: &#x27;hello world&#x27;, &#125;;&#125;);// b.jsrequire([&#x27;./a.js&#x27;], function (moduleA) &#123; console.log(moduleA.a); // 打印出：hello world&#125;); CMD 特点 1、CMD 是在 AMD 基础上改进的一种规范，和 AMD 不同在于对依赖模块的执行时机处理不同，CMD 是就近依赖，而 AMD 是前置依赖。 环境：浏览器环境 应用：seajs 是参照 UMD 规范实现的，requireJS 的最新的几个版本也是部分参照了 UMD 规范的实现 语法： 1、导入：define(function(require, exports, module) {});2、导出：define(function (){return ‘值’); demo // a.jsdefine(function (require, exports, module) &#123; exports.a = &#x27;hello world&#x27;;&#125;);// b.jsdefine(function (require, exports, module) &#123; var moduleA = require(&#x27;./a.js&#x27;); console.log(moduleA.a); // 打印出：hello world&#125;); UMD 特点： 1、兼容 AMD 和 commonJS 规范的同时，还兼容全局引用的方式 环境：浏览器或服务器环境 应用：无 语法： 1、无导入导出规范，只有如下的一个常规写法： 常规写法： (function (root, factory) &#123;if (typeof define === &#x27;function&#x27; &amp;&amp; define.amd) &#123;//AMDdefine([&#x27;jquery&#x27;], factory);&#125; else if (typeof exports === &#x27;object&#x27;) &#123;//Node, CommonJS 之类的module.exports = factory(require(&#x27;jquery&#x27;));&#125; else &#123;//浏览器全局变量(root 即 window)root.returnExports = factory(root.jQuery);&#125;&#125;(this, function ($) &#123;//方法function myFunc()&#123;&#125;;//暴露公共方法return myFunc;&#125;)); ES6 module 特点： 1、按需加载（编译时加载）2、import 和 export 命令只能在模块的顶层，不能在代码块之中（如：if 语句中）,import()语句可以在代码块中实现异步动态按需动态加载 环境：浏览器或服务器环境（以后可能支持） 应用：ES6 的最新语法支持规范 语法： 1、导入：import {模块名 A，模块名 B…} from ‘模块路径’2、导出：export 和 export default3、import(‘模块路径’).then()方法 注意：export 只支持对象形式导出，不支持值的导出，export default 命令用于指定模块的默认输出，只支持值导出，但是只能指定一个，本质上它就是输出一个叫做 default 的变量或方法。 规范： /*错误的写法*/// 写法一export 1;// 写法二var m = 1;export m;// 写法三if (x === 2) &#123;import MyModual from &#x27;./myModual&#x27;;&#125;/*正确的三种写法*/// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;;// 写法四var n = 1;export default n;// 写法五if (true) &#123;import(&#x27;./myModule.js&#x27;).then((&#123;export1, export2&#125;) =&gt; &#123;// ...·&#125;);&#125;// 写法六Promise.all([import(&#x27;./module1.js&#x27;),import(&#x27;./module2.js&#x27;),import(&#x27;./module3.js&#x27;),]).then(([module1, module2, module3]) =&gt; &#123;···&#125;); 转载JS 模块规范：AMD、UMD、CMD、commonJS、ES6 module","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"http和https","date":"2021-10-16T08:26:06.000Z","path":"2021/10/16/2021-10-16-http-and-https/","text":"HTTP 的特点和缺点特点：无连接、无状态、灵活、简单快速 无连接：每一次请求都要连接一次，请求结束就会断掉，不会保持连接 无状态：每一次请求都是独立的，请求结束不会记录连接的任何信息(提起裤子就不认人的意思)，减少了网络开销，这是优点也是缺点 灵活：通过 http 协议中头部的Content-Type标记，可以传输任意数据类型的数据对象(文本、图片、视频等等)，非常灵活 简单快速：发送请求访问某个资源时，只需传送请求方法和 URL 就可以了，使用简单，正由于 http 协议简单，使得 http 服务器的程序规模小，因而通信速度很快 缺点：无状态、不安全、明文传输、队头阻塞 无状态：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大 不安全：明文传输可能被窃听不安全，缺少身份认证也可能遭遇伪装，还有缺少报文完整性验证可能遭到篡改 明文传输：报文(header 部分)使用的是明文，直接将信息暴露给了外界，WIFI陷阱就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息 队头阻塞：开启长连接(下面有讲)时，只建立一个 TCP 连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲) HTTP 报文组成部分http 报文：由请求报文和响应报文组成 请求报文：由请求行、请求头、空行、请求体四部分组成 响应报文：由状态行、响应头、空行、响应体四部分组成 请求行：包含 http 方法，请求地址，http 协议以及版本 请求头/响应头：就是一些 key:value 来告诉服务端我要哪些内容，要注意什么类型等，请求头/响应头每一个字段详解 空行：用来区分首部与实体，因为请求头都是 key:value 的格式，当解析遇到空行时，服务端就知道下一个不再是请求头部分，就该当作请求体来解析了 请求体：请求的参数 状态行：包含 http 协议及版本、数字状态码、状态码英文名称 响应体：服务端返回的数据 HTTP 请求方法(9 种)HTTP1.0： GET、POST、HEAD HTTP1.1： PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT 方法 描述 GET 获取资源 POST 传输资源，通常会造成服务器资源的修改 HEAD 获得报文首部 PUT 更新资源 PATCH 对 PUT 的补充，对已知资源部分更新 菜鸟 DELETE 删除资源 OPTIONS 列出请求资源支持的请求方法，用来跨域请求 TRACE 追踪请求/响应路径，用于测试或诊断 CONNECT 将连接改为管道方式用于代理服务器(隧道代理下面有讲) GET 和 POST 的区别 GET在浏览器回退时是无害的，而POST会再次发起请求 GET请求会被浏览器主动缓存，而POST不会，除非手动设置 GET请求参数会被安逗保留在浏览器历史记录里，而POST中的参数不会被保留 GET请求在URL中传递的参数有长度限制(浏览器限制大小不同)，而POST没有限制 GET参数通过URL传递，POST放在Request body中 GET产生的 URL 地址可以被收藏，而POST不可以 GET没有POST安全，因为GET请求参数直接暴露在URL上，所以不能用来传递敏感信息 GET请求只能进行URL编码，而POST支持多种编码方式 对参数的数据类型，GET只接受ASCII字符，而POST没有限制 GET产生一个 TCP 数据包，POST产生两个数据包(Firefox 只发一次)。GET 浏览器把 http header 和 data 一起发出去，响应成功 200，POST 先发送 header，响应 100 continue，再发送 data，响应成功 200 常见 HTTP 状态码1xx: 指示信息——表示请求已接收，继续处理 2xx: 成功——表示请求已被成功接收 3xx: 重定向——表示要完成请求必须进行进一步操作 4xx: 客户端错误——表示请求有语法错误或请求无法实现 5xx: 服务端错误——表示服务器未能实现合法的请求 状态码 描述 200 请求成功 206 已完成指定范围的请求(带 Range 头的 GET 请求),场景如 video,audio 播放文件较大,文件分片时 301 永久重定向 302 临时重定向 304 请求资源未修改，可以使用缓存的资源，不用在服务器取 400 请求有语法错误 401 没有权限访问 403 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时 404 请求资源不存在 500 服务器内部错误，无法完成请求 503 请求未完成，因服务器过载、宕机或维护等 什么是持久连接/长连接http1.0协议采用的是”请求-应答”模式，当使用普通模式，每个请求/应答客户与服务器都要新建一个连接，完成之后立即断开连接(http协议为无连接的协议) http1.1版本支持长连接，即请求头添加Connection: Keep-Alive，使用 Keep-Alive 模式(又称持久连接，连接复用)建立一个TCP连接后使客户端到服务端的连接持续有效，可以发送/接受多个http请求/响应，当出现对服务器的后续请求时，Keep-Alive 功能避免了建立或者重新建立连接 如图：短连接极大的降低了传输效率 长连接优缺点优点 减少CPU及内存的使用，因为不需要经常建立和关闭连接 支持管道化的请求及响应模式 减少网络堵塞，因为减少了 TCP 请求 减少了后续请求的响应时间，因为不需要等待建立 TCP、握手、挥手、关闭 TCP 的过程 发生错误时，也可在不关闭连接的情况下进行错误提示 缺点 一个长连接建立后，如果一直保持连接，对服务器来说是多么的浪费资源呀，而且长连接时间的长短，直接影响到服务器的并发数 还有就是可能造成队头堵塞(下面有讲)，造成信息延迟 如何避免长连接资源浪费？ 客户端请求头声明：Connection: close，本次通信后就关闭连接 服务端配置：如 Nginx，设置keepalive_timeout设置长连接超时时间，keepalive_requests设置长连接请求次数上限 系统内核参数设置： net.ipv4.tcp_keepalive_time = 60，连接闲置 60 秒后，服务端尝试向客户端发送侦测包，判断 TCP 连接状态，如果没有收到 ack 反馈就在 net.ipv4.tcp_keepalive_intvl = 10，就在 10 秒后再次尝试发送侦测包，直到收到 ack 反馈，一共会 net.ipv4.tcp_keepalive_probes = 5，一共会尝试 5 次，要是都没有收到就关闭这个 TCP 连接了 什么是管线化(管道化)http1.1在使用长连接的情况下，建立一个连接通道后，连接上消息的传递类似于 请求 1 -&gt; 响应 1 -&gt; 请求 2 -&gt; 响应 2 -&gt; 请求 3 -&gt; 响应 3 管理化连接的消息就变成了类似这样 请求 1 -&gt; 请求 2 -&gt; 请求 3 -&gt; 响应 1 -&gt; 响应 2 -&gt; 响应 3 管线化是在同一个 TCP 连接里发一个请求后不必等其回来就可以继续发请求出去，这可以减少整体的响应时间，但是服务器还是会按照请求的顺序响应请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题队头堵塞(下面有讲解决方法) 管线化的特点： 管线化机制通过持久连接完成，在http1.1版本才支持 只有GET请求和HEAD请求才可以进行管线化，而POST有所限制 初次创建连接时不应启动管线化机制，因为服务器不一定支持 http1.1 版本的协议 管线化不会影响响应到来的顺序，如上面的例子所示，响应返回的顺序就是请求的顺序 要求客户端和服务端都支持管线化，但并不要求服务端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可 由于上面提到的服务端问题，开户管线化很可能并不会带来大幅度的性能提升，而且很多服务端和代理程序对管线化的支持并不好，因为浏览器(Chrome/Firefox)默认并未开启管线化支持 如何解决 HTTP 的队头阻塞问题http1.0协议采用的是请求-应答模式，报文必须是一发一收，就形成了一个先进先出的串行队列，没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求最先处理，就导致如果队首的请求耗时过长，后面的请求就只能处于阻塞状态，这就是著名的队头阻塞问题。解决如下： 并发连接因为一个域名允许分配多个长连接，就相当于增加了任务队列，不至于一个队列里的任务阻塞了其他全部任务。以前在 RFC2616 中规定过客户端最多只能并发 2 个连接，但是现实是很多浏览器不按套路出牌，就是遵守这个标准 T_T，所以在 RFC7230 把这个规定取消掉了，现在的浏览器标准中一个域名并发连接可以有6~8个，记住是 6~8 个，不是 6 个(Chrome6 个/Firefox8 个) 如果这个还不能满足你 继续，不要停… 域名分片一个域名最多可以并发 6~8 个，那咱就多来几个域名 比如 a.baidu.com，b.baidu.com，c.baidu.com，多准备几个二级域名，当我们访问 baidu.com 时，可以让不同的资源从不同的二域名中获取，而它们都指向同一台服务器，这样能够并发更多的长连接了 而在HTTP2.0下，可以一瞬间加载出来很多资源，因为支持多路复用，可以在一个 TCP 连接中发送多个请求 说一下 HTTP 代理常见的代理有两种：普通代理(中间人代理)，隧道代理 普通代理(中间人代理) 如图：代理服务器相当于一个中间人，一直帮两边传递东西，好可怜~~ 不过它可以在中间可以帮我们过滤、缓存、负载均衡(多台服务器共用一台代理情况下)等一些处理 注意，实际场景中客户端和服务器之间可能有多个代理服务器 隧道代理客户端通过CONNECT方法请求隧道代理创建一个可以到任意目标服务器和端口号的 TCP 连接，创建成功之后隧道代理只做请求和响应数据的转发，中间它不会做任何处理 为什么需要隧道代理呢？ 我们都知道https服务是需要网站有证书的，而代理服务器显然没有，所以浏览器和代理之间无法创建TLS，所以就有了隧道代理，它把浏览器的数据原样透传，这样就实现了通过中间代理和服务端进行 TLS 握手，然后进行加密传输 可能有人会问，那还要代理干嘛，直接请求服务器不是更好吗 代理服务器，到底有什么好处呢？ 突破访问限制：如访问一些单位或集团内部资源，或用国外代理服务器(翻墙)，就可以上国外网站看片等 安全性更高：上网者可以通过这种方式隐藏自己的 IP，免受攻击。还可以对数据过滤，对非法 IP 限流等 负载均衡：客户端请求先到代理服务器，而代理服务器后面有多少源服务器，IP 是多少，客户端是不知道的。因此，代理服务器收到请求后，通过特定的算法(随机算法、轮询、一致性 hash、LUR(最近最少使用) 算法这里不细说了)把请求分发给不同的源服务器，让各个源服务器负载尽量均衡 缓存代理：将内容缓存到代理服务器(这个下面一节详细说) 代理最常见的请求头Via 是一个能用首部，由代理服务器添加，适用于正向和反向代理，在请求和响应首部均可出现，这个消息首部可以用来追踪消息转发情况，防止循环请求，还可以识别在请求或响应传递链中消息发送者对于协议的支持能力，详情请看 MDN Via: 1.1 vegurVia: HTTP/1.1 GWAVia: 1.0 fred, 1.1 p.example.net X-Forwarded-For 记录客户端请求的来源 IP，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源 IP 追加进去 X-Forwarded-For: client,proxy1,proxy2 注意：与服务器直连的代理服务器的 IP 不会被追加进去，该代理可能过 TCP 连接的Remote Address字段获取到与服务器直连的代理服务器 IP X-Real-IP 一般记录真实发出请求的客户端的 IP，还有X-Forwarded-Host和X-Forwarded-Proto分别记录真实发出请求的客户端的域名和协议名 代理中客户端 IP 伪造问题以及如何预防？X-Forwarded-For是可以伪造的，比如一些通过 X-Forwarded-For 获取到客户端 IP 来限制刷票的系统就可以通过伪造该请求头达到刷票的目的，如果客户端请求显示指定了 X-Forwarded-For：192.168.1.108 那么服务端收到的这个请求头，第一个 IP 就是伪造的 预防 在对外 Nginx 服务器上配置 location / &#123; proxy_set_header X-Forwarded-For $remote_addr&#125; 这样第一个 IP 就是从TCP连接客户端的 IP，不会读取伪造的 从右到左遍历X-Forwarded-For的 IP，排除已知代理服务器 IP 和内网 IP，获取到第一个符合条件的 IP 就可以了 正向代理和反向代理正向代理工作在客户端的代理为正向代理。使用正向代理的时候，需要在客户端配置需要使用的代理服务器，正向代理对服务端透明。比如抓包工具 Fiddler、Charles 以及访问一些外网网站的代理工具都是正向代理 正向代理通常用于 缓存 屏蔽某些不健康的网站 通过代理访问原本无法访问的网站 上网认证，对用户访问进行授权 反向代理工作在服务端的代理称为反向代理。使用反向代理的时候，不需要在客户端进行设置，反向代理对客户端透明。如 Nginx 就是反向代理 反向代理通常用于：负载均衡、服务端缓存、流量隔离、日志、金丝雀发布 代理中的长连接在各个代理和服务器、客户端节点之间是一段一段的 TCP 连接，客户端通过代理访问目标服务器也叫逐段传输，用于逐段传输的请求头叫逐段传输头。 逐段传输头会在每一段传输的中间代理中处理掉，不会传给下一个代理 标准的逐段传输头有：Keep-Alive、Transfer-Encoding、TE、Connection、Trailer、Upgrade、Proxy-Authorization、Proxy-Authenticate。 Connection 头决定当前事务完成后是否关闭连接，如果该值为 keep-alive，则连接是持久连接不会关闭，使得对同一服务器的请求可以继续在该连接上完成 说一下 HTTP 缓存及缓存代理关于 http 缓存在上一篇文章里有了详细介绍 (建议收藏)为什么第二次打开页面快？五步吃透前端缓存，让页面飞起 缓存代理就是让代理服务器接管一部分的服务端的 http 缓存，客户端缓存过期之后就近到代理服务器的缓存中获取，代理缓存过期了才请求源服务器，这样流量大的时候能明显降低源服务器的压力 注意响应头字段 Cache-Control： 值有public时，表示可以被所有终端缓存，包括代理服务器、CDN。值有private时，只能被终端浏览器缓存，CDN、代理等中继服务器都不可以缓存。 HTTPSHTTPS 是超文本传输安全协议，即HTTP + SSL/TLS。说白了，就是一个加强版的 HTTP HTTP 本文开始讲了，所以我们要理解 HTTPS 的精华，就要先弄清楚这个SSL/TLS了 SSL/TLS一张图让你理解 SSL 和 TLS 的关系 如图，TLS 是 SSL 的升级版，而且 TLS1.2 版本以下都已废弃，目前主要用的是TLS 1.2和TLS 1.3。而OpenSSL则是开源版本的 那么它到底是个啥呢？ 浏览器和服务器通信之前会先协商，选出它们都支持的加密套件，用来实现安全的通信。常见加密套件 随便拿出一个加密套件举例，如：RSA-PSK-AES128-GCM-SHA256，就是长这样，代表什么意思呢，我们看图 **RSA**：表示握手时用 RSA 算法交换密钥 **PSK**：表示使用 PSK 算法签名 AES128-GCM**：表示使用 AES256 对称加密算法通信，密钥长度 128，分组模式 GCM。TLS 1.3 中只剩下称加密算法有AES和CHACHA20，分组模式只剩下GCM和POLY1305** SHA256**：表示使用 SHA256 算法验证信息完整性并生成随机数。TLS 1.3 中哈希摘要算法只剩下SHA256和SHA384**了 为什么需要用到这么多算法呢？ 为了保证安全，TLS 需要保证信息的：机密性、可用性、完整性、认证性、不可否认性，每一种算法都有其特定的用处 HTTPS 中 TLS 的加密算法为什么说 https 是安全的？ https 一定是安全的吗？（考察 https 中间人劫持，我另一篇有关于详细介绍网络安全） 有什么解决办法？ https 的证书校验过程是怎么样的？ 证书校验用到了哪些算法？ 对称加密算法 就是加密和解密使用同一个密钥。如AES、DES。加解密过程： 浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表 服务器给浏览器返回另一个随机数server-random和双方都支持的加密方法 然后两者用加密方法将两个随机数混合生成密钥，这就是通信双上加解密的密钥 问题是双方如何安全的传递两个随机数和加密方法，直接传给客户端，那过程中就很可能被窃取，别人就能成功解密拿到数据，往下看 不对称加密算法 就是一对密钥，有公钥(public key)和私钥(private key)，其中一个密钥加密后的数据，只能让另一个密钥进行解密。如RSA、ECDHE。加解密过程： 浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表 服务器把另一个随机数server-random、加密方法、公钥传给浏览器 然后浏览器用公钥将两个随机数加密，生成密钥，这个密钥只能用私钥解密 使用公钥反推出私钥是非常困难，但不是做不到，随着计算机运算能力提高，非对称密钥至少要2048位才能保证安全性，这就导致性能上要比对称加密要差很多 所以！ TLS 实际用的是两种算法的混合加密。通过 非对称加密算法 交换 对称加密算法 的密钥，交换完成后，再使用对称加密进行加解密传输数据。这样就保证了会话的机密性。过程如下 浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表 服务器把另一个随机数server-random、加密方法、公钥传给浏览器 浏览器又生成另一个随机数pre-random，并用公钥加密后传给服务器 服务器再用私钥解密，得到pre-random 浏览器和服务器都将三个随机数用加密方法混合生成最终密钥 这样即便被截持，中间人没有私钥就拿不到pre-random，就无法生成最终密钥。 可又有问题来了，如果一开始就被 DNS 截持，我们拿到的公钥是中间人的，而不是服务器的，数据还是会被窃取，所以数字证书来了，往下看，先简单说一下摘要算法 摘要算法 主要用于保证信息的完整性。常见的MD5 算法、散列函数、哈希函数都属于这类算法，其特点就是单向性、无法反推原文 假如信息被截取，并重新生成了摘要，这时候就判断不出来是否被篡改了，所以需要给摘要也通过会话密钥进行加密，这样就看不到明文信息，保证了安全性，同时也保证了完整性 如何保证数据不被篡改？签名原理和证书?数字证书(数字签名) 它可以帮我们验证服务器身份。因为如果没有验证的话，就可能被中间人劫持，假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器 这样不知不觉间信息就被人窃取了，所以在结合对称和非对称加密的基础上，又添加了数字证书认证的步骤，让服务器证明自己的身份 数字证书需要向有权威的认证机构(CA)获取授权给服务器。首先，服务器和CA机构分别有一对密钥(公钥和私钥)，然后是如何生成数字证书的呢？ CA 机构通过摘要算法生成服务器公钥的摘要(哈希摘要) CA 机构通过CA 私钥及特定的签名算法加密摘要，生成签名 把签名、服务器公钥等信息打包放入数字证书，并返回给服务器 服务器配置好证书，以后客户端连接服务器，都先把证书发给客户端验证并获取服务器的公钥。 证书验证流程： 使用CA 公钥和声明的签名算法对 CA 中的签名进行解密，得到服务器公钥的摘要内容 再用摘要算法对证书里的服务器公钥生成摘要，再把这个摘要和上一步得到的摘要对比，如果一致说明证书合法，里面的公钥也是正确的，否则就是非法的 证书认证又分为单向认证和双向认证 单向认证：服务器发送证书，客户端验证证书 双向认证：服务器和客户端分别提供证书给对方，并互相验证对方的证书 不过大多数 https 服务器都是单向认证，如果服务器需要验证客户端的身份，一般通过用户名、密码、手机验证码等之类的凭证来验证。只有更高级别的要求的系统，比如大额网银转账等，就会提供双向认证的场景，来确保对客户身份提供认证性 HTTPS 连接过程和优化我们知道了 https 就只是比 http 多了一步 TLS 连接 TLS 连接是怎么回事呢，根据 TLS 版本和密钥交换法不同，过程也不一样，有三种方式 RSA 握手早期的 TLS 密钥交换法都是使用 RSA 算法，它的握手流程是这样子的 浏览器给服务器发送一个随机数client-random和一个支持的加密方法列表 服务器把另一个随机数server-random、加密方法、公钥传给浏览器 浏览器又生成另一个随机数pre-random，并用公钥加密后传给服务器 服务器再用私钥解密，得到pre-random，此时浏览器和服务器都得到三个随机数了，各自将三个随机数用加密方法混合生成最终密钥 然后开始通信 TLS 1.2 版TLS 1.2版的用的是ECDHE密钥交换法，看图 浏览器给服务器发送一个随机数client-random、TLS 版本和一个支持的加密方法列表 服务器生成一个椭圆曲线参数server-params、随机数server-random、加密方法、证书等传给浏览器 浏览器又生成椭圆曲线参数client-params，握手数据摘要等信息传给服务器 服务器再返回摘要给浏览器确认应答 这个版本不再生成椭圆曲线参数cliend-params和server-params，而是在服务器和浏览器两边都得到server-params和client-params之后，就用 ECDHE 算法直接算出pre-random，这就两边都有了三个随机数，然后各自再将三个随机加密混合生成最终密钥 TLS 1.3 版在 TLS1.3 版本中废弃了 RSA 算法，因为 RSA 算法可能泄露私钥导致历史报文全部被破解，而 ECDHE 算法每次握手都会生成临时的密钥，所以就算私钥被破解，也只能破解一条报文，而不会对之前的历史信息产生影响，，所以在 TLS 1.3 中彻底取代了 RSA。目前主流都是用ECDHE算法来做密钥交换的 TLS1.3 版本中握手过程是这样子的 浏览器生成client-params、和client-random、TLS 版本和加密方法列表发送给服务器 服务器返回server-params、server-random、加密方法、证书、摘要等传给浏览器 浏览器确认应答，返回握手数据摘要等信息传给服务器 简单说就是简化了握手过程，只有三步，把原来的两个 RTT 打包成一个发送了，所以减少了传输次数。这种握手方式也叫1-RTT握手 这种握手方还有优化空间吗？ 有的，用会话复用 会话复用会话复用有两种方式：Session ID 和 Session Ticket **Session ID**：就是客户端和服务器首次连接手各自保存会话 ID，并存储会话密钥，下次再连接时，客户端发送 ID 过来，服务器这边再查找 ID，如果找到了就直接复用会话，密钥也不用重新生成 可是这样的话，在客户端数量庞大的时候，对服务器的存储压力可就大了 所以出来了第二种方式 **Session Ticket**：就是双方连接成功后服务器加密会话信息，用 Session Ticket 消息发给客户端存储起来，下次再连接时就把这个 Session Ticket 解密，验证有没有过期，如果没有过期就复用会话。原理就是把存储压力分给客户端。 这样就万无一失了吗？ No，这样也存在安全问题。因为每次要用一个固定的密钥来解密 Session Ticket，一旦密钥被窃取，那所有历史记录也就被破解了，所以只能尽量避免这种问题定期更换密钥。毕竟节省了不少生成会话密钥和这些算法的耗时，性能还是提升了嘛 那刚说了1-RTT，那能不能优化到0-RTT呢 还真可以，做法就是发送 Session Ticket 的时候带上应用数据，不用等服务端确认。这种方式被称为PSK(Pre-Shared Key) 这样万无一失了吗？ 尴了个尬，还是不行。这 PSK 要是被窃取，人家不断向服务器重发，就直接增加了服务器被攻击的风险 虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本 HTTPS 优缺点优点 内容加密，中间无法查看原始内容 身份认证，保证用户访问正确。如访问百度，即使 DNS 被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持 数据完整性，防止内容被第三方冒充或篡改 虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本 缺点 要钱，功能越强大的证书费用越贵 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名 https 双方加解密，耗费更多服务器资源 https 握手更耗时，降低一定用户访问速度(优化好就不是缺点了) HTTP 和 HTTPS 的区别 HTTP 是明文传输，不安全的，HTTPS 是加密传输，安全的多 HTTP 标准端口是80，HTTPS 标准端口是443 HTTP 不用认证证书免费，HTTPS 需要认证证书要钱 连接方式不同，HTTP 三次握手，HTTPS 中 TLS1.2 版本 7 次，TLS1.3 版本 6 次 HTTP 在 OSI 网络模型中是在应用层，而 HTTPS 的 TLS 是在传输层 HTTP 是无状态的，HTTPS 是有状态的 HTTPS 的性能优化访问速度优化 会话复用，上面说了，复用 session 可以减少 CPU 消耗，因为不需要进行非对称密钥交换的计算。可以提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。 使用 SPDY 或者 HTTP2。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。HTTP2 支持多路复用，有同样的效果。 设置HSTS，服务端返回一个 HSTS 的 http header，浏览器获取到 HSTS 头部之后，在一段时间内，不管用户输入www.baidu.com还是http://www.baidu.com ，都会默认将请求内部跳转成 https://www.baidu.com。Chrome, firefox, ie 都支持了 HSTS。 Nginx设置Ocsp stapling。Ocsp 全称在线证书状态检查协议 (rfc6960)，用来向 CA 站点查询证书状态，比如是否撤销。通常情况下，浏览器使用 OCSP 协议发起查询请求，CA 返回证书状态内容，然后浏览器接受证书是否可信的状态。这个过程非常消耗时间，因为 CA 站点有可能在国外，网络不稳定，RTT 也比较大。如果不需要查询则可节约时间。 False start。简单概括 False start 的原理就是在 clientkeyexchange 发出时将应用层数据一起发出来，能够节省一个 RTT。 计算性能优化 优先使用 ECC 椭圆加密算术 使用最新版的 OpenSSL TLS 远程代理计算 硬件加速方案 HTTP 版本1991 年 HTTP 0.9 版，只有一个 GET，而且只支持纯文本内容，早已过时就不讲了 HTTP 1.0(1996 年) 任意数据类型都可以发送 有 GET、POST、HEAD 三种方法 无法复用 TCP 连接(长连接) 有丰富的请求响应头信息。以 header 中的Last-Modified/If-Modified-Since和Expires作为缓存标识 HTTP 1.1(1997 年) 引入更多的请求方法类型PUT、PATCH、DELETE、OPTIONS、TRACE、CONNECT 引入长连接，就是 TCP 连接默认不关闭，可以被多个请求复用，通过请求头 connection:keep-alive 设置 引入管道连接机制，可以在同一 TCP 连接里，同时发送多个请求 强化了缓存管理和控制Cache-Control、ETag/If-None-Match 支持分块响应，断点续传，利于大文件传输，能过请求头中的Range实现 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 IP 地址 缺点：主要是连接缓慢，服务器只能按顺序响应，如果某个请求花了很长时间，就会出现请求队头阻塞 虽然出了很多优化技巧：为了增加并发请求，做域名拆分、资源合并、精灵图、资源预取…等等 最终为了推进从协议上进行优化，Google 跳出来，推出SPDY协议 SPDY(2009 年)SPDY（读作“SPeeDY”）是 Google 开发的基于 TCP 的会话层协议 主要通过帧、多路复用、请求优先级、HTTP 报头压缩、服务器推送以最小化网络延迟，提升网络速度，优化用户的网络使用体验 原理是在 SSL 层上增加一个 SPDY 会话层，以在一个 TCP 连接中实现并发流。通常的 HTTP GET 和 POST 格式仍然是一样的，然而 SPDY 为编码和传输数据设计了一个新的帧格式。因为流是双向的，所以可以在客户端和服务端启动 虽然诞生后很快被所有主流浏览器所采用，并且服务器和代理也提供了支持，但是 SPDY 核心人员后来都参加到 HTTP 2.0 开发中去了，自 HTTP2.0 开发完成就不再支持 SPDY 协议了，并在 Chrome 51 中删掉了 SPDY 的支持 HTTP 2.0(2015 年)说出 http2 中至少三个新特性？ 使用新的二进制协议，不再是纯文本，避免文本歧义，缩小了请求体积 多路复用，同域名下所有通信都是在单链接(双向数据流)完成，提高连接的复用率，在拥塞控制方面有更好的能力提升 使用HPACK算法将头部压缩，用哈夫曼编码建立索表，传送索引大大节约了带宽 允许服务端主动推送数据给客户端 增加了安全性，使用 HTTP 2.0，要求必须至少 TLS 1.2 使用虚拟的流传输消息，解决了应用层的队头阻塞问题 缺点 TCP 以及 TCP+TLS 建立连接的延时，HTTP2 使用 TCP 协议来传输的，而如果使用 HTTPS 的话，还需要 TLS 协议进行安全传输，而使用 TLS 也需要一个握手过程，在传输数据之前，导致我们花掉 3~4 个 RTT TCP 的队头阻塞并没有彻底解决。在 HTTP2 中，多个请求跑在一个 TCP 管道中，但当 HTTP2 出现丢包时，整个 TCP 都要开始等待重传，那么就会阻塞该 TCP 连接中的所有请求 SPDY 和 HTTP2 的区别 头部压缩算法，SPDY 是通用的deflate算法，HTTP2 是专门为压缩头部设计的HPACK算法 SPDY 必须在TLS上运行，HTTP2 可在TCP上直接使用，因为增加了 HTTP1.1 的 Upgrade 机制 SPDY 更加完善的协议商讨和确认流程 SPDY 更加完善的 Server Push 流程 SPDY 增加控制帧的种类，并对帧的格式考虑的更细致 HTTP1 和 HTTP2 HTTP2 是一个二进制协议，HTTP1 是超文本协议，传输的内容都不是一样的 HTTP2 报头压缩，可以使用 HPACK 进行头部压缩，HTTP1 则不论什么请求都会发送 HTTP2服务端推送(Server push)，允许服务器预先将网页所需要的资源 push 到浏览器的内存当中 HTTP2 遵循多路复用，代替同一域名下的内容，只建立一次连接，HTTP1.x 不是，对域名有 6~8 个连接限制 HTTP2 引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况，同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。HTTP2 对同一域名下所有请求都是基于流的，也就是说同一域名下不管访问多少文件，只建立一次连接 HTTP 3.0/QUIC由于 HTTP 2.0 依赖于 TCP，TCP 有什么问题那 HTTP2 就会有什么问题。最主要的还是队头阻塞，在应用层的问题解决了，可是在 TCP 协议层的队头阻塞还没有解决。 TCP 在丢包的时候会进行重传，前面有一个包没收到，就只能把后面的包放到缓冲区，应用层是无法取数据的，也就是说 HTTP2 的多路复用并行性对于 TCP 的丢失恢复机制不管用，因此丢失或重新排序的数据都会导致交互挂掉 为了解决这个问题，Google 又发明了QUIC协议 并在 2018 年 11 月将 QUIC 正式改名为HTTP 3.0 特点： 在传输层直接干掉 TCP，用UDP替代 实现了一套新的拥塞控制算法，彻底解决 TCP 中队头阻塞的问题 实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据。 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3 转载真！一文搞定 HTTP 和 HTTPS","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"}]},{"title":"vscode项目国际化插件","date":"2021-10-13T08:29:10.000Z","path":"2021/10/13/2021-10-13-vscode-i18n/","text":"背景：由于经常遇到需要国际化的项目，每次要了解字串是什么意思，都要去搜索对应的字串是什么意思，比较消耗时间 i18n-allysettings.json 中配置 &#123; // 资源文件路径 &quot;i18n-ally.localesPaths&quot;: [&quot;src/locale&quot;, &quot;src/common/lang&quot;], // 资源文件的文件种类，默认为json &quot;i18n-ally.enabledParsers&quot;: [&quot;js&quot;, &quot;ts&quot;], // 资源文件的文件名作为第一个key &quot;i18n-ally.namespace&quot;: true, // 资源的key &quot;i18n-ally.pathMatcher&quot;: &quot;&#123;namespaces&#125;/&#123;locale&#125;.js&quot;, // 默认展示语言 &quot;i18n-ally.displayLanguage&quot;: &quot;zh&quot;, // flat(&#123;&quot;a.b.c&quot;: &quot;...&quot;&#125;) or nested(&#123;&quot;a&quot;: &#123;&quot;b&quot;: &#123;&quot;c&quot;: &quot;...&quot;&#125;&#125;&#125;) &quot;i18n-ally.keystyle&quot;: &quot;nested&quot;&#125; 默认支持的框架包括 vue、angular、react 等原生的 i18n 工具 如果不在其中需要自定义 # 在哪些文件中显示翻译languageIds: - html - javascript - typescript - javascriptreact - typescriptreactusageMatchRegex: # The following example shows how to detect `t(&quot;your.i18n.keys&quot;)` # the `&#123;key&#125;` will be placed by a proper keypath matching regex, # you can ignore it and use your own matching rules as well - &quot;\\\\s?[&#x27;\\&quot;`](&#123;key&#125;)[&#x27;\\&quot;`]\\\\s?\\\\|\\\\s?i18n&quot; - &quot;[^\\\\w\\\\d]t\\\\([&#x27;\\&quot;`](&#123;key&#125;)[&#x27;\\&quot;`]&quot; - &quot;[^\\\\w\\\\d]transform\\\\([&#x27;\\&quot;`](&#123;key&#125;)[&#x27;\\&quot;`]&quot;monopoly: true i18n-ally 文档","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"vscode","slug":"vscode","permalink":"https://luckyship.github.io/tags/vscode/"}]},{"title":"css层叠上下文","date":"2021-10-12T03:06:48.000Z","path":"2021/10/12/2021-10-12-css-stacking-context/","text":"对于 css 的层叠顺序一直不是很清楚，使用 z-index 的时候有的时候不生效，为啥会产生这样的场景呢，css 的层叠顺序到底是怎样的 以往，由于自己使用 z-index 的频率不大，所以对这个 CSS 属性存在比较片面的认识。一直认为 z-index 就是用来描述定义一个元素在屏幕 Z 轴上的堆叠顺序。z-index 值越大在 Z 轴上就越靠上，也就是离屏幕观察者越近。最后才发现这个认识存在很大的问题： 首先，z-index 属性值并不是在任何元素上都有效果。它仅在定位元素（定义了 position 属性，且属性值为非 static 值的元素）上有效果。 判断元素在 Z 轴上的堆叠顺序，不仅仅是直接比较两个元素的 z-index 值的大小，这个堆叠顺序实际由元素的层叠上下文、层叠等级共同决定。 要想完全理解一个东西，首先要明白它是什么，也就是它的定义。我们先看看上面提到的层叠上下文、层叠等级、层叠顺序都是什么？定义又太过抽象，后面会再用一个具象的比喻来让你彻底明白它们到底是什么，有什么联系。 什么是层叠上下文层叠上下文(stacking context)，是 HTML 中一个三维的概念。在 CSS2.1 规范中，每个盒模型的位置是三维的，分别是平面画布上的X轴，Y 轴以及表示层叠的 Z 轴。一般情况下，元素在页面上沿X轴 Y 轴平铺，我们察觉不到它们在 Z 轴上的层叠关系。而一旦元素发生堆叠，这时就能发现某个元素可能覆盖了另一个元素或者被另一个元素覆盖。 如果一个元素含有层叠上下文，(也就是说它是层叠上下文元素)，我们可以理解为这个元素在 Z 轴上就“高人一等”，最终表现就是它离屏幕观察者更近。 具象的比喻：你可以把层叠上下文元素理解为理解为该元素当了官，而其他非层叠上下文元素则可以理解为普通群众。凡是“当了官的元素”就比普通元素等级要高，也就是说元素在 Z 轴上更靠上，更靠近观察者。 什么是“层叠等级”那么，层叠等级指的又是什么？层叠等级(stacking level，叫“层叠级别”/“层叠水平”也行) 在同一个层叠上下文中，它描述定义的是该层叠上下文中的层叠上下文元素在Z轴上的上下顺序。在其他普通元素中，它描述定义的是这些普通元素在Z轴上的上下顺序。说到这，可能很多人疑问了，不论在层叠上下文中还是在普通元素中，层叠等级都表示元素在Z轴上的上下顺序，那就直接说它描述定义了所有元素在Z轴上的上下顺序就 OK 啊！为什么要分开描述？ 为了说明原因，先举个栗子： 具象的比喻：我们之前说到，处于层叠上下文中的元素，就像是元素当了官，等级自然比普通元素高。再想象一下，假设一个官员 A 是个省级领导，他下属有一个秘书 a-1，家里有一个保姆 a-2。另一个官员 B 是一个县级领导，他下属有一个秘书 b-1，家里有一个保姆 b-2。a-1 和 b-1 虽然都是秘书，但是你想一个省级领导的秘书和一个县级领导的秘书之间有可比性么？甚至保姆 a-2 都要比秘书 b-1 的等级高得多。谁大谁小，谁高谁低一目了然，所以根本没有比较的意义。只有在 A 下属的 a-1、a-2 以及 B 下属的 b-1、b-2 中相互比较大小高低才有意义 再类比回“层叠上下文”和“层叠等级”，就得出一个结论： 普通元素的层叠等级优先由其所在的层叠上下文决定。 层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。 如何产生“层叠上下文”前面说了那么多，知道了“层叠上下文”和“层叠等级”，其中还有一个最关键的问题：到底如何产生层叠上下文呢？如何让一个元素变成层叠上下文元素呢？ 其实，层叠上下文也基本上是有一些特定的 CSS 属性创建的，一般有 3 种方法： HTML 中的根元素&lt;html&gt;&lt;/html&gt;本身 j 就具有层叠上下文，称为“根层叠上下文”。 普通元素设置 position 属性为非 static 值并设置 z-index 属性为具体数值，产生层叠上下文。 CSS3 中的新属性也可以产生层叠上下文。 什么是“层叠顺序”说完“层叠上下文”和“层叠等级”，我们再来说说“层叠顺序”。“层叠顺序”(stacking order)表示元素发生层叠时按照特定的顺序规则在 Z 轴上垂直显示。由此可见，前面所说的“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则。 上图的代码 &lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt; &lt;title&gt;JS Bin&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;style type=&quot;text/css&quot;&gt; .z-index div &#123; width: 200px; height: 100px; color: white; border: 1px solid white; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;z-index&quot;&gt; &lt;div id=&quot;background&quot; style=&quot;background-color:violet; transform: translate(0px, 0px);&quot;&gt; &lt;span style=&quot;position: absolute;&quot;&gt;层叠上下文background/border&lt;/span&gt; &lt;div style=&quot;background-color:blueviolet; z-index: -1; margin-left: 50px; margin-top: 50px;&quot;&gt;负index&lt;/div&gt; &lt;div style=&quot;background-color:steelblue; margin: -50px 0 0 100px;&quot;&gt;block块状盒子&lt;/div&gt; &lt;div style=&quot;background-color:springgreen; float: left; margin: -50px 0 -50px 150px&quot;&gt;float浮动盒子&lt;/div&gt; &lt;div style=&quot;background-color:greenyellow; display: inline-block; margin: -50px 0 0 200px;&quot;&gt; inline/inline-block盒子 &lt;/div&gt; &lt;div style=&quot;background-color:orange; position: relative; z-index: auto; margin: -50px 0 0 250px;&quot;&gt; z-index:auto/z-index:0 &lt;/div&gt; &lt;div style=&quot;background-color:red; position: relative; z-index: 1; margin: -50px 0 0 300px;&quot;&gt;正z-index&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/body&gt;&lt;/html&gt; 在不考虑 CSS3 的情况下，当元素发生层叠时，层叠顺讯遵循上面途中的规则。 这里值得注意的是： 左上角”层叠上下文 background/border“指的是层叠上下文元素的背景和边框。 inline/inline-block 元素的层叠顺序要高于 block(块级)/float(浮动)元素。 单纯考虑层叠顺序，z-index: auto 和 z-index: 0 在同一层级，但这两个属性值本身是有根本区别的。 判断方法 1、首先先看要比较的两个元素是否处于同一个层叠上下文中： 1.1 如果是，谁的层叠等级大，谁在上面（怎么判断层叠等级大小呢？——看“层叠顺序”图）。 1.2 如果两个元素不在统一层叠上下文中，请先比较他们所处的层叠上下文的层叠等级。 2、当两个元素层叠等级相同、层叠顺序相同时，在 DOM 结构中后面的元素层叠等级在前面元素之上。 实例&lt;style type=&quot;text/css&quot;&gt; div &#123; width: 200px; height: 100px; color: white; border: 1px solid white; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;box1&quot; style=&quot;position: relative; z-index: auto;&quot;&gt; &lt;div class=&quot;child1&quot; style=&quot;background-color:red; position: relative; z-index: 2;&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;box2&quot; style=&quot;position: relative; z-index: auto;&quot;&gt; &lt;div class=&quot;child2&quot; style=&quot;background-color:blue; position: relative; z-index: 1; margin: -50px 0 0 50px;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; .box1/.box2虽然设置了 position: relative，但是 z-index: auto 的情况下，这两个 div 还是普通元素，并没有产生层叠上下文。所以，child1/.child2 属于&lt;html&gt;&lt;/html&gt;元素的“根层叠上下文”中，此时，谁的 z-index 值大，谁在上面。 对于上面中的 CSS 代码，我们只把.box1/.box2 的 z-index 属性值改为数值 0，其余不变。 &lt;div class=&quot;box1&quot; style=&quot;position: relative; z-index: 0;&quot;&gt; &lt;div class=&quot;child1&quot; style=&quot;background-color:red; position: relative; z-index: 2;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;box2&quot; style=&quot;position: relative; z-index: 0;&quot;&gt; &lt;div class=&quot;child2&quot; style=&quot;background-color:blue; position: relative; z-index: 1; margin: -50px 0 0 50px;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 此时，我们发现，仅仅修改了.box1/.box2的 z-index 属性值改为数值 0，最终结果完全相反。这时.child2 覆盖在了.child1 上面。原因是什么呢？很简单：因为设置 z-index: 0 后，.box1/.box2产生了各自的层叠上下文，这时候要比较.child1/.child2 的层叠关系完全由父元素.box1/.box2的层叠关系决定。但是.box1/.box2的 z-index 值都为 0，都是块级元素（所以它们的层叠等级，层叠顺序是相同的），这种情况下，在 DOM 结构中后面的覆盖前面的，所以.child2 就在上面。 CSS3 中的属性对层叠上下文的影响 CSS3 中出现了很多新属性，其中一些属性对层叠上下文也产生了很大的影响。如下： 父元素的 display 属性值为 flex|inline-flex，子元素 z-index 属性值不为 auto 的时候，子元素为层叠上下文元素； 元素的 opacity 属性值不是 1； 元素的 transform 属性值不是 none； 元素 mix-blend-mode 属性值不是 normal； 元素的 filter 属性值不是 none； 元素的 isolation 属性值是 isolate； will-change 指定的属性值为上面任意一个； 元素的-webkit-overflow-scrolling 属性值设置为 touch。 CSS3 中，元素属性满足以上条件之一，就会产生层叠上下文。我们用第 1 条来做一个简单的解释说明。 &lt;style type=&quot;text/css&quot;&gt; div &#123; width: 200px; height: 100px; color: white; border: 1px solid white; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;parent&quot; style=&quot;background-color:blue;&quot;&gt; &lt;div class=&quot;child&quot; style=&quot;background-color:red; position: relative; z-index: -1; margin: 50px 0 0 50px;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们发现，.child 被.parent 覆盖了。分析一下： 虽然.parent 设置了 z-index 属性值，但是没有设置 position 属性，z-index 无效，所以没有产生层叠上下文，.parent 还是普通的块级元素。此时，在层叠顺序规则中，z-index 值小于 0 的.child 会被普通的 block 块级元素.parent 覆盖。 对于上面的栗子，我们只修改 body 的属性，设置 display: flex，其余属性和 DOM 结构不变。 当给 body 设置 display: flex 时，.parent 就变成层叠上下文元素，根据层叠顺序规则，层叠上下文元素的 background/border 的层叠等级小于 z-index 值小于 0 的元素的层叠等级，所以 z-index 值为-1 的.child 在.parent 上面。 这里注意，背景background/border和.child元素处在同一个层叠上下文（.parent）下，所以才会比较他们的层叠顺序 或者直接在 .parent 上增加 css 属性 transform: translate(0, 0)，也可以达到同样的效果 参考彻底搞懂 CSS 层叠上下文、层叠等级、层叠顺序、z-index深入理解 CSS 中的层叠上下文和层叠顺序","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"前端3大框架原理比较分析","date":"2021-09-20T02:35:14.000Z","path":"2021/09/20/2021-09-20-web-framed-diff/","text":"首先了解一下浏览器的渲染原理《How Browsers Work》译文由于最近在探索框架性能，各框架的正确使用场景，对框架的数据绑定原理做了如下的总结： 1、AngularAngular 的数据观测采用的是脏检查（dirty checking）机制。每一个指令都会有一个对应的用来观测数据的对象，叫做 watcher；一个作用域中会有很多个 watcher。每当界面需要更新时，Angular 会遍历当前作用域里的所有 watcher，对它们一一求值，然后和之前保存的旧值进行比较。如果求值的结果变化了，就触发对应的更新，这个过程叫做 digest cycle。脏检查有两个问题： 1）任何数据变动都意味着当前作用域的每一个 watcher 需要被重新求值，因此当 watcher 的数量庞大时，应用的性能就不可避免地受到影响，并且很难优化；2）当数据变动时，框架并不能主动侦测到变化的发生，需要手动触发 digest cycle 才能触发相应的 DOM 更新。Angular 通过在 DOM 事件处理函数中自动触发 digest cycle 部分规避了这个问题，但还是有很多情况需要用户手动进行触发。脏检查即一种不关心你如何以及何时改变的数据，只关心在特定的检查阶段数据是否改变的数据监听技术。而常规的 set, get 的方式则会强加许多限制；脏检查可以实现批处理完数据之后，再去统一更新 view；脏检查其实比 GET/SET 更容易实现。脏检查是个单向的检查流程(请不要和双向绑定发生混淆)，可以实现_任意复杂度的表达式支持。而 get/ set 的方式则需要处理复杂依赖链，基本上表达式支持都是阉割的. 很显然，脏检查是低效的，它的效率基本上取决于你绑定的观察者数量。然而结合这种类 mvvm 系统中，他又是高效的。因为监听模式带来了 dom 的局部更新，而 dom 操作恰恰又是隐藏的性能瓶颈所在。 2、VueJS 将原生的数据改造成 “可观察对象”。一个可观察对象可以被取值，也可以被赋值, 在 watcher 的求值过程中，每一个被取值的可观察对象都会将当前的 watcher 注册为自己的一个订阅者，并成为当前 watcher 的一个依赖。 当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的 watcher 重新求值，并触发相应的更新。依赖收集的优点在于可以精确、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如 Knockout，通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数调用的形式，在进行数据操作时写法繁琐，不够直观；同时，对复杂嵌套结构的对象支持也不理想。Vue.js 利用了 ES5 的 Object.defineProperty 方法，直接将原生数据对象的属性改造为 getter 和 setter，在这两个函数内部实现依赖的收集和触发，而且完美支持嵌套的对象结构。对于数组，则通过包裹数组的可变方法（比如 push）来监听数组的变化。这使得操作 Vue. js 的数据和操作原生对象几乎没有差别[注:在添加/删除属性，或是修改数组特定位置元素时，需要调用特定的函数，如 obj.$add(key, value) 才能触发更新。这是受 ES5 的语言特性所限。]，数据操作的逻辑更为清晰流畅，和第三方数据同步方案的整合也更为方便。异步批量 DOM 更新：当大量数据变动时，所有受到影响的 watcher 会被推送到一个队列中，并且每个 watcher 只会推进队列一次。这个队列会在进程 的下一个 “tick” 异步执行。这个机制可以避免同一个数据多次变动产生的多余 DOM 操作，也可以保证所有的 DOM 写操作在一起执行，避免 DOM 读写切换可能导致的 layout。 动画系统：Vue.js 提供了简单却强大的动画系统，当一个元素的可见性变化时，用户不仅可以很简单地定义对应的 CSS Transition 或 Animation 效果，还可以利用丰富的 JavaScript 钩子函数进行更底层的动画处理。 可扩展性：除了自定义指令、过滤器和组件，Vue.js 还提供了灵活的 mixin 机制，让用户可以在多个组件中复用共同的特性。 在大型的应用中，为了分工、复用和可维护性，我们不可避免地需要将应用抽象为多个相对独立的模块。在较为传统的开发模式中，我们只有在考虑复用时才会将某一部分做成组件；但实际上，应用类 UI 完全可以看作是全部由组件树构成的 3、ReactJS Web 界面由 DOM 树来构成，当其中某一部分发生变化时，其实就是对应的某个 DOM 节点发生了变化。在 React 中，构建 UI 界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由 React 来比较两个界面的区别，这就需要对 DOM 树进行 Diff 算法分析。 即给定任意两棵树，找到最少的转换步骤。但是标准的 Diff 算法复杂度需要 O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而 Facebook 工程师却做到了，他们结合 Web 界面的特点做出了两个简单的假设，使得 Diff 算法复杂度直接降低到 O(n)，两个相同组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构； 算法上的优化是 React 整个界面 Render 的基础，事实也证明这两个假设是合理而精确的，保证了整体界面构建的性能，对于同一层次的一组子节点，它们可以通过唯一的 id 进行区分。 React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。 我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗： innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size) Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change) Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 总结： Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求，性能比较也要看场合 在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。 初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化 .","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"},{"name":"react","slug":"react","permalink":"https://luckyship.github.io/tags/react/"}]},{"title":"Vue你了解哪些","date":"2021-09-12T08:26:18.000Z","path":"2021/09/12/2021-09-12-vue-knowledge/","text":"一、vuevue 优点 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb； 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习； 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单； 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势； 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作； 虚拟 DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式； 运行速度更快:相比较与 react 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势。 谈谈对 vue 渐进式的理解 什么是 MVVM？MVVM 是是 Model-View-ViewModel 的缩写，Model 代表数据模型，定义数据操作的业务逻辑，View 代表视图层，负责将数据模型渲染到页面上，ViewModel 通过双向绑定把 View 和 Model 进行同步交互，不需要手动操作 DOM 的一种设计思想。 MVVM 和 MVC 区别？和其他框架(jquery)区别？那些场景适用？MVVM 和 MVC 都是一种设计思想，主要就是 MVC 中的 Controller 演变成 ViewModel,，MVVM 主要通过数据来显示视图层而不是操作节点，解决了 MVC 中大量的 DOM 操作使页面渲染性能降低，加载速度慢，影响用户体验问题。主要用于数据操作比较多的场景。场景：数据操作比较多的场景，更加便捷 v-show 和 v-if 指令的共同点和不同点? v-show 指令是通过修改元素的 displayCSS 属性让其显示或者隐藏。 【CSS 控制节点是否显示，节点一直存在】 v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果。 【DOM 节点是否存在】 使用场景：需要反复展示就用v-show，如果一次决定不同模板内容就用v-if vue 中 key 值的作用当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key 的作用主要是为了高效的更新虚拟 DOM 【防止采用就地复用策略进行改变】 如何在组件内部实现一个双向数据绑定？ 该题目又可能称之为 ：如何在组件上面使用 v-model 考察组件的 v-model 文档地址： https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model https://cn.vuejs.org/v2/guide/components.html#%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-v-model import Vue from &#x27;vue&#x27;;const component = &#123; props: [&#x27;value&#x27;], // 默认props接收value属性 template: ``, data() &#123; return &#123;&#125;; &#125;, methods: &#123; handleInput(e) &#123; this.$emit(&#x27;input&#x27;, e.target.value); // 默认触发自定义事件input &#125;, &#125;,&#125;;new Vue(&#123; components: &#123; CompOne: component, &#125;, el: &#x27;#root&#x27;, template: ``, data() &#123; return &#123; value: &#x27;123&#x27;, &#125;; &#125;,&#125;); 常用指令 v-model 双向数据绑定，一般用于表单元素。 v-for 对数组或对象进行循环操作，使用是 v-for 不是 v-repeat v-on 用来绑定事件，用法：v-on:事件 = ‘函数’ v-show/v-if 用来显示或隐藏元素，v-show 是通过 display 实现，v-if 是每次删除后在创建 v-bind 属性绑定 v-html 渲染文档，可以编译 HTML 字符串 v-text 渲染文本，不可以编译 HTML 字符串 computed 和 method 区别 computed 依赖于缓存，依赖的变量变化了才会变化，模板变化了，即使依赖变量没有变化也不会重新计算； method 是事件，method 里面的事件每次都会执行，只要模板更新都会再次执行。 什么是 vue 的单向数据流 文档地址：https://cn.vuejs.org/v2/guide/components-props.html#%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81 vue 的单向数据流指的是 vue 组件通信里面父子通信是自上而下的，我们不能直接修改 props 里面属性。 vue 里面如何操作样式 操作 style 对象语法 :style=&quot;&#123;CSS属性名:变量&#125;&quot; 数组语法 :style=&quot;[样式描述变量1，样式描述变量2]&quot; 直接字符串 style=&#39;css属性名:css属性值;css属性名2:css属性值2;...&#39; 操作 class 对象语法 :class=&quot;&#123;class名:布尔变量&#125;&quot; 数组语法 :class=&quot;[变量1,变量2,...]&quot; 三木语法： :class = &quot;条件 ? &#39;class名1&#39;:&#39;class名2&#39;&quot; v-if 和 v-for 为什么不推荐一起用当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 所以会导致每个列表项渲染的时候都会进行条件判断，从而让性能比较低。 数组更新检测有哪些方法 变更方法 【修改原数组】 Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括： push();pop();shift();unshift();splice();sort();reverse(); 替换数组 变更方法，顾名思义，会变更调用了这些方法的原始数组。相比之下，也有非变更方法，例如 filter()、concat() 和 slice()。它们不会变更原始数组，而总是返回一个新数组。 如果获取事件对象 在书写事件函数的时候直接写上形参就表示事件对象 methods:&#123; fn(ev)&#123; // ev就是事件对象 &#125;&#125; 如果既要传参又要获取事件对象，那么传入实参的时候传入一个$event表示事件对象，$event这个单词不能写错 &lt;button @click=&quot;run(10,$event)&quot;&gt;点击&lt;/button&gt;&lt;script&gt; methods:&#123; run(num,ev)&#123; // 形参实参一一对应，ev和$event对应所以 就是事件对象 &#125; &#125;&lt;/script&gt; 哪些常见事件修饰符，有何作用 .stop 阻止冒泡 .prevent 阻止默认行为 .capture 捕获阶段触发 .self 自己本身上面触发 .once 一次性绑定 .passive 一般给 scroll 或者 resize 事件绑定，等到调整完成之后触发。 有哪些常见按键修饰符，以及如何定义按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 所有字母都也是按键修饰符 自定义按键修饰符：Vue.config.keyCodes.按键修饰符名 = 按键码 如何实现一个 v-model 指令 v-model 其实是 属性绑定和事件综合使用的语法糖。 &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=&quot;msg=$event.target.value&quot; /&gt;// 先给输入框的value绑定变量，这叫做属性绑定// 再给输入框绑定input事件，一旦输入，就将输入框的值赋给msg变量，从而实现双向绑定 表单控件绑定需要什么？ 给一组单选控件绑定给同一个变量，且每个单选控件都要有个一个 value 给一组多选控件绑定同一个变量，且这个变量是一个数组，且每个多选项都要有一个 value 如果 input 的 type 为 checkbox，我们用来做勾选的时候， 应该绑定一个布尔值类型的变量 textarea 绑定数据，同样应该使用 v-model 直接给到标签，而不是插值表达式 有哪些常见的表单修饰符 .lazy 在“change”时而非“input”时更新 .number 将用户的输入值转为数值类型 .trim 自动过滤用户输入的首尾空白字符 如何定义一个组件 全局注册 Vue.component(组件名, &#123; 组件配置选项 &#125;); 局部注册 // 组件或者vue实例的配置选项里面增加components属性。&#123; ..., components:&#123; 组件名:&#123; 组件配置对象 &#125; &#125;&#125; 组件 data 为啥是一个函数因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。 简而言之：组件的数据应该是各自独立的，互不干扰，所以 data 是函数返回一个对象，这样各自就独立了。 组件的 props 是什么？如何定义 props 是组件向外提供的一个接口，用来接收外部数据，也是父组件传递给子组件的主要方式 如何定义 // 方式1： 数组语法props:[&#x27;自定义属性名1&#x27;,&#x27;自定义属性名2&#x27;,...]// 方式2： 对象语法props:&#123; 自定义属性名1:&#123; type:类型 或 [类型1，类型2,...], // 类型有 Object,Array,String,Boolean,Number,Date,Function ， default:默认值， // 基本数据类型 default()&#123; // 如果props的值是引用数据类型，那么设置默认值的时候应该是一个函数，返回数组或对象 return []/&#123;&#125; &#125;, required:true/false, validator:function(val)&#123; // val就是该属性对应的值，用于内部做判断使用 return true/false // true表示验证通过，false表示验证不通过，控制台会有警告 &#125; &#125;&#125; 如何自定义组件的 v-model一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件，但是像单选框、复选框等类型的输入控件可能会将 value attribute 用于不同的目的。model 选项可以用来避免这样的冲突： Vue.component(&#x27;base-checkbox&#x27;, &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27;, &#125;, props: &#123; checked: Boolean, &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot; &gt; `,&#125;); 现在在这个组件上使用 v-model 的时候： &lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt; 这里的 lovingVue 的值将会传入这个名为 checked 的 prop。同时当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新的值的时候，这个 lovingVue 的 property 将会被更新。 注意你仍然需要在组件的 props 选项里声明 checked 这个 prop。 .native修饰符有何用 当我们给组件绑定原生事件无效的时候，可以加上.native修饰符就可以让组件上面的原生事件有效。 .sync修饰符有何作用.sync的用法如下： &lt;组件 :属性名.sync=&quot;变量&quot; /&gt; 其实他本质是一个语法糖： &lt;组件 :属性名=&quot;变量&quot; @update:属性名 = &quot;变量=$event&quot; /&gt; 其实是 v-model 的另外一种使用展示。 这也是为什么我们推荐以 update:myPropName 的模式触发事件取而代之。举个例子，在一个包含 title prop 的假设的组件中，我们可以用以下方法表达对其赋新值的意图： this.$emit(&#x27;update:title&#x27;, newTitle) 然后父组件可以监听那个事件并根据需要更新一个本地的数据 property。例如： &lt;text-document v-bind:title=&quot;doc.title&quot; v-on:update:title=&quot;doc.title = $event&quot;&gt;&lt;/text-document&gt; 为了方便起见，我们为这种模式提供一个缩写，即 .sync 修饰符： &lt;text-document v-bind:title.sync=&quot;doc.title&quot;&gt;&lt;/text-document&gt; 注意带有 .sync 修饰符的 v-bind **不能和表达式一起使用** 插槽是什么？ 有哪些分类？ 插槽是用来自定义组件内部模板内容的一种方式； 分类： 默认插槽 具名插槽 作用域插槽 写一个具名插槽方式 1：(老写法) &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template slot=&quot;名称&quot;&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt;&lt;!--组件内部--&gt;&lt;slot name=&quot;名称&quot;&gt;&lt;/slot&gt; 方式 2： &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template v-slot:名称&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt;&lt;!--组件内部--&gt;&lt;slot name=&quot;名称&quot;&gt;&lt;/slot&gt; 方式 3：其实是方式 2 的简写 &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template #名称&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt;&lt;!--组件内部--&gt;&lt;slot name=&quot;名称&quot;&gt;&lt;/slot&gt; 作用域插槽如何写方式 1：(老写法) &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template slot=&quot;名称&quot; slot-scope=&quot;作用域名&quot;&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt; 方式 2： &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template v-slot:名称=&quot;作用域名&quot;&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt; 方式 3：其实是方式 2 的简写 &lt;!--组件外部--&gt;&lt;组件名&gt; &lt;template #名称=&quot;作用域名&quot;&gt; 自定义HTML内容 &lt;/template&gt;&lt;/组件名&gt; 如何实现动态组件&lt;component :is=&quot;变量&quot;&gt;&lt;/component&gt;&lt;!--变量的值就是组件名，这里就会展示什么组件--&gt; 如何实现缓存组件&lt;keep-alive&gt; &lt;组件名&gt;&lt;/组件名&gt;&lt;/keep-alive&gt; 缓存组件要注意什么？ 缓存组件抱起来的组件将会被缓存，下一次打开的时候不会被再次创建（所以前四个生命周期不会再次被创建），所以我们不能把组件一打开就要做的放在 created 或 mounted 里面，因为组件不会再次创建。我们需要放在activated钩子里面。具体可参见文档：https://cn.vuejs.org/v2/api/#activated 如何定义一个递归组件 所谓的递归组件就是内部不断调用自己，在我们的树形结构中非常常见，如无限极分类；无限极菜单都常用； 递归组件最核心的就是组件一定要定义好 name 名次，否则无法起作用。 递归组件一定要有不成立的时候，否则无限递归，就会出错。 - 数据如下 var data = [ &#123; id: &#x27;1&#x27;, data: &#123; menuName: &#x27;项目管理&#x27;, menuCode: &#x27;&#x27;, &#125;, childTreeNode: [ &#123; data: &#123; menuName: &#x27;项目&#x27;, menuCode: &#x27;BusProject&#x27;, &#125;, childTreeNode: [], &#125;, &#123; data: &#123; menuName: &#x27;我的任务&#x27;, menuCode: &#x27;BusProject&#x27;, &#125;, childTreeNode: [], &#125;, &#123; data: &#123; menuName: &#x27;人员周报&#x27;, menuCode: &#x27;BusProject&#x27;, &#125;, childTreeNode: [], &#125;, ], &#125;, &#123; id: &#x27;2&#x27;, data: &#123; menuName: &#x27;数据统计&#x27;, menuCode: &#x27;BusClock&#x27;, &#125;, childTreeNode: [], &#125;, &#123; id: &#x27;3&#x27;, data: &#123; menuName: &#x27;人事管理&#x27;, menuCode: &#x27;&#x27;, &#125;, childTreeNode: [], &#125;, &#123; id: &#x27;4&#x27;, data: &#123; menuName: &#x27;基础管理&#x27;, menuCode: &#x27;&#x27;, &#125;, childTreeNode: [], &#125;,]; 递归组件 &lt;!-- 父组件中引入items --&gt;&lt;items :model=&quot;model&quot; v-for=&quot;model in data&quot;&gt;&lt;/items&gt;&lt;template&gt; &lt;li&gt; &lt;div @click=&quot;toggle&quot;&gt; &lt;i v-if=&quot;isFolder&quot; class=&quot;fa &quot; :class=&quot;[open ? &#x27;fa-folder-open&#x27; : &#x27;fa-folder&#x27;]&quot;&gt;&lt;/i&gt; &lt;!--isFolder判断是否存在子级改变图标--&gt; &lt;i v-if=&quot;!isFolder&quot; class=&quot;fa fa-file-text&quot;&gt;&lt;/i&gt; &#123;&#123; model.data.menuName &#125;&#125; &lt;/div&gt; &lt;ul v-show=&quot;open&quot; v-if=&quot;isFolder&quot;&gt; &lt;items v-for=&quot;cel in model.childTreeNode&quot; :model=&quot;cel&quot;&gt;&lt;/items&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/template&gt;&lt;script type=&quot;text/javascript&quot;&gt; export default &#123; name: &#x27;items&#x27;, props: [&#x27;model&#x27;], components: &#123;&#125;, data() &#123; return &#123; open: false, isFolder: true, &#125;; &#125;, computed: &#123; isFolder: function () &#123; return this.model.childTreeNode &amp;&amp; this.model.childTreeNode.length; &#125;, &#125;, methods: &#123; toggle: function () &#123; if (this.isFolder) &#123; this.open = !this.open; &#125; &#125;, &#125;, &#125;;&lt;/script&gt; vue 如何强制刷新组件1.使用 this.$forceUpdate 强制重新渲染 如果要在组件内部中进行强制刷新，则可以调用**this.$forceUpdate()**强制重新渲染组件，从而达到更新目的。 &lt;template&gt;&lt;button @click=&quot;reload()&quot;&gt;刷新当前组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;comp&#x27;, methods: &#123; reload() &#123; this.$forceUpdate() &#125; &#125;&#125;&lt;/script&gt; 2.使用 v-if 指令 如果是刷新某个子组件，则可以通过 v-if 指令实现。我们知道，当 v-if 的值发生变化时，组件都会被重新渲染一遍。因此，利用 v-if 指令的特性，可以达到强制刷新组件的目的。 &lt;template&gt; &lt;comp v-if=&quot;update&quot;&gt;&lt;/comp&gt; &lt;button @click=&quot;reload()&quot;&gt;刷新comp组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt; import comp from &#x27;@/views/comp.vue&#x27;; export default &#123; name: &#x27;parentComp&#x27;, data() &#123; return &#123; update: true, &#125;; &#125;, methods: &#123; reload() &#123; // 移除组件 this.update = false; // 在组件移除后，重新渲染组件 // this.$nextTick可实现在DOM 状态更新后，执行传入的方法。 this.$nextTick(() =&gt; &#123; this.update = true; &#125;); &#125;, &#125;, &#125;;&lt;/script&gt; 什么时候使用 vue 动画 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 vue 动画有哪些类名 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 有哪些自定义过渡类名 enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) vue 中 mixins 配置选项是什么？有何作用 mixins 是混入，用于实现复用组件所需要的配置选项，可以实现很多功能的复用。 文档地址：https://cn.vuejs.org/v2/guide/mixins.html 使用： // 定义一个混入对象var myMixin = &#123; created: function () &#123; this.hello(); &#125;, methods: &#123; hello: function () &#123; console.log(&#x27;hello from mixin!&#x27;); &#125;, &#125;,&#125;;// 定义一个使用混入对象的组件var Component = Vue.extend(&#123; mixins: [myMixin],&#125;); mixin 混入对象和 Vuex 的区别： Vuex 是状态共享管理，所以 Vuex 中的所有变量和方法都是可以读取和更改并相互影响的； mixin 可以定义公用的变量或方法，但是 mixin 中的数据是不共享的，也就是每个组件中的 mixin 实例都是不一样的，都是单独存在的个体，不存在相互影响的； mixin 混入对象值为函数的同名函数选项将会进行递归合并为数组，两个函数都会执行，只不过先执行 mixin 中的同名函数；（生命周期钩子函数、methods 等） mixin 混入对象值为对象的同名对象将会进行替换，都优先执行组件内的同名对象，也就是组件内的同名对象将 mixin 混入对象的同名对象进行覆盖；(watch、methods 中定义的方法等) 如何实现一个自定义指令// 全局注册指令Vue.directive(&#x27;指令名&#x27;, &#123; 配置选项,&#125;);// 局部注册&#123; directives: &#123; 指令名: &#123; 配置选项; &#125; &#125;&#125; 自定义指令有何作用？ 有哪些钩子 作用：当我们希望对原生的 DOM 节点，或者组件 都做 某一类型的操作的时候（如：页面已进入输入框就获取焦点；如输入框一旦加上某个指令就可以实现自动验证），我们就可以用自定义指令来开发我们想要的功能。 钩子： bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前我们会在稍后讨论渲染函数时介绍更多 VNodes 的细节。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。 指令钩子函数会被传入以下参数： el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。 过滤器是什么？如何定义？如何使用？ 是什么： 是对模板里面的数据进行某一类的操作，可以理解为模板的工具函数（如：直接在模板里面使用定义好的过滤器实现时间戳变格式化的时间；价格保留小数位等等处理） 如何定义： // 全局注册Vue.filter(&#x27;过滤器名&#x27;,(val,形参)=&gt;&#123; // val表示传入的值， 第二个参数开始才是传入的实参 这个函数一定要有返回值 // 处理 return 结果&#125;)// 局部注册&#123; filters:&#123; 过滤器名(val,形参)&#123; return 结果 &#125;, 过滤器名2(val,形参)&#123; return 结果 &#125;, ... &#125;&#125; 如何使用： &#123;&#123; 变量 | 过滤器 &#125;&#125; // 单个使用&#123;&#123; 变量 | 过滤器1 | 过滤器2 | ... &#125;&#125; // 串联使用，下一个过滤器函数接收的是上一个过滤器处理的结果&#123;&#123; 变量 | 过滤器(实参) &#125;&#125; // 过滤器传参 Vue.use 是什么? 如何使用？ 是什么： vue.use 是 vue 的插件安装函数。调用 use 我们可以安装很多第三方的插件，如 vue-router,vuex, element-ui,vant 等等，当然最重要的是可以安装我们自己开发的插件。 开发插件 Vue.js 的插件应该暴露一个 install 方法。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： MyPlugin.install = function (Vue, options) &#123; // 1. 添加全局方法或 property Vue.myGlobalMethod = function () &#123; // 逻辑... &#125; // 2. 添加全局资源 Vue.directive(&#x27;my-directive&#x27;, &#123; bind (el, binding, vnode, oldVnode) &#123; // 逻辑... &#125; ... &#125;) // 3. 注入组件选项 Vue.mixin(&#123; created: function () &#123; // 逻辑... &#125; ... &#125;) // 4. 添加实例方法 Vue.prototype.$myMethod = function (methodOptions) &#123; // 逻辑... &#125;&#125; 使用插件 Vue.use(MyPlugin, &#123; someOption: true &#125;); vue-loader 是什么？使用它的用途有哪些？解析.vue 文件的一个加载器，跟 template/js/style 转换成 js 模块。 用途：js 可以写 esstyle 样式可以 scss 或 less、template 可以加 jade 等 聊聊你对 Vue.js 的 template 编译的理解？简而言之，就是先转化成 AST 树，再得到的 render 函数返回 VNode（Vue 的虚拟 DOM 节点） 详情步骤： 首先，通过 compile 编译器把 template 编译成 AST 语法树（abstract syntax tree 即 源代码的抽象语法结构的树状表现形式），compile 是 createCompiler 的返回值，createCompiler 是用以创建编译器的。另外 compile 还负责合并 option。 然后，AST 会经过 generate（将 AST 语法树转化成 render funtion 字符串的过程）得到 render 函数，render 的返回值是 VNode，VNode 是 Vue 的虚拟 DOM 节点，里面有（标签名、子节点、文本等等） 什么是 vue 生命周期？Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载 Dom→ 渲染、更新 → 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。 vue 生命周期的作用是什么？它的生命周期中有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成好的逻辑。 vue 生命周期总共有几个阶段？它可以总共分为 8 个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后 第一次页面加载会触发哪几个钩子？第一次页面加载时会触发 beforeCreate, created, beforeMount, mounted 这几个钩子 DOM 渲染在 哪个周期中就已经完成？DOM 渲染在 mounted 中就已经完成了 简单描述每个周期具体适合哪些场景？beforecreate : 可以在这加个 loading 事件，出现加载框效果 在加载实例时触发 created : 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用 mounted : 挂载元素，获取到 DOM 节点 updated : 如果对数据统一处理，在这里写上相应函数 beforeDestroy : 可以做一个确认停止事件的确认框 nextTick : 更新数据后立即操作 dom vue 组件如何通信 方式 1：父子通信 父传子 ：自定义属性 props 子传父 ：自定义事件 $emit 方式 2：父子关系 $parent,$root 等方式找到父组件或根节点去对应调用它的方法或者设置他的属性 $children,$refs 找到某个子组件直接调用他的方法或者设置他的属性 方式 3： 祖先后代 祖先组件定义 provide 所有的后代组件定义 inject 就可接收传递过来的数据 方式 4： 任意两个组件（兄弟组件） 通过事件主线： vue 本身就有 $on 和 $emit 方法。 A 组件中使用$on监听事件，B组件中通过$emit 触发事件 方式 5： vuex 方式 6： 本地存储 说出$mount、$watch、$delete、$refs、$slots、$forceUpdate、$nextTick、$destroy 这些 API 方法或属性的的作用 $mount ：用于挂载 vue 实例到某个节点上面，功能类似 el 选项， 有了它可以不配置 el; $watch：用于监听数据的变化，功能类似内部配置选项 watch 一样的效果。 $delete：用于删除 data 里面数据里面的对象的属性，可以实现响应式效果。 功能和$set 一致，只不过他是删除属性 $refs：用于获取原生 DOM 节点，或者某个组件对象 $slot： 用于获取当前组件传入的所有插槽内容 $forceUpdate： 用于刷新当前组件或 vue 实例，它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。 $nextTick：将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。【简单理解即使等到 DOM 渲染完成再做应该的逻辑操作】 $destroy()：只是完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 is 的用法（用于动态组件且基于 DOM 内模板的限制来工作。）is 用来动态切换组件，DOM 模板解析 &lt;table&gt; &#123;&#x27; &#x27;&#125; &lt;tr is=&quot;my-row&quot;&gt;&lt;/tr&gt;&#123;&#x27; &#x27;&#125;&lt;/table&gt; vue 的两个核心是什么数据驱动、组件系统。 数据驱动:Object.defineProperty 和存储器属性: getter 和 setter（所以只兼容 IE9 及以上版本），可称为基于依赖收集的观测机制,核心是 VM，即 ViewModel，保证数据和视图的一致性。组件系统:点此查看 vue 的 render 函数式什么？如何使用Vue 推荐在绝大多数情况下使用模板来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力。这时你可以用渲染函数，它比模板更接近编译器。 无论 el 也好，template 最终都是通过 render 函数渲染，而且如果同时存在三者，render 函数权重最大！ render: function (createElement) &#123; return createElement(&#x27;标签名&#x27;,&#123; 属性描述 &#125;,子元素)&#125;// createElement 表示创建虚拟元素// createElement(&#x27;标签名&#x27;,&#123; 属性描述 &#125;,子元素)属性描述包括：// 与 `v-bind:class` 的 API 相同， // 接受一个字符串、对象或字符串和对象组成的数组 &#x27;class&#x27;: &#123; foo: true, bar: false &#125;, // 与 `v-bind:style` 的 API 相同， // 接受一个字符串、对象，或对象组成的数组 style: &#123; color: &#x27;red&#x27;, fontSize: &#x27;14px&#x27; &#125;, // 普通的 HTML attribute attrs: &#123; id: &#x27;foo&#x27; &#125;, // 组件 prop props: &#123; myProp: &#x27;bar&#x27; &#125;, // DOM property domProps: &#123; innerHTML: &#x27;baz&#x27; &#125;, // 事件监听器在 `on` 内， // 但不再支持如 `v-on:keyup.enter` 这样的修饰器。 // 需要在处理函数中手动检查 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler&#125; 案例 Vue.component(&#x27;box&#x27;,&#123; template:` &lt;div class=&quot;width:200px;height:200px;background-color:red&quot;&gt; &lt;h2 class=&#x27;title&#x27; id=&#x27;tit&#x27;&gt;我是标题&lt;/h2&gt; &lt;p&gt; &lt;button @click=&#x27;del&#x27;&gt;减少&lt;/button&gt; &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt; &lt;button @click=&#x27;add(2)&#x27;&gt;增加&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; ` data()&#123; return &#123; msg:1 &#125; &#125;, methods:&#123; add(val)&#123; this.msg+=val &#125;, del()&#123; this.msg-- &#125; &#125;&#125;) 通过 render 实现 Vue.component(&#x27;box&#x27;, &#123; data() &#123; return &#123; msg: 1, &#125;; &#125;, methods: &#123; add(val) &#123; this.msg += val; &#125;, del() &#123; this.msg--; &#125;, &#125;, render(h) &#123; // 创建div，且返回 return h( &#x27;div&#x27;, &#123; style: &#123; width: &#x27;200px&#x27;, height: &#x27;200px&#x27;, backgroundColor: &#x27;red&#x27;, &#125;, &#125;, [ // 创建h2 h( &#x27;h2&#x27;, &#123; class: &#x27;title&#x27;, attrs: &#123; id: &#x27;tit&#x27;, &#125;, &#125;, &#x27;我是标题&#x27; ), // 创建p h(&#x27;p&#x27;, &#123;&#125;, [ // 创建button h( &#x27;button&#x27;, &#123; on: &#123; click: this.del, &#125;, &#125;, &#x27;减少&#x27; ), // 创建span h(&#x27;span&#x27;, &#123;&#125;, this.msg), // 创建button h( &#x27;button&#x27;, &#123; on: &#123; click: () =&gt; &#123; this.add(2); &#125;, &#125;, &#125;, &#x27;增加&#x27; ), ]), ] ); &#125;,&#125;); 参考：https://www.jianshu.com/p/7508d2a114d3 使用 key 要什么要注意的吗？ 不要使用对象或数组之类的非基本类型值作为 key，请用字符串或数值类型的值； 不要使用数组的 index 作为 key 值，因为在删除数组某一项，index 也会随之变化，导致 key 变化，渲染会出错。 例：在渲染[a,b,c]用 index 作为 key，那么在删除第二项的时候，index 就会从 0 1 2 变成 0 1（而不是 0 2)，随之第三项的 key 变成 1 了，就会误把第三项删除了。 组件的 name 选项有什么作用？ 递归组件时，组件调用自身使用； 用is特殊特性和component内置组件标签时使用； keep-alive内置组件标签中include 和exclude属性中使用。 什么是递归组件？举个例子说明下？递归引用可以理解为组件调用自身，在开发多级菜单组件时就会用到，调用前要先设置组件的 name 选项， 注意一定要配合 v-if 使用，避免形成死循环，用 element-vue 组件库中 NavMenu 导航菜单组件开发多级菜单为例： &lt;template&gt; &lt;el-submenu :index=&quot;menu.id&quot; popper-class=&quot;layout-sider-submenu&quot; :key=&quot;menu.id&quot;&gt; &lt;template slot=&quot;title&quot;&gt; &lt;Icon :type=&quot;menu.icon&quot; v-if=&quot;menu.icon&quot; /&gt; &lt;span&gt;&#123;&#123; menu.title &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;template v-for=&quot;(child, i) in menu.menus&quot;&gt; &lt;side-menu-item v-if=&quot;Array.isArray(child.menus) &amp;&amp; child.menus.length&quot; :menu=&quot;child&quot;&gt;&lt;/side-menu-item&gt; &lt;el-menu-item :index=&quot;child.id&quot; :key=&quot;child.id&quot; v-else&gt; &lt;Icon :type=&quot;child.icon&quot; v-if=&quot;child.icon&quot; /&gt; &lt;span&gt;&#123;&#123; child.title &#125;&#125;&lt;/span&gt; &lt;/el-menu-item&gt; &lt;/template&gt; &lt;/el-submenu&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;sideMenuItem&#x27;, props: &#123; menu: &#123; type: Object, default() &#123; return &#123;&#125;; &#125;, &#125;, &#125;, &#125;;&lt;/script&gt; 说下$attrs和$listeners的使用场景？$attrs: 包含了父作用域中（组件标签）不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。 在创建基础组件时候经常使用，可以和组件选项inheritAttrs:false和配合使用在组件内部标签上用v-bind=&quot;$attrs&quot;将非 prop 特性绑定上去； $listeners: 包含了父作用域中（组件标签）的 (不含.native) v-on 事件监听器。 在组件上监听一些特定的事件，比如 focus 事件时，如果组件的根元素不是表单元素的，则监听不到，那么可以用v-on=&quot;$listeners&quot;绑定到表单元素标签上解决。 EventBus 注册在全局上时，路由切换时会重复触发事件，如何解决呢？在有使用$on的组件中要在beforeDestroy钩子函数中用$off销毁。 Vue 怎么改变插入模板的分隔符？用delimiters选项,其默认是[&quot;&#123;&#123;\", \"&#125;&#125;&quot;] // 将分隔符变成ES6模板字符串的风格new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;, &#x27;&#125;&#x27;]&#125;) Vue 变量名如果以_、$开头的属性会发生什么问题？怎么访问到它们的值？以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突，你可以使用例如 vm.$data._property 的方式访问这些属性。 怎么捕获 Vue 组件的错误信息？ errorCaptured是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收error、vm、info三个参数，return false后可以阻止错误继续向上抛出。 errorHandler为全局钩子，使用Vue.config.errorHandler配置，接收参数与errorCaptured一致，2.6 后可捕捉v-on与promise链的错误，可用于统一错误处理与错误兜底。 Vue 项目中如何配置 favicon？ 静态配置 &lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;, 其中&lt;%= BASE_URL %&gt;等同 vue.config.js 中publicPath的配置; 动态配置 &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;&quot;&gt; import browserImg from &#x27;images/kong.png&#x27;; //为favicon的默认图片const imgurl = &#x27;后端传回来的favicon.ico的线上地址&#x27;;let link = document.querySelector(&#x27;link[type=&quot;image/png&quot;]&#x27;);if (imgurl) &#123; link.setAttribute(&#x27;href&#x27;, imgurl);&#125; else &#123; link.setAttribute(&#x27;href&#x27;, browserImg);&#125; Vue 为什么要求组件模板只能有一个根元素？当前的 virtualDOM 差异和 diff 算法在很大程度上依赖于每个子组件总是只有一个根元素。 说说你对单向数据流和双向数据流的理解单向数据流是指数据只能从父级向子级传递数据，子级不能改变父级向子级传递的数据。 双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。 比如用v-model、.sync来实现双向数据流。 二、vue-routervue-route 如何使用？// 【安装 】npm i vue-router// 【配置】// src/router/index.js 创建配置文件import Vue from &#x27;vuex&#x27;import Router from &quot;vue-router&quot;// 安装Vue.use(Router)// 定义路由映射const routes = [ &#123; path:&quot;/地址&quot;,component:()=&gt;import(&#x27;组件位置路径&#x27;) &#125;]// 创建路由实例const router = new Router(&#123; routes,&#125;)// 暴露export default router// 【注入vue实例】// main.js中操作...import router from &#x27;./router&#x27;...new Vue(&#123; ..., router, // 一旦注入，所有组件中都有$router和$route; $router表示路由对象实例； $route表示当前页面路由信息 ...&#125;)// 【定义路由出口】// App.vue中操作&lt;router-view&gt;&lt;/router-view&gt;// 【使用router-link跳转】&lt;router-link to=&quot;/地址&quot;&gt;&lt;/router-link&gt; 何为命名路由？ 其实就是给路由取一个名字,增加一个 name 属性。 // 映射关系const routes = [&#123; name: &#x27;名称&#x27;, path: &#x27;/地址&#x27;, component: 组件 &#125;]; 定义了命名路由，那么就可以通过路由名称实现跳转 // 原来写法&lt;router-link to=&quot;/地址&quot;&gt;&lt;/router-link&gt;// 新写法&lt;router-link :to=&quot;&#123;name:&#x27;名称&#x27;&#125;&quot;&gt;&lt;/router-link&gt;// 编程式导航 router.push(&#x27;/地址&#x27;) router.push(&#123;name:&#x27;名称&#x27;&#125;) 如何定义动态路由，获取动态参数// 映射关系const routes = [&#123; name: &#x27;名称&#x27;, path: &#x27;/地址/:标识符&#x27;, component: 组件 &#125;]; &lt;router-link to=&quot;/地址/数据&quot;&gt;&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;名称&#x27;, params: &#123; 标识符: 数据 &#125; &#125;&quot;&gt;&lt;/router-link&gt;// 编程式导航 router.push(&#x27;/地址/数据&#x27;) router.push(&#123;name:&#x27;名称&#x27;,params:&#123;标识符:数据&#125;&#125;) 获取动态参数 this.$route.params.标识符 得到 数据 但是这里我们有更加高级的用法，使用 props 将组件解耦 // 映射关系const routes = [ &#123; name: &#x27;名称&#x27;, path: &#x27;/地址/:标识符&#x27;, component: 组件, props: true &#125;, // // 开启props传参，说白了将路由参数传递到组件的props中]; // 组件中，下面是组件的配置选型 export default &#123; ..., props:[&#x27;标识符&#x27;] //props定义和动态路由后面标识符一致的定义属性。 ... &#125; // 组件中可以直接通过this.标识符 直接获得路由参数数据。 如案例： // 路由配置const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/user/:id&#x27;, component: User, props: true, &#125;, ],&#125;); // A页面this.$router.push(&#x27;/user/123&#x27;)或者&lt;router-link to=&#x27;/user&#x27;&gt;去user页面&lt;/router-link&gt; // User页面const User = &#123; props: [&#x27;id&#x27;], // this.id 就是动态路由数据值为 123 template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;, // 这里就是会渲染123&#125;; 有哪些编程式导航方法 编程式导航方法都存在 路由实例里面。 组件中可以使用this.$router访问，其他 JS 文件中可以通过导入路由实例调用 this.$router.push(&#39;/地址&#39;) 跳转到某个新地址，历史记录栈中增加一个 this.$router.replace(&#39;/地址&#39;) 跳转到某个地址，新地址替换当前地址在历史记录中的位置 this.$router.go(数字) 正数前进几步；负数后退几步；0 表示刷新 this.$router.back() 后退 this.$router.forward() 前进 何为命名视图？如何使用 所谓的命名视图的意思是默认情况下我们一个路由地址渲染一个组件到一个 router-view 里面去；而命名视图的目的是 可以实现一个路由地址，渲染多个组件到不同的 router-view 里去进行展示 使用： // 映射关系const routes = [ &#123; name:&#x27;名称&#x27; , path:&#x27;/地址&#x27;, //component:组件 //只能渲染一个组件 components:&#123; default:组件X 视图名A:组件A, 视图名B:组件B &#125; &#125;] &lt;router-view&gt;&lt;/router-view&gt;&lt;!--默认视图，渲染组件X--&gt;上面这句其实是：&lt;router-view name=&quot;default&quot;&gt;&lt;/router-view&gt;&lt;router-view name=&quot;视图名A&quot;&gt;&lt;/router-view&gt;&lt;!--渲染组件A--&gt;&lt;router-view name=&quot;视图名B&quot;&gt;&lt;/router-view&gt;&lt;!--渲染组件B--&gt; 何为嵌套路由？ 如何使用？何时使用？ 定义：所谓的嵌套路由，指的的是在一个路由组件里面还有会有 router-view 展示下一级的路由组件信息。 何时使用：我们开发一些特定功能模块的时候，包含有子模块页面，就可以采用嵌套路由。 如：用户中心是一个大模块页面，用户订单、用户资料、收货地址等等都会有侧边栏信息，诸如此类有共同模块布局，且内容不同的，则可以使用嵌套路由。 如何使用： // 映射关系const routes = [ &#123; name:&#x27;名称&#x27; , path:&#x27;/地址&#x27;, component:组件 children:[ // 子级路由会渲染上级路由的组件里面的router-view里面进行展示 &#123; name:&#x27;名称1&#x27;, path:&quot;/地址/子地址1&quot;, component: ()=&gt;import(组件地址) &#125;, &#123; name:&#x27;名称2&#x27;, path:&quot;/地址/子地址2&quot;, component: ()=&gt;import(组件地址) &#125;, // 子级的地址也可以不加 /地址， 这样会自动拼接 上一级的前缀。 注意不能加 / &#123; name:&#x27;名称3&#x27;, path:&quot;子地址3&quot;, component: ()=&gt;import(组件地址) &#125; // 上述 path就单独写一个 子地址3 就表示 /地址/子地址3 ] &#125;] 怎么通过路由实现面包屑 认识面包屑 前后端分离实现面包屑有 2 中方式： 方式 1： 每个页面直接写死 方式 2： 通过$route.matched 属性 去遍历 生成。 方式 2 实现思路： 要有面包屑一般肯定要是一个嵌套路由，否则一般就只能展示 2 级。 每个路由都要有 meta 元信息， 然后里面设置一个 tilte，设置为标题。 我们的$route 表示当前页面路由信息，如果是一个嵌套路由，那么$route.matched 属性是一个数组，里面的内容就是一个上上级到下一级的路由信息，我们可以通过遍历数组，取出每个里面的 path 地址和 meta 里面的 title 来进行设置即可。 页面之间如何传参 本地存储，一个页面设置，一个页面读取 动态路由 /地址/数据 【A 页面】 this.$route.params.标识符 获取数据 【B 页面】 query 传参 /地址?属性名=值 【A 页面】 this.$route.query.属性名 【B 页面】 hash 传参 /地址#属性名=值 【A 页面】 this.$route.hash 然后再处理得到信息 【B 页面】 vue 存储和读取 vue-router 有哪几种导航钩子？三种 第一种是全局导航钩子： router.beforeEach( (to,from,next)=&gt;&#123; ... &#125; ) router.afterEach((to, from) =&gt; &#123; ... &#125;) 第二种：组件内的钩子 beforeRouteEnter(to, from, next) &#123; ... &#125; beforeRouteUpdate (to, from, next) &#123;...&#125; beforeRouteLeave (to, from, next) &#123;...&#125; 第三种：单独路由独享组件 const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // 配置在路由映射里面 // ... &#125;, &#125;, ],&#125;); $route和$router 的区别 $route 是“路由信息对象” path 路径地址 params 动态路由数据 hash hash 数据 query search 数据 fullPath 完整地址 matched 路由匹配 （可用于制作面包屑） name 路由名称 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等 push/replace/go/back/forward beforeEach/afterEach/… addRoutes 方法，增加映射 路由元信息是什么？有何作用？ 设置每个路由映对象的时候，可以增加一个 meta 属性，里面可以自定义相关数据 // 路由映射&#123; path:&#x27;/地址&#x27;, component: ()=&gt;import(组件地址), meta:&#123; 属性名:&quot;属性值&quot;, .... &#125;&#125; 组件中读取： this.$route.meta.属性名 作用： 可以通过这个设置标题，在拦截器里面进行设置； meta 里面放入权限验证字段，判断是否有权限访问页面 … 如何实现页面的过渡效果&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 如何实现路由重定向// 路由映射&#123; path:&#x27;/地址A&#x27;, component: ()=&gt;import(组件地址), redirect:&#x27;/地址B&#x27; // 访问地址A的时候将会跳转到地址B&#125; 路由懒加载是什么？ 如何实现？为什么要懒加载？ 为什么： 当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。 是什么：路由被访问的时候才加载对应组件 如何实现： // 路由映射&#123; path:&#x27;/地址A&#x27;, component: ()=&gt;import(组件地址) // 懒加载&#125; 导航钩子有何作用？ 导航钩子类似中间件的味道，对导航的发生过程进行拦截，满足条件才可以继续向下走，否则路由就会被挂起来。 所以我们很多时候需要注意是否需要在导航守卫里面调用 next 全局前置守卫：（router.beforeEach((to, from, next) =&gt; &#123; ... &#125;） 权限判断、标题设置、进度条开始 等，需要所有路由都做的事情 全局守后置守卫：（router.afterEach((to, from) =&gt; &#123;...&#125;） 进度条结束等 路由独享守卫：（ beforeEnter: (to, from, next) =&gt; &#123; ... &#125;） 权限判断、针对某一个路由要做的事情都放在这里。 局部前置守卫: （beforeRouteEnter (to, from, next) &#123; ... &#125;） 进入页面之前要做的事情，注意这里不能使用 this，因为组件还没有初始化 局部更新守卫： （beforeRouteUpdate (to, from, next) &#123; ... &#125;） 同路由跳转同路由的更新监测，如详情页跳转到详情页，可以放在这里监听 局部后置守卫： （beforeRouteLeave (to, from, next) &#123; ... &#125;） 某个页面要消失的时候做的事情，如判断是否要离开，是否保存了数据等。 如何实现激活导航 默认如果router-link组件的地址和当前路由地址一致，会加上router-link-active的 class 名（这是模糊匹配）或者 router-link-exact-active的 class 名（这是严格匹配） 修改激活 class 名： // 路由中配置new VueRouter(&#123; linkActiveClass:&#x27;class名&#x27;, // 非严格模式下的激活class名 linkExactActiveClass:&#x27;class名&#x27;, // 严格模式的激活的时候class名 routes:[...] // 映射&#125;) 有哪些路由模式？ 实现的具体原理是什么？ 路由模式 2 中： history 模式 原理： html5 的 history 里面的 api， 如 pushState,replaceState 这 2 个函数可以替换网页中的 url，但是页面不会重新加载 hash 模式 原理： 监听 window 的 hashchange 事件，展示不同组件 监听 popstate，pushState和replaceState不会触发popState事件，只有浏览器的返回按钮，go、back函数会触发 history 模式路由要注意什么？ 如果不想要很丑的 hash，我们可以用路由的 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。 注意点：不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面 简而言之： history 模式需要后台配置，否则会和真正的服务器端路由地址冲突。 addRoutes 方法是什么？有何作用？ 是什么：动态添加更多的路由规则。参数必须是一个符合 routes 选项要求的数组。 作用： 可以实现根据需求动态加载路由配置映射关系数据信息，我们一般在管理系统中，通过这个方法来实现 按需加载路由映射，从而实现不同的角色看到不同的菜单。 base 配置项的作用 配置路由地址的基准前缀地址，增加这个选项之后所有的路由地址会全部自动增加上这个前缀，但是我们写router-link 的时候不需要加这个前缀。 使用： // 路由中配置new VueRouter(&#123; base:&quot;/前缀地址&quot; routes:[...] // 映射&#125;) 如何处理滚动行为 history 模式下 new VueRouter(&#123; ..., // savedPosition 这个参数当且仅当导航 (通过浏览器的 前进/后退 按钮触发) 时才可用 效果和 router.go() 或 router.back() scrollBehavior (to, from, savedPosition) &#123; // 返回savedPosition 其实就是 当用户点击 返回的话，保持之前游览的高度 if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125; &#125;, ...&#125;) 注意：scrollBehavior 属性仅在 history 模式下才可以使用。 hash 模式下 router.beforeEach((to, from, next) =&gt; &#123; // 直接使用window的scroll方法滚动回顶部 window.scrollTo(0, 0); next();&#125;); 路由里面有哪些常用组件 router-link router-view 路由里面详情页跳转详情页，组件不重新创建如何处理？ 我们的vue-router同路由跳转到同路由，组件是不会更新的。 如：文章详情路由/article/11 页面里面有个链接跳转到/article/22 这篇文章，其实就是同路由组件跳转。这个时候文章详情组件是不会再次被创建的，所以我们不能把获取数据请求的方法写在 created或者 mounted里面或者在里面去调用，因为组件不会被再次创建，如果写在生命周期里面去调用，从而导致跳转到/article/22的时候无法请求数据， 如何解决： 方式 1：使用 beforeRouteUpdate，因为/article/11跳转到/article/22 这个跳转属于同路由组件更新，beforeRouteUpdate会被触发 方式 2： 使用watch去监听$route的变化，在监听的函数里面去发送请求。 如何实现页面加载进度条核心使用：nprogress插件 第一步， 安装 npm install --save nprogress 第二步， main.js 中引入插件 import NProgress from &#x27;nprogress&#x27;;import &#x27;nprogress/nprogress.css&#x27;; 第三步，在 main.js 文件配置插件的功能 NProgress.configure(&#123; easing: &#x27;ease&#x27;, // 动画方式 speed: 500, // 递增进度条的速度 showSpinner: false, // 是否显示加载ico trickleSpeed: 200, // 自动递增间隔 minimum: 0.3, // 初始化时的最小百分比&#125;); 第四步，监听路由跳转，进入页面执行插件动画。 路由跳转中 // router.js// 导航全局前置守卫router.beforeEach((to, from, next) =&gt; &#123; // 每次切换页面时，调用进度条 NProgress.start(); // 这个一定要加，没有next()页面不会跳转的。这部分还不清楚的去翻一下官网就明白了 next();&#125;); 跳转结束了 // router.jsrouter.afterEach(() =&gt; &#123; // 在即将进入新的页面组件前，关闭掉进度条 NProgress.done();&#125;); 如何实现刷新页面 实现思路有 3 种 方式 1： 通过给router-view添加v-if指令，控制组件重新渲染，从而实现刷新。 方式 2： 采用window.reload()，或者router.go(0)刷新时，整个浏览器进行了重新加载，闪烁，体验不好 方式 3： 为了实现刷新页面，可以先跳转到一个空页面，然后马上跳回来，从而实现这个功能 方式 1 实现方式 provide / inject 组合 作用：允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。 App.vue: 声明 reload 方法，控制 router-view 的显示或隐藏，从而控制页面的再次加载 某个组件中：在页面注入 App.vue 组件提供（provide）的 reload 依赖，在逻辑完成之后（删除或添加…）,直接 this.reload()调用，即可刷新当前页面。 需要理解 provide/inject 的使用，不熟悉看文档地址：https://cn.vuejs.org/v2/api/#provide-inject 方式 3 的实现方法 一、原理 如上图所示，我们需要为要刷新的页面 A 编写一个自动跳回的空页面，当用户操作了 A 页面后，A 页面先跳转到空页面，然后空页面马上跳回 A 页面，这时候 vue 会去重新加载 A 页面。这种方法可以变相实现自我刷新，缺点是当需要刷新的页面较多时，空页面也会随之变多。 二、当前页面事件监听 如上图所示，我们定义了 refreshPage 方法，这个方法是对特定事件的回调，在这个方法会处理业务逻辑，然后在最后使用 vue 的 router 跳转到一个空页面，这个空页面路由路径是/user/back，这个路径是随便取的，大家可以选择自己的路径 三、空页面的编写 如上图所示，在空页面中立即执行路由，跳回原来的页面，这时候原来的页面会进行重新加载，从而实现了刷新。这里的/user/index 就是跳回原来页面的路由路径，大家需要根据自己的项目情况写。 四、注意事项 本文所使用的方法，其实是一种 hack 方法，在极端情况下，比如网络极端恶劣，那么可能出现跳到空页面后跳不会来，或者干脆跳不到空页面的情况，大家需要根据自己的项目情况酌情选择。 如何使用路由实现标签页 &lt;template&gt; &lt;ul class=&quot;tag-list&quot;&gt; &lt;!-- 循环这个li --&gt; &lt;li :class=&quot;$route.fullPath === item.path ? &#x27;on&#x27; : &#x27;&#x27;&quot; v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt; &lt;router-link :to=&quot;item.path&quot;&gt; &#123;&#123; item.name &#125;&#125; &lt;/router-link&gt; &lt;i @click=&quot;del(item, index)&quot;&gt;X&lt;/i&gt; &lt;/li&gt; &lt;li @click=&quot;delOther&quot;&gt;关闭其他&lt;/li&gt; &lt;li @click=&quot;delAll&quot;&gt;关闭所有&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; name: &#x27;TagsList&#x27;, data() &#123; // 从本地存储读取是否有！ let list = localStorage.getItem(&#x27;taglist&#x27;); return &#123; list: list ? JSON.parse(list) : [], // 菜单地址池 &#125;; &#125;, watch: &#123; // 监听$route的变化，从而实现增加标签页信息 $route: &#123; immediate: true, // 一开始就要做一次监听 handler() &#123; // 判断是否已经有 const hasPath = this.list.some(val =&gt; val.path === this.$route.fullPath); // 如果没有就写入 !hasPath &amp;&amp; this.list.push(&#123; name: this.$route.meta.title, path: this.$route.fullPath, &#125;); // 写入本地存储持久化 localStorage.setItem(&#x27;taglist&#x27;, JSON.stringify(this.list)); &#125;, &#125;, &#125;, methods: &#123; // 删除单个标签页 del(val, index) &#123; //删除的元素，删除元素的下标 // 删除的是否为激活元素 if (val.path === this.$route.fullPath) &#123; // 是激活 // 跳转到index-1的那个路由地址去！ 左边激活 this.list.splice(index, 1); // 删除对应元素！ if (this.list.length) &#123; // 还有值！ if (index == 0) &#123; // 删除第是第一个，说明右边还有，那么就向后走，但是其实还是index下标这个，因为数组已经发生变化了 this.$router.push(this.list[index].path); &#125; else &#123; // 删除的不是第一个（说明左边还有），那么就展示左边的一个 this.$router.push(this.list[index - 1].path); &#125; &#125; else &#123; // 最一个元素，跳转到制定地址去 this.$router.push(&#x27;/welcome&#x27;); &#125; &#125; else &#123; // 不是激活 this.list.splice(index, 1); &#125; // 持久化存储 localStorage.setItem(&#x27;taglist&#x27;, JSON.stringify(this.list)); &#125;, // 删除其他标签页 delOther() &#123; // 直接赋值为当前页面元素 this.list = [&#123; name: this.$route.meta.title, path: this.$route.fullPath &#125;]; // 持久化存储 localStorage.setItem(&#x27;taglist&#x27;, JSON.stringify(this.list)); &#125;, // 删除所有标签 delAll() &#123; this.list = []; // 持久化存储 localStorage.setItem(&#x27;taglist&#x27;, JSON.stringify(this.list)); // 跳转地址 this.$router.push(&#x27;/welcome&#x27;); &#125;, &#125;, &#125;; /*思路： 有一个数组，用于存储打开过的标签信息 // 数组格式： [&#123; name:&#x27;名称&#x27;,path:&#x27;/地址&#x27; &#125;,...] 增加： // 用watch监听$route的变化 // 有变化，插入到数组中去（判断一下数组中是否已经存在） 删除： 删除所有： 直接赋值为空数组，然后跳转到默认地址 删除其他： 直接赋值为一个元素，就是当前路由的信息 删除单个： // 是否为激活 // 不是激活项 直接删除 // 是激活项： // 首先删除元素 // 删除完之后数组是否还有长度： // 没有长度，说明删除的是最后一个元素且还是激活项，那么跳转到默认地址 // 有长度，就判断删除的元素下标是否为0，也就是判断是否为首位 // 如果是0，【删完后还有长度，且删除的那个是首位，说明右边还有内容】，所以展示右边的内容。而右边那个元素的下标就是index // 如果不是0 【删完后还有长度，且删除的不是首位，说明左边还有内容】，所以展示左边的内容，以此类推，直到左边没有了，就会去判断右边是否还有。*/&lt;/script&gt;&lt;style scoped&gt; .tag-list &#123; position: absolute; left: 0; top: 0; width: 100%; background-color: #eee; border-bottom: 1px solid #aaa; height: 50px; &#125; .tag-list li &#123; display: inline-block; list-style: none; padding-left: 10px; padding-right: 30px; line-height: 30px; border: 1px solid blue; color: blue; margin: 10px; position: relative; &#125; .tag-list li a &#123; text-decoration: none; color: inherit; &#125; .tag-list li i &#123; position: absolute; right: 5px; top: 5px; width: 20px; height: 20px; display: inline-block; text-align: center; line-height: 20px; font-style: normal; border-radius: 50%; cursor: pointer; &#125; .tag-list li i:hover &#123; background-color: blue; color: #fff; &#125; .tag-list li.on &#123; background-color: blue; color: #fff; &#125; .tag-list li.on i:hover &#123; background-color: #fff; color: #000; &#125;&lt;/style&gt; 说一下路由实现的原理 hash 模式：监听 window 的 hashchange 事件，从而实现更换展示不同的组件 history 模式： 从 HTML5 开始，History interface 提供了 2 个新的方法：pushState()**、replaceState()** 使得我们可以对浏览器历史记录栈进行修改 参考文档地址：https://www.cnblogs.com/gaosirs/p/10606266.html vue-router 原理文档：https://blog.csdn.net/derivation/article/details/105085951 完整的 vue-router 导航解析流程 1.导航被触发； 2.在失活的组件里调用 beforeRouteLeave 守卫； 3.调用全局 beforeEach 守卫； 4.在复用组件里调用 beforeRouteUpdate 守卫； 5.调用路由配置里的 beforeEnter 守卫； 6.解析异步路由组件； 7.在被激活的组件里调用 beforeRouteEnter 守卫； 8.调用全局 beforeResolve 守卫； 9.导航被确认；10..调用全局的 afterEach 钩子；11.DOM 更新； 12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。 切换路由时，需要保存草稿的功能，怎么实现呢？&lt;keep-alive :include=&quot;include&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 其中 include 可以是个数组，数组内容为路由的 name 选项的值。 说说你对 router-link 的了解&lt;router-link&gt;是 Vue-Router 的内置组件，在具有路由功能的应用中作为声明式的导航使用。 &lt;router-link&gt;有 8 个 props，其作用是： to：必填，表示目标路由的链接。当被点击后，内部会立刻把to的值传到router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。 &lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#x27;home&#x27;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;home&#x27; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;user&#x27;, query: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; 注意 path 存在时 params 不起作用，只能用 query replace：默认值为 false，若设置的话，当点击时，会调用router.replace()而不是router.push()，于是导航后不会留下 history 记录。 append：设置 append 属性后，则在当前 (相对) 路径前添加基路径。 tag：让&lt;router-link&gt;渲染成tag设置的标签，如tag:&#39;li,渲染结果为&lt;li&gt;foo&lt;/li&gt;。 active-class：默认值为router-link-active,设置链接激活时使用的 CSS 类名。默认值可以通过路由的构造选项 linkActiveClass 来全局配置。 exact-active-class：默认值为router-link-exact-active,设置链接被精确匹配的时候应该激活的 class。默认值可以通过路由构造函数选项 linkExactActiveClass 进行全局配置的。 exact ：是否精确匹配，默认为 false。```html&lt;!-- 这个链接只会在地址为 / 的时候被激活 --&gt;&lt;router-link to=&quot;/&quot; exact&gt;&lt;/router-link&gt; event：声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组，默认是click。 Vue 路由怎么跳转打开新窗口？const obj = &#123; path: xxx, //路由地址 query: &#123; mid: data.id, //可以带参数 &#125;,&#125;;const &#123; href &#125; = this.$router.resolve(obj);window.open(href, &#x27;_blank&#x27;); 三、vuexvuex 和本地存储的区别 vuex 刷新就丢失，本地存储一直在 vuex 它可以实时更新，本地存储不能 什么是 Vuex？Vuex 是一个专为 Vue.js 应用程序开发的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交 mutation，例this.$store.commit(&#39;SET_VIDEO_PAUSE&#39;, video_pause)，SET_VIDEO_PAUSE 为 mutations 属性中定义的方法。 Vuex 解决了什么问题？ 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。 怎么引用 Vuex？ 先安装依赖nnpm install vuex --save 在项目目录 src 中建立 store 文件夹 在 store 文件夹下新建 index.js 文件,写入 import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);//不是在生产环境debug为trueconst debug = process.env.NODE_ENV !== &#x27;production&#x27;;//创建Vuex实例对象const store = new Vuex.Store(&#123; strict: debug, //在不是生产环境下都开启严格模式 state: &#123;&#125;, getters: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;);export default store;复制代码; 然后再 main.js 文件中引入 Vuex,这么写 import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;import store from &#x27;./store&#x27;;const vm = new Vue(&#123; store: store, // 一旦挂载，组件中this.$store就可以得到仓库实例 render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;); Vuex 的 5 个核心属性是什么？分别是 state、getters、mutations、actions、modules 。 Vuex 中状态储存在哪里，怎么改变它？存储在 state 中，改变 Vuex 中的状态的唯一途径就是显式地提交 (commit) mutation。 Vuex 中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变 state 里面的状态，是不允许，所以先用深度克隆复制对象，再修改。 怎么在组件中批量使用 Vuex 的 state 状态？使用 mapState 辅助函数, 利用对象展开运算符将 state 混入 computed 对象中 import &#123; mapState &#125; from &#x27;vuex&#x27;;export default &#123; computed: &#123; ...mapState([&#x27;price&#x27;, &#x27;number&#x27;]), &#125;,&#125;; Vuex 中要从 state 派生一些状态出来，且多个组件使用它，该怎么做，？使用 getter 属性，相当 Vue 中的计算属性 computed，只有原状态改变派生状态才会改变。 getter 接收两个参数，第一个是 state，第二个是 getters(可以用来访问其他 getter)。 const store = new Vuex.Store(&#123; state: &#123; price: 10, number: 10, discount: 0.7, &#125;, getters: &#123; total: state =&gt; &#123; return state.price * state.number; &#125;, discountTotal: (state, getters) =&gt; &#123; return state.discount * getters.total; &#125;, &#125;,&#125;); 然后在组件中可以用计算属性 computed 通过this.$store.getters.total这样来访问这些派生转态。 computed: &#123; total() &#123; return this.$store.getters.total &#125;, discountTotal() &#123; return this.$store.getters.discountTotal &#125; // 或者直接计算属性，上述代码可以简写为 ...mapGetters([&#x27;total&#x27;,&#x27;discountTotal&#x27;])&#125; 怎么通过 getter 来实现在组件内可以通过特定条件来获取 state 的状态？通过让 getter 返回一个函数，来实现给 getter 传参。然后通过参数来进行判断从而获取 state 中满足要求的状态 const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: &#x27;...&#x27;, done: true &#125;, &#123; id: 2, text: &#x27;...&#x27;, done: false &#125;, ], &#125;, getters: &#123; getTodoById: state =&gt; id =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id); &#125;, &#125;,&#125;); 然后在组件中可以用计算属性 computed 通过this.$store.getters.getTodoById(2)这样来访问这些派生转态。 computed: &#123; getTodoById() &#123; return this.$store.getters.getTodoById &#125;,&#125;mounted()&#123; console.log(this.getTodoById(2).done)//false&#125; 怎么在组件中批量使用 Vuex 的 getter 属性使用 mapGetters 辅助函数, 利用对象展开运算符将 getter 混入 computed 对象中 import &#123; mapGetters &#125; from &#x27;vuex&#x27;;export default &#123; computed: &#123; ...mapGetters([&#x27;total&#x27;, &#x27;discountTotal&#x27;]), &#125;,&#125;; 怎么在组件中批量给 Vuex 的 getter 属性取别名并使用使用 mapGetters 辅助函数, 利用对象展开运算符将 getter 混入 computed 对象中 import &#123; mapGetters &#125; from &#x27;vuex&#x27;;export default &#123; computed: &#123; ...mapGetters(&#123; myTotal: &#x27;total&#x27;, myDiscountTotal: &#x27;discountTotal&#x27;, &#125;), &#125;,&#125;; 在 Vuex 的 state 中有个状态 number 表示货物数量，在组件怎么改变它。首先要在 mutations 中注册一个 mutation const store = new Vuex.Store(&#123; state: &#123; number: 10, &#125;, mutations: &#123; SET_NUMBER(state, data) &#123; state.number = data; &#125;, &#125;,&#125;); 在组件中使用this.$store.commit提交 mutation，改变 number this.$store.commit(&#x27;SET_NUMBER&#x27;, 10); 在 Vuex 中使用 mutation 要注意什么。mutation 必须是同步函数 在组件中多次提交同一个 mutation，怎么写使用更方便。使用 mapMutations 辅助函数,在组件中这么使用 import &#123; mapMutations &#125; from &#x27;vuex&#x27;methods:&#123; ...mapMutations(&#123; setNumber:&#x27;SET_NUMBER&#x27;, &#125;)&#125; 然后调用this.setNumber(10)相当调用this.$store.commit(&#39;SET_NUMBER&#39;,10) Vuex 中 action 和 mutation 有什么区别？ action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。 action 可以包含任意异步操作。mutation 只能是同步操作。 提交方式不同，action 是用this.$store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。mutation 是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交。 接收参数不同，mutation 第一个参数是 state，而 action 第一个参数是 context，其包含了 &#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters; // 等同于 `store.getters`，只存在于模块中&#125; Vuex 中 action 和 mutation 有什么相同点？第二参数都可以接收外部提交时传来的参数。 this.$store.dispatch(&#39;ACTION_NAME&#39;,data)和this.$store.commit(&#39;SET_NUMBER&#39;,10) 在组件中多次提交同一个 action，怎么写使用更方便。使用 mapActions 辅助函数,在组件中这么使用 methods:&#123; ...mapActions(&#123; setNumber:&#x27;SET_NUMBER&#x27;, &#125;)&#125; 然后调用this.setNumber(10)相当调用this.$store.dispatch(&#39;SET_NUMBER&#39;,10) Vuex 中 action 通常是异步的，那么如何知道 action 什么时候结束呢？在 action 函数中返回 Promise，然后再提交时候用 then 处理 actions:&#123; SET_NUMBER_A(&#123;commit&#125;,data)&#123; return new Promise((resolve,reject) =&gt;&#123; setTimeout(() =&gt;&#123; commit(&#x27;SET_NUMBER&#x27;,10); resolve(); &#125;,2000) &#125;) &#125;&#125;this.$store.dispatch(&#x27;SET_NUMBER_A&#x27;).then(() =&gt; &#123; // ...&#125;) Vuex 中有两个 action，分别是 actionA 和 actionB，其内都是异步操作，在 actionB 要提交 actionA，需在 actionA 处理结束再处理其它操作，怎么实现？利用 ES6 的async和await来实现。 actions:&#123; async actionA(&#123;commit&#125;)&#123; //... &#125;, async actionB(&#123;dispatch&#125;)&#123; await dispatch (&#x27;actionA&#x27;)//等待actionA完成 // ... &#125;&#125; 有用过 Vuex 模块吗，为什么要使用，怎么使用。有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。 在 module 文件新建 moduleA.js 和 moduleB.js 文件。在文件中写入 const state = &#123; //...&#125;;const getters = &#123; //...&#125;;const mutations = &#123; //...&#125;;const actions = &#123; //...&#125;;export default &#123; state, getters, mutations, actions,&#125;; 然后再 index.js 引入模块 import Vue from &#x27;vue&#x27;;import Vuex from &#x27;vuex&#x27;;Vue.use(Vuex);import moduleA from &#x27;./module/moduleA&#x27;;import moduleB from &#x27;./module/moduleB&#x27;;const store = new Vuex.Store(&#123; modules: &#123; moduleA, moduleB, &#125;,&#125;);export default store; 在模块中，getter 和 mutation 接收的第一个参数 state，是全局的还是模块的？第一个参数 state 是模块的 state，也就是局部的 state。 在模块中，getter 和 mutation 和 action 中怎么访问全局的 state 和 getter？ 在 getter 中可以通过第三个参数 rootState 访问到全局的 state,可以通过第四个参数 rootGetters 访问到全局的 getter。 在 mutation 中不可以访问全局的 satat 和 getter，只能访问到局部的 state。 在 action 中第一个参数 context 中的context.rootState访问到全局的 state，context.rootGetters访问到全局的 getter。 在组件中怎么访问 Vuex 模块中的 getter 和 state,怎么提交 mutation 和 action？ 直接通过this.$store.getters.xxx和this.$store.模块名.xxx来访问模块中的 getter 和 state。 直接通过this.$store.commit(&#39;mutationA&#39;,data)提交模块中的 mutation。 直接通过this.$store.dispatch(&#39;actionA&#39;,data)提交模块中的 action。 以上是没有命名空间的，如果有命名空间那么就是下面这样 直接通过this.$store.getters[&#39;模块名/xxx&#39;]和this.$store.模块名.xxx来访问模块中的 getter 和 state。 直接通过this.$store.commit(&#39;模块名/mutationA&#39;,data)提交模块中的 mutation。 直接通过this.$store.dispatch(&#39;模块名/actionA&#39;,data)提交模块中的 action。 用过 Vuex 模块的命名空间吗？为什么使用，怎么使用。默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间，如果多个模块中 action、mutation 的命名是一样的，那么提交 mutation、action 时，将会触发所有模块中命名相同的 mutation、action。 这样有太多的耦合，如果要使你的模块具有更高的封装度和复用性，你可以通过添加namespaced: true 的方式使其成为带命名空间的模块。 export default &#123; namespaced: true, state, getters, mutations, actions,&#125;; 怎么在带命名空间的模块内提交全局的 mutation 和 action？将 &#123; root: true &#125; 作为第三参数传给 dispatch 或 commit 即可。 this.$store.dispatch(&#x27;actionA&#x27;, null, &#123; root: true &#125;);this.$store.commit(&#x27;mutationA&#x27;, null, &#123; root: true &#125;); 怎么在带命名空间的模块内注册全局的 action？actions: &#123; actionA: &#123; root: true, // 带上root为true表示就是根的action了 handler (context, data) &#123; ... &#125; &#125; &#125; 组件中怎么提交 modules 中的带命名空间的 moduleA 中的 mutationA？this.$store.commit(&#x27;moduleA/mutationA&#x27;, data); 怎么使用 mapState，mapGetters，mapActions 和 mapMutations 这些函数来绑定带命名空间的模块？使用createNamespacedHelpers创建基于某个命名空间辅助函数 import &#123; createNamespacedHelpers &#125; from &#x27;vuex&#x27;;const &#123; mapState, mapActions,mapGetters,mapMutations &#125; = createNamespacedHelpers(&#x27;moduleA&#x27;);export default &#123; computed: &#123; // 在 `module/moduleA` 中查找 ...mapState(&#123; a: state =&gt; state.a, b: state =&gt; state.b &#125;), ...mapGetters([&#x27;getterA&#x27;,&#x27;getterB&#x27;]) &#125;, methods: &#123; // 在 `module/moduleA` 中查找 ...mapActions([ &#x27;actionA&#x27;, &#x27;actionB&#x27; ])， ...mapMutations([ &#x27;mutationA&#x27;, &#x27;mutationB&#x27; ]) &#125;&#125; 如果不使用createNamespacedHelpers就需要注意，不能直接用数组语去获取 import &#123; mapState, mapActions &#125; from &#x27;vuex&#x27;;export default &#123; computed: &#123; // 在 `module/moduleA` 中查找 ...mapState(&#123; a: state =&gt; state.模块名.a, b: state =&gt; state.模块名.b &#125;), ...mapGetters(&#123; gettersA:&#x27;模块名/gettersA&#x27; gettersB:&#x27;模块名/gettersB&#x27; &#125;) &#125;, methods: &#123; // 在 `module/moduleA` 中查找 ...mapActions(&#123; actionA:&#x27;模块名/actionA&#x27;, actionB:&#x27;模块名/actionB&#x27; &#125;), ...mapMutations(&#123; mutationA:&#x27;模块名/mutationA&#x27;, mutationB:&#x27;模块名/mutationB&#x27; &#125;) &#125;&#125; Vuex 插件有用过吗？怎么用简单介绍一下？Vuex 插件就是一个函数，它接收 store 作为唯一参数。在 Vuex.Store 构造器选项 plugins 引入。 在 store/plugin.js 文件中写入 export default function createPlugin(param) &#123; return store =&gt; &#123; //... &#125;;&#125; 然后在 store/index.js 文件中写入 import createPlugin from &#x27;./plugin.js&#x27;;const myPlugin = createPlugin();const store = new Vuex.Store(&#123; // ... plugins: [myPlugin],&#125;); 在 Vuex 插件中怎么监听组件中提交 mutation 和 action？ 用 Vuex.Store 的实例方法subscribe监听组件中提交 mutation 用 Vuex.Store 的实例方法subscribeAction监听组件中提交 action 在 store/plugin.js 文件中写入 export default function createPlugin(param) &#123; return store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type); //是那个mutation console.log(mutation.payload); console.log(state); &#125;); // store.subscribeAction((action, state) =&gt; &#123; // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // &#125;) store.subscribeAction(&#123; before: (action, state) =&gt; &#123; //提交action之前 console.log(`before action $&#123;action.type&#125;`); &#125;, after: (action, state) =&gt; &#123; //提交action之后 console.log(`after action $&#123;action.type&#125;`); &#125;, &#125;); &#125;;&#125; import createPlugin from &#x27;./plugin.js&#x27;;const myPlugin = createPlugin();const store = new Vuex.Store(&#123; // ... plugins: [myPlugin],&#125;); 在 v-model 上怎么用 Vuex 中 state 的值？需要通过 computed 计算属性来转换。 &lt;input v-model=&quot;message&quot;&gt;// ...computed: &#123; message: &#123; get () &#123; return this.$store.state.message &#125;, set (value) &#123; this.$store.commit(&#x27;updateMessage&#x27;, value) &#125; &#125;&#125; Vuex 的严格模式是什么,有什么作用,怎么开启？在严格模式下，无论何时发生了状态变更且不是由 mutation 函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。（有效防止了直接赋值 state 里面的内容进行修改） 在 Vuex.Store 构造器选项中开启,如下 const store = new Vuex.Store(&#123; strict: true,&#125;); 为什么不推荐直接赋值修改 state组件里直接修改 state 也是生效的,但是不推荐这种直接修改 state 的方式，因为这样不能使用 vuex 的浏览器插件来跟踪状态的变化，不利于调试。如果是严格模式下，直接会抛出错误。 四、axiosaxios 是什么 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。前端最流行的 ajax 请求库， react/vue 官方都推荐使用 axios 发 ajax 请求 axios 特点 基于 promise 的异步 ajax 请求库，支持 promise 所有的 API 浏览器端/node 端都可以使用，浏览器中创建 XMLHttpRequests 支持请求／响应拦截器 支持请求取消 可以转换请求数据和响应数据，并对响应回来的内容自动转换成 JSON 类型的数据 批量发送多个请求 安全性更高，客户端支持防御 XSRF，就是让你的每个请求都带一个从 cookie 中拿到的 key, 根据浏览器同源策略，假冒的网站是拿不到你 cookie 中得 key 的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 axios 常用语法 axios(config): 通用/最本质的发任意类型请求的方式 axios(url[, config]): 可以只指定 url 发 get 请求 axios.request(config): 等同于 axios(config) axios.get(url[, config]): 发 get 请求 axios.delete(url[, config]): 发 delete 请求 axios.post(url[, data, config]): 发 post 请求 axios.put(url[, data, config]): 发 put 请求 axios.defaults.xxx: 请求的默认全局配置 axios.interceptors.request.use(): 添加请求拦截器 axios.interceptors.response.use(): 添加响应拦截器 axios.create([config]): 创建一个新的 axios(它没有下面的功能) axios.Cancel(): 用于创建取消请求的错误对象 axios.CancelToken(): 用于创建取消请求的 token 对象 axios.isCancel(): 是否是一个取消请求的错误 axios.all(promises): 用于批量执行多个异步请求 axios.spread(): 用来指定接收所有成功数据的回调函数的方法 axios 为什么既能在浏览器环境运行又能在服务器(node)环境运行？axios 在浏览器端使用XMLHttpRequest对象发送 ajax 请求；在 node 环境使用http对象发送 ajax 请求。 var defaults.adapter = getDefaultAdapter();function getDefaultAdapter () &#123; var adapter; if (typeof XMLHttpRequest !== &#x27;undefined&#x27;) &#123; // 浏览器环境 adapter = require(&#x27;./adapter/xhr&#x27;); &#125; else if (typeof process !== &#x27;undefined&#x27;) &#123; // node环境 adapter = require(&#x27;./adapter/http&#x27;); &#125; return adapter;&#125; 上面几行代码，可以看出：XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能；process 对象是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。原来作者是通过判断 XMLHttpRequest 和 process 这两个全局变量来判断程序的运行环境的，从而在不同的环境提供不同的 http 请求模块，实现客户端和服务端程序的兼容。 axios 相比原生 ajax 的优点ajax 的缺点 本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮 基于原生的 XHR 开发，XHR 本身的架构不清晰。 JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打包的方案又不能享受 CDN 服务） 不符合关注分离（Separation of Concerns）的原则 配置和调用方式非常混乱，而且基于事件的异步模型不友好。 说下你了解的 axios 相关配置属性？ url是用于请求的服务器 URL method是创建请求时使用的方法,默认是 get baseURL将自动加在url前面，除非url是一个绝对 URL。它可以通过设置一个baseURL便于为 axios 实例的方法传递相对 URL transformRequest允许在向服务器发送前，修改请求数据，只能用在’PUT’,’POST’和’PATCH’这几个请求方法 headers是即将被发送的自定义请求头headers:{‘X-Requested-With’:’XMLHttpRequest’}, params是即将与请求一起发送的 URL 参数，必须是一个无格式对象(plainobject)或 URLSearchParams 对象 params: &#123; ID: 12345;&#125; auth表示应该使用 HTTP 基础验证，并提供凭据这将设置一个Authorization头，覆写掉现有的任意使用headers设置的自定义Authorization头 auth:&#123;username:&#x27;janedoe&#x27;,password:&#x27;s00pers3cret&#x27;&#125; ‘proxy’定义代理服务器的主机名称和端口，这里的auth表示 HTTP 基础验证应当用于连接代理，并提供凭据这将会设置一个Proxy-Authorization头，覆写掉已有的通过使用header设置的自定义Proxy-Authorization头。 proxy:&#123; host:&#x27;127.0.0.1&#x27;, port:9000, auth::&#123; username:&#x27;mikeymike&#x27;, password:&#x27;rapunz3l&#x27; &#125;&#125; 什么是 axios 拦截器 什么是拦截器： 在我们实际发送请求到我们的服务器之前进行拦截处理；在我们的服务器端正式返回数据给具体请求方法前进行拦截。 效果图 请求拦截器的作用是在请求发送前进行一些操作，例如在每个请求体里加上 token，统一做了处理如果以后要改也非常容易。 响应拦截器的作用是在接收到响应后进行一些操作，例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页等。 拦截器如何使用// 添加请求拦截器axios.interceptors.request.use( function (config) &#123; // 在发送请求之前做些什么 return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器axios.interceptors.response.use( function (response) &#123; // 对响应数据做点什么 return response; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;); 如何创建一个 axios 实例const $axios = axios.create(&#123; 配置信息,&#125;);// 注意创建的axios实例对象是没有all方法的。 axios 处理 token 过期后如何继续之前的请求/** * 封装 axios 请求模块 */import axios from &#x27;axios&#x27;;import store from &#x27;@/store&#x27;;import router from &#x27;@/router&#x27;;// axios.create 方法：复制一个 axiosconst request = axios.create(&#123; baseURL: &#x27;http://xxxx.cn/&#x27;, // 基础路径&#125;);// 请求拦截器 【携带token】request.interceptors.request.use( function (config) &#123; const user = store.state.user; if (user) &#123; config.headers.Authorization = `Bearer $&#123;user.token&#125;`; &#125; // Do something before request is sent return config; &#125;, function (error) &#123; // Do something with request error return Promise.reject(error); &#125;);// 响应拦截器request.interceptors.response.use( // 响应成功进入第1个函数 // 该函数的参数是响应对象 function (response) &#123; // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data return response; &#125;, // 响应失败进入第2个函数，该函数的参数是错误对象 async function (error) &#123; // Any status codes that falls outside the range of 2xx cause this function to trigger // Do something with response error // 如果响应码是 401 ，则请求获取新的 token // 响应拦截器中的 error 就是那个响应的错误对象 console.dir(error); if (error.response &amp;&amp; error.response.status === 401) &#123; // 校验是否有 refresh_token const user = store.state.user; if (!user || !user.refresh_token) &#123; router.push(&#x27;/login&#x27;); // 代码不要往后执行了 return; &#125; // 如果有refresh_token，则请求获取新的 token try &#123; const res = await axios(&#123; method: &#x27;PUT&#x27;, url: &#x27;http://xxxx/authorizations&#x27;, // 更新token的地址 headers: &#123; Authorization: `Bearer $&#123;user.refresh_token&#125;`, &#125;, &#125;); // 如果获取成功，则把新的 token 更新到容器中 console.log(&#x27;刷新 token 成功&#x27;, res); store.commit(&#x27;setUser&#x27;, &#123; token: res.data.data.token, // 最新获取的可用 token refresh_token: user.refresh_token, // 还是原来的 refresh_token &#125;); // 把之前失败的用户请求继续发出去 // config 是一个对象，其中包含本次失败请求相关的那些配置信息，例如 url、method 都有 // return 把 request 的请求结果继续返回给发请求的具体位置 return request(error.config); // 【核心：继续之前的上一次请求】 &#125; catch (err) &#123; // 如果获取失败，直接跳转 登录页 console.log(&#x27;请求刷线 token 失败&#x27;, err); router.push(&#x27;/login&#x27;); &#125; &#125; return Promise.reject(error); &#125;);export default request; vue 中如何使用 axios 安装 axios npm i axios -S vue 中使用 axios 一般主要是 2 中方法 方法 1：直接将 axios 或者 axios 的实例挂载到 vue 的原型上面，这样在所有的组件里面都可以直接使用； // main.js中此处很多其他代码...,import axios from &quot;axios&quot; // 导入const $axios = axios.create(&#123; // 创建axios实例 baseUrl:&quot;基准地址&quot;, timeout:3000&#125;)Vue.prototype.$axios = $axios // 挂载到vue原型上面此处很多其他代码..., // 任意组件中 通过this.$axios 直接获取实例然后调用即可this.$axios.get/post(...) 方法 2：封装单独的 axios，且将所有的数据请求独立到 api 目录，然后将请求方法传递到页面使用，实际工作里面这种用的最多 创建一个 axios 实例，配置基本信息，和拦截器 放在utils/http.js import axios from &#x27;axios&#x27;;// 创建一个axios实例let $axios = axios.create(&#123; baseURL: &#x27;http://122.51.249.55:3000/index.php/Api/&#x27;, // 基准前缀地址！ timeout: 3000, // 请求时长！&#125;);// 添加请求拦截器$axios.interceptors.request.use( function (config) &#123; return config; &#125;, function (error) &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;);// 添加响应拦截器$axios.interceptors.response.use( function (response) &#123; // 对数据进行处理 if (response.data.status == 1) &#123; return response.data.result; &#125; else &#123; alert(response.data.msg); &#125; &#125;, function (error) &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;);// 暴露axios实例！export default $axios; 创建api/index.js 文件，文件里面的为请求数据的方法，返回 promise 对象，可以让模板里面直接读取数据 // 导入axios实例import $axios from &#x27;@/utils/http&#x27;;import axios from &#x27;axios&#x27;; // 因为axios实例没有all方法，所以还是要导入axios// 获取首页相关数据export async function getIndex() &#123; let p1 = $axios.get(&#x27;/Index/favourite&#x27;); let p2 = $axios.get(&#x27;/Index/home&#x27;); return await axios.all([p1, p2]); // 返回promise对象&#125;// 获取商品列表export async function getList(data) &#123; return $axios.get(&#x27;Good/list&#x27;, &#123; params: data &#125;);&#125; 在组件中调用封装的业务请求方法 import &#123; getIndex, getList &#125; from &#x27;@/common/request&#x27;; // 导入数据请求方法export default &#123; // 要加上async 修饰符 async mounted() &#123; try &#123; this.indexdata = await getIndex(); this.list = await getList(&#123; page: 1, size: 10 &#125;); &#125; catch (err) &#123; console.log(&#x27;数据请求出错&#x27;); &#125; &#125;,&#125;; 五、vue-clivue 等单页面应用及其优缺点缺点： 不支持低版本的浏览器，最低只支持到 IE9；不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。 优点： 无刷新体验,提升了用户体验；前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；API 共享，同一套后端程序代码不用修改就可以用于 Web 界面、手机、平板等多种客户端用户体验好、快，内容的改变不需要重新加载整个页面。 vue-cli 如何安装 2.x 版本模板 查看 vue-cli 版本号 vue -V或者vue --version如果是vue不是内部活外部命令说明根本没有装脚手架 安装 vue-cli 最新脚手架 npm i @vue/cli -g // 全局安装脚手架 新脚手架创建项目 vue create 项目名 如何用新脚手架拉取老脚手架模板 安装 npm install -g @vue/cli-init 初始化项目 // vue-cli 2.x 初始化项目命令vue init webpack 项目名 启动项目 npm run devnpm start// 打包npm run build vue-cli2.x 如何配置 less安装模块 npm install less@3.9 less-loader@5.0.0 --save-dev // 注意版本号，这里写的版本号实测过没有问题，版本太高可能编译出错 vue-cli2.x 如何配置跨域然后config/index.js里 dev: &#123; ..., proxyTable: &#123; &#x27;/api&#x27;: &#123; //使用&quot;/api&quot;来代替 target: &#x27;http://xxxx:xx/xx&#x27;, //接口域名 changeOrigin:true, //改变源 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;&#x27; //路径重写 &#125; &#125;&#125; vue-cli2.x 如何进行打包配置 默认打包出来的 index.html 和静态资源文件是绝对路径关系，很多时候需要使用相对路径关系，方便部署！ 操作 config/index.js build/webpack.prod.conf.js build/utils.js 六、SSR七、其他vue 常用 UI 库有哪些vue 常用插件vue 项目如何实现权限管理 权限管理是基于 RBAC 完成的， 就是不同用户会有不同的角色，每个角色会有不同的菜单信息，从而决定了我们的用户能看到不同的菜单页面。 权限前后端都要做：后端是做接口访问权限，保证数据安全；前端做权限是保证用户访问到不同的页面，操作不同的功能。 前端如何做： 最核心的是让不同的用户有不同的路由映射表，也就觉得了他可以看到不同的页面，且不能访问他没有路由映射的页面。 代码逻辑： 登录成功之后，获取到 token，跳转到系统首页 导航守卫里面判断是否有角色信息， 如果没有就拉取用户信息，获取用户资料， 结束之后再去请求该用户所对应的的角色的 菜单（路由）列表信息。 有时候可能需要处理成路由映射的格式， 处理完成之后，通过 router.addRoutes方法添加到路由映射表里面。 这样就决定了不同的用户有不同的映射表，访问不同的页面。 如果是节点级别的权限管理，后端返回该用户所对应角色的所有可以操作的节点标识符，我们通过自定义指令实现判断这些标识符所对应的按钮是否可以显示。 说说你对 SPA 单页面的理解，它的优缺点分别是什么？是一种只需要将单个页面加载到服务器之中的 web 应用程序。当浏览器向服务器发出第一个请求时，服务器会返回一个 index.html 文件，它所需的 js，css 等会在显示时统一加载，部分页面按需加载。url 地址变化时不会向服务器在请求页面，通过路由才实现页面切换。 优点： 良好的交互体验，用户不需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示流畅； 良好的前后端工作分离模式。 缺点： SEO 难度较高，由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 首屏加载过慢（初次加载耗时多） SPA 单页面的实现方式有哪些？ 在 hash 模式中，在 window 上监听 hashchange(onhashChange) 事件（地址栏中 hash 变化触发）驱动界面变化； 在 history 模式中，在 window 上监听 popstate(onpopstate) 事件（浏览器的前进或后退按钮的点击触发）驱动界面变化，监听 a 链接点击事件用 history.pushState、history.replaceState 方法驱动界面变化；pushState、replaceState不会触发 popState 事件 直接在界面用显示隐藏事件驱动界面变化。 Vue 如何优化首页加载速度减少请求的次数 1.请求合并：将同一时间需要的 js 合并，目的是节省 dns 查找的时间 2.按需加载 1.单页应用下的按照路由的需要加载 2.缓存 3.css sprite base64 iconfont 4.cdn 托管 5.延迟加载：图片的延迟加载：（就是先不设置 img 的 src 属性，等合适的时机（比如滚动、滑动、出现在视窗内等）再把图片真实 url 放到 img 的 src 属性上。） js 的延迟加载： 减少量 1.精简代码（tree-shaking） (1)去除无用的代码 (2)规范些代码的方式 (3)外部 cdn 的引入 2.懒加载 —路由的懒加载 3.压缩 — （1）webpack 压缩 UglifyJsPlugin （2）gzip 压缩 (3)图片压缩、JPG 优化 4.缓存 http 代码：—浏览器的强缓存（max-age Etag）和协商(弱)缓存（last-modified） 5.第三方组件—第三方组件作为外部依赖使用，会被打爆进业务代码。 6.按需加载 — （1）第三方库和工具的按需加载，如 echarts （2）选择更优的工具 day.js 代替 moment （3）可用代码拆分（Code-splitting）只传送用户需要的代码 减少内存的消耗 1.减少全局变量； 2.减少全局组件； 3.减少 dom 操作， 减少 DOM 访问，使用事件代理 css 样式放在页面前面 延迟 js 加载 避免 CSS 表达式，避免@import","updated":"2025-08-02T05:46:04.178Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"diff算法","date":"2021-09-12T08:18:15.000Z","path":"2021/09/12/2021-09-12-diff-calculate/","text":"Diff 算法核心原理1、认识虚拟 DOM（Virtual DOM）没有 vue 之前我们都是用 js 和 jq，操作 DOM—&gt;视图更新 有了 vue，数据改变—&gt;生成虚拟 DOM（计算变更）—&gt;操作真实的 DOM—&gt;视图更新 真实 DOM： &lt;ul id=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;哈哈&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;呵呵&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;嘿嘿&lt;/li&gt;&lt;/ul&gt; 对应的虚拟 DOM 为： let oldVDOM = &#123; // 旧虚拟DOM tagName: &#x27;ul&#x27;, // 标签名 props: &#123; // 标签属性 id: &#x27;list&#x27; &#125;, children: [ // 标签子节点 &#123; tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;哈哈&#x27;] &#125;, &#123; tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;呵呵&#x27;] &#125;, &#123; tagName: &#x27;li&#x27;, props: &#123; class: &#x27;item&#x27; &#125;, children: [&#x27;嘿嘿&#x27;] &#125;, ]&#125; 虚拟 DOM 算法 = 虚拟 DOM + Diff 算法 好处：虚拟 DOM 算法操作真实 DOM，性能高于直接操作真实 DOM 2、什么是 Diff 算法 上图中，其实只有一个 li 标签修改了文本，其他都是不变的，所以没必要所有的节点都要更新，只更新这个 li 标签就行，Diff 算法就是查出这个 li 标签的算法。 总结：Diff 算法是一种对比算法。对比两者是旧虚拟DOM和新虚拟DOM，对比出是哪个虚拟节点更改了，找出这个虚拟节点，并只更新这个虚拟节点所对应的真实节点，而不用更新其他数据没发生改变的节点，实现精准地更新真实 DOM，进而提高效率。 3、Diff 算法的原理新旧虚拟 DOM 对比的时候，Diff 算法比较只会在同层级进行, 不会跨层级比较。 4、Diff 对比流程 当数据改变时，会触发setter，并且通过Dep.notify去通知所有订阅者Watcher，订阅者们就会调用patch方法 1、Data 通过 Observer 转换成了 getter/setter 的形式来追踪变化。 2、当外界通过 Watcher 读取数据时，会触发 getter 从而将 Watcher 添加到依赖中。 3、当数据发生了变化时，会触发 setter，从而 Dep 中的依赖（Watcher）发送通知。 4、Watcher 接收到通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能会触发用户返回的某个回调函数。 patch 方法对比当前同层的虚拟节点是否为同一种类型的标签： 是：继续执行patchVnode方法进行深层比对 否：没必要比对了，直接整个节点替换成新虚拟节点 patch的核心原理代码： function patch(oldVnode, newVnode) &#123; // 比较是否为一个类型的节点 if (sameVnode(oldVnode, newVnode)) &#123; // 是：继续进行深层比较 patchVnode(oldVnode, newVnode) &#125; else &#123; // 否 const oldEl = oldVnode.el // 旧虚拟节点的真实DOM节点 const parentEle = api.parentNode(oldEl) // 获取父节点 createEle(newVnode) // 创建新虚拟节点对应的真实DOM节点 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 // 设置null，释放内存 oldVnode = null &#125; &#125; return newVnode&#125; sameVnode 方法patch 关键的一步就是sameVnode方法判断是否为同一类型节点， sameVnode 方法的核心原理代码： function sameVnode(oldVnode, newVnode) &#123; return ( oldVnode.key === newVnode.key &amp;&amp; // key值是否一样 oldVnode.tagName === newVnode.tagName &amp;&amp; // 标签名是否一样 oldVnode.isComment === newVnode.isComment &amp;&amp; // 是否都为注释节点 isDef(oldVnode.data) === isDef(newVnode.data) &amp;&amp; // 是否都定义了data sameInputType(oldVnode, newVnode) // 当标签为input时，type必须是否相同 )&#125; patchVnode 方法这个函数做了以下事情： 找到对应的真实DOM，称为el 判断newVnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为newVnode的文本节点。 如果oldVnode有子节点而newVnode没有，则删除el的子节点 如果oldVnode没有子节点而newVnode有，则将newVnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 function patchVnode(oldVnode, newVnode) &#123; const el = newVnode.el = oldVnode.el // 获取真实DOM对象 // 获取新旧虚拟节点的子节点数组 const oldCh = oldVnode.children, newCh = newVnode.children // 如果新旧虚拟节点是同一个对象，则终止 if (oldVnode === newVnode) return // 如果新旧虚拟节点是文本节点，且文本不一样 if (oldVnode.text !== null &amp;&amp; newVnode.text !== null &amp;&amp; oldVnode.text !== newVnode.text) &#123; // 则直接将真实DOM中文本更新为新虚拟节点的文本 api.setTextContent(el, newVnode.text) &#125; else &#123; // 否则 if (oldCh &amp;&amp; newCh &amp;&amp; oldCh !== newCh) &#123; // 新旧虚拟节点都有子节点，且子节点不一样 // 对比子节点，并更新 updateChildren(el, oldCh, newCh) &#125; else if (newCh) &#123; // 新虚拟节点有子节点，旧虚拟节点没有 // 创建新虚拟节点的子节点，并更新到真实DOM上去 createEle(newVnode) &#125; else if (oldCh) &#123; // 旧虚拟节点有子节点，新虚拟节点没有 //直接删除真实DOM里对应的子节点 api.removeChild(el) &#125; &#125;&#125; updateChildren 方法updateChildren 的核心原理代码： function updateChildren(parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; oldStartVnode = oldCh[++oldStartIdx] &#125; else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125; else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125; else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125; else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125; else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125; 首尾指针法： 会进行互相进行比较，总共有五种比较情况： 1、oldS 和 newS 使用sameVnode方法进行比较，sameVnode(oldS, newS) 2、oldS 和 newE 使用sameVnode方法进行比较，sameVnode(oldS, newE) 3、oldE 和 newS 使用sameVnode方法进行比较，sameVnode(oldE, newS) 4、oldE 和 newE 使用sameVnode方法进行比较，sameVnode(oldE, newE) 5、如果以上逻辑都匹配不到，再把所有旧子节点的 key 做一个映射到旧节点下标的 key -&gt; index 表，然后用新 vnode 的 key 去找出在旧节点中可以复用的位置。 图例比较： 第一步：oldS 和 newE 相等，需要把节点a移动到newE所对应的位置，也就是末尾 第二步：oldS 和 newS相等，需要把节点b移动到newS所对应的位置 第三步：oldS、oldE 和 newS相等，需要把节点c移动到newS所对应的位置 第四步：oldCh先遍历完成了，而newCh还没遍历完，说明newCh比oldCh多，所以需要将多出来的节点，插入到真实 DOM 上对应的位置上 如果oldCh比newCh多的话，那就是newCh先走完循环，然后oldCh会有多出的节点，结果会在真实 DOM 里进行删除这些旧节点。5、为什么不建议用 index 作为循环项的 key a，b，c三个li标签都是复用之前的，因为他们三个根本没改变，改变的只是前面新增了一个林三心 在进行子节点的 diff算法 过程中，会进行 旧首节点和新首节点的sameNode对比，这一步命中了逻辑，因为现在新旧两次首部节点 的 key 都是 0了，同理，key 为 1 和 2 的也是命中了逻辑，导致相同key的节点会去进行patchVnode更新文本，而原本就有的c节点，却因为之前没有 key 为 4 的节点，而被当做了新节点，所以使用 index 做 key，最后新增的居然是本来就已有的 c 节点。所以前三个都进行patchVnode更新文本，最后一个进行了新增，那就解释了为什么所有 li 标签都更新了。 我们只要使用一个独一无二的值 id 来当做 key 就行了。","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"},{"name":"react","slug":"react","permalink":"https://luckyship.github.io/tags/react/"}]},{"title":"剖析commonjs与es module","date":"2021-09-05T01:12:00.000Z","path":"2021/09/05/2021-09-05-commonjs-es-module/","text":"前言今天我们来深度分析一下 Commonjs 和 Es Module，希望通过本文的学习，能够让大家彻底明白 Commonjs 和 Es Module 原理，能够一次性搞定面试中遇到的大部分有关 Commonjs 和 Es Module 的问题。 老规矩我们带上疑问开始今天的分析 🤔🤔🤔： Commonjs 和 Es Module 有什么区别 ？ Commonjs 如何解决的循环引用问题 ？ 既然有了 exports，为何又出了 module.exports? 既生瑜，何生亮 ？ require 模块查找机制 ？ Es Module 如何解决循环引用问题 ？ exports = &#123;&#125; 这种写法为何无效 ？ 关于 import() 的动态引入 ？ Es Module 如何改变模块下的私有变量 ？ … 模块化早期 JavaScript 开发很容易存在全局污染和依赖管理混乱问题。这些问题在多人开发前端应用的情况下变得更加棘手。我这里例举一个很常见的场景： &lt;body&gt; &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./home.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./list.js&quot;&gt;&lt;/script&gt;&lt;/body&gt; 如上在没有模块化的前提下，如果在 html 中这么写，那么就会暴露一系列问题。 全局污染没有模块化，那么 script 内部的变量是可以相互污染的。比如有一种场景，如上 ./index.js 文件和 ./list.js 文件为小 A 开发的，./home.js 为小 B 开发的。 小 A 在 index.js中声明 name 属性是一个字符串。 var name = &quot;我不是外星人&quot;; 然后小 A 在 list.js 中，引用 name 属性， console.log(name); // ƒ name()&#123;&#125; 打印却发现 name 竟然变成了一个函数。刚开始小 A 不知所措，后来发现在小 B 开发的 home.js 文件中这么写道： function name() &#123; //...&#125; 而且这个 name 方法被引用了多次，导致一系列的连锁反应。 上述例子就是没有使用模块化开发，造成的全局污染的问题，每个加载的 js 文件都共享变量。当然在实际的项目开发中，可以使用匿名函数自执行的方式，形成独立的块级作用域解决这个问题。 只需要在 home.js 中这么写道： (function () &#123; function name() &#123; //... &#125;&#125;)(); 这样小 A 就能正常在 list.js 中获取 name 属性。但是这只是一个 demo ，我们不能保证在实际开发中情况会更加复杂。所以不使用模块开发会暴露出很多风险。 所以就需要模块化来解决上述的问题，今天我们就重点讲解一下前端模块化的两个重要方案：Commonjs 和 Es Module CommonjsCommonjs 的提出，弥补 Javascript 对于模块化，没有统一标准的缺陷。nodejs 借鉴了 Commonjs 的 Module ，实现了良好的模块化管理。 目前 commonjs 广泛应用于以下几个场景： Node 是 CommonJS 在服务器端一个具有代表性的实现； Browserify 是 CommonJS 在浏览器中的一种实现； webpack 打包工具对 CommonJS 的支持和转换；也就是前端应用也可以在编译之前，尽情使用CommonJS 进行开发。 commonjs 使用与原理在使用 规范下，有几个显著的特点。 在 commonjs 中每一个 js 文件都是一个单独的模块，我们可以称之为 module； 该模块中，包含 CommonJS 规范的核心变量: exports、module.exports、require； exports 和 module.exports 可以负责对模块中的内容进行导出； require 函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容； commonjs 使用初体验我们先尝试这导出一个模块：hello.js中 let name = &quot;aaa&quot;;module.exports = function sayName() &#123; return name;&#125;; 导入：接下来简单的导入： home.js const sayName = require(&quot;./hello.js&quot;);module.exports = function say() &#123; return &#123; name: sayName(), author: &quot;我不是外星人&quot;, &#125;;&#125;; 如上就是 Commonjs 最简单的实现，那么暴露出两个问题： 如何解决变量污染的问题。 module.exports，exports，require 三者是如何工作的？又有什么关系？ commonjs 实现原理首先从上述得知每个模块文件上存在 module，exports，require 三个变量，然而这三个变量是没有被定义的，但是我们可以在 Commonjs 规范下每一个 js 模块上直接使用它们。在 nodejs 中还存在 **filename 和 **dirname 变量。 如上每一个变量代表什么意思呢： module 记录当前模块信息。 require 引入模块的方法。 exports 当前模块导出的属性 在编译的过程中，实际 Commonjs 对 js 的代码块进行了首尾包装， 我们以上述的 home.js 为例子 🌰，它被包装之后的样子如下： (function (exports, require, module, __filename, __dirname) &#123; const sayName = require(&quot;./hello.js&quot;); module.exports = function say() &#123; return &#123; name: sayName(), author: &quot;我不是外星人&quot;, &#125;; &#125;;&#125;); 在 Commonjs 规范下模块中，会形成一个包装函数，我们写的代码将作为包装函数的执行上下文，使用的 require ，exports ，module 本质上是通过形参的方式传递到包装函数中的。 那么包装函数本质上是什么样子的呢？ function wrapper(script) &#123; return &quot;(function (exports, require, module, __filename, __dirname) &#123;&quot; + script + &quot;\\n&#125;)&quot;;&#125; 包装函数执行。 const modulefunction = wrapper(` const sayName = require(&#x27;./hello.js&#x27;) module.exports = function say()&#123; return &#123; name:sayName(), author:&#x27;我不是外星人&#x27; &#125; &#125;`); 如上模拟了一个包装函数功能， script 为我们在 js 模块中写的内容，最后返回的就是如上包装之后的函数。当然这个函数暂且是一个字符串。 runInThisContext(modulefunction)(module.exports, require, module, __filename, __dirname); 在模块加载的时候，会通过 runInThisContext (可以理解成 eval ) 执行 modulefunction ，传入require ，exports ，module 等参数。最终我们写的 nodejs 文件就这么执行了。 到此为止，完成了整个模块执行的原理。接下来我们来分析以下 require 文件加载的流程。 require 文件加载流程上述说了 commonjs 规范大致的实现原理，接下来我们分析一下， require 如何进行文件的加载的。 我们还是以 nodejs 为参考，比如如下代码片段中： const fs = require(&quot;fs&quot;); // ①核心模块const sayName = require(&quot;./hello.js&quot;); //② 文件模块const crypto = require(&quot;crypto-js&quot;); // ③第三方自定义模块 如上代码片段中： ① 为 nodejs 底层的核心模块。 ② 为我们编写的文件模块，比如上述 sayName ③ 为我们通过 npm 下载的第三方自定义模块，比如 crypto-js。 当 require 方法执行的时候，接收的唯一参数作为一个标识符 ，Commonjs 下对不同的标识符，处理流程不同，但是目的相同，都是找到对应的模块。 require 加载标识符原则首先我们看一下 nodejs 中对标识符的处理原则。 首先像 fs ，http ，path 等标识符，会被作为 nodejs 的核心模块。 ./ 和 ../ 作为相对路径的文件模块， / 作为绝对路径的文件模块。 非路径形式也非核心模块的模块，将作为自定义模块。 核心模块的处理：核心模块的优先级仅次于缓存加载，在 Node 源码编译中，已被编译成二进制代码，所以加载核心模块，加载过程中速度最快。 路径形式的文件模块处理：已 ./ ，../ 和 / 开始的标识符，会被当作文件模块处理。require() 方法会将路径转换成真实路径，并以真实路径作为索引，将编译后的结果缓存起来，第二次加载的时候会更快。至于怎么缓存的？我们稍后会讲到。 自定义模块处理：自定义模块，一般指的是非核心的模块，它可能是一个文件或者一个包，它的查找会遵循以下原则： 在当前目录下的 node_modules 目录查找。 如果没有，在父级目录的 node_modules 查找，如果没有在父级目录的父级目录的 node_modules 中查- 找。 沿着路径向上递归，直到根目录下的 node_modules 目录。 在查找过程中，会找 package.json 下 main 属性指向的文件，如果没有 package.json ，在 node 环境下会以此查找 index.js ，index.json ，index.node。 require 模块引入与处理CommonJS 模块同步加载并执行模块文件，CommonJS 模块在执行阶段分析模块依赖，采用深度优先遍历（depth-first traversal），执行顺序是父 -&gt; 子 -&gt; 父； 为了搞清除 require 文件引入流程。我们接下来再举一个例子，这里注意一下细节： a.js文件 const getMes = require(&quot;./b&quot;);console.log(&quot;我是 a 文件&quot;);exports.say = function () &#123; const message = getMes(); console.log(message);&#125;; b.js文件 const say = require(&quot;./a&quot;);const object = &#123; name: &quot;aaaa&quot;, author: &quot;我不是外星人&quot;,&#125;;console.log(&quot;我是 b 文件&quot;);module.exports = function () &#123; return object;&#125;; 主文件main.js const a = require(&quot;./a&quot;);const b = require(&quot;./b&quot;);console.log(&quot;node 入口文件&quot;); 接下来终端输入 node main.js 运行 main.js，效果如下： $ node main.js我是 b 文件我是 a 文件node 入口文件 从上面的运行结果可以得出以下结论： main.js 和 a.js 模块都引用了 b.js 模块，但是 b.js 模块只执行了一次。a.js 模块 和 b.js 模块互相引用，但是没有造成循环引用的情况。执行顺序是父 -&gt; 子 -&gt; 父；那么 Common.js 规范是如何实现上述效果的呢？ require 加载原理首先为了弄清楚上述两个问题。我们要明白两个感念，那就是 module 和 Module。 module ：在 Node 中每一个 js 文件都是一个 module ，module 上保存了 exports 等信息之外，还有一个 loaded 表示该模块是否被加载。 为 false 表示还没有加载；为 true 表示已经加载Module ：以 nodejs 为例，整个系统运行之后，会用 Module 缓存每一个模块加载的信息。 require 的源码大致长如下的样子： // id 为路径标识符function require(id) &#123; /* 查找 Module 上有没有已经加载的 js 对象*/ const cachedModule = Module._cache[id] /* 如果已经加载了那么直接取走缓存的 exports 对象 */ if(cachedModule)&#123; return cachedModule.exports &#125; /* 创建当前模块的 module */ const module = &#123; exports: &#123;&#125; ,loaded: false , ...&#125; /* 将 module 缓存到 Module 的缓存属性中，路径标识符作为 id */ Module._cache[id] = module /* 加载文件 */ runInThisContext(wrapper(&#x27;module.exports = &quot;123&quot;&#x27;))(module.exports, require, module, __filename, __dirname) /* 加载完成 *// module.loaded = true /* 返回值 */ return module.exports&#125; 从上面我们总结出一次 require 大致流程是这样的； require 会接收一个参数——文件标识符，然后分析定位文件，分析过程我们上述已经讲到了，加下来会从 Module 上查找有没有缓存，如果有缓存，那么直接返回缓存的内容。 如果没有缓存，会创建一个 module 对象，缓存到 Module 上，然后执行文件，加载完文件，将 loaded 属性设置为 true ，然后返回 module.exports 对象。借此完成模块加载流程。 模块导出就是 return 这个变量的其实跟 a = b 赋值一样， 基本类型导出的是值， 引用类型导出的是引用地址。 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports， 所以对 exports 进行赋值会导致 exports 操作的不再是 module.exports 的引用。 require 避免重复加载从上面我们可以直接得出，require 如何避免重复加载的，首先加载之后的文件的 module 会被缓存到 Module 上，比如一个模块已经 require 引入了 a 模块，如果另外一个模块再次引用 a ，那么会直接读取缓存值 module ，所以无需再次执行模块。 对应 demo 片段中，首先 main.js 引用了 a.js ，a.js 中 require 了 b.js 此时 b.js 的 module 放入缓存 Module 中，接下来 main.js 再次引用 b.js ，那么直接走的缓存逻辑。所以 b.js 只会执行一次，也就是在 a.js 引入的时候。 require 避免循环引用那么接下来这个循环引用问题，也就很容易解决了。为了让大家更清晰明白，那么我们接下来一起分析整个流程。 ① 首先执行 node main.js ，那么开始执行第一行 require(a.js)； ② 那么首先判断 a.js 有没有缓存，因为没有缓存，先加入缓存，然后执行文件 a.js （需要注意 是先加入缓存， 后执行模块内- 容）; ③ a.js 中执行第一行，引用 b.js。 ④ 那么判断 b.js 有没有缓存，因为没有缓存，所以加入缓存，然后执行 b.js 文件。 ⑤ b.js 执行第一行，再一次循环引用 require(a.js) 此时的 a.js 已经加入缓存，直接读取值。接下来打印 console.log(&#39;我- 是 b 文件&#39;)，导出方法。 ⑥ b.js 执行完毕，回到 a.js 文件，打印 console.log(&#39;我是 a 文件&#39;)，导出方法。 ⑦ 最后回到 main.js，打印 console.log(&#39;node 入口文件&#39;) 完成这个流程。不过这里我们要注意问题： 如上第 ⑤ 的时候，当执行 b.js 模块的时候，因为 a.js 还没有导出 say 方法，所以 b.js 同步上下文中，获取不到 say。 为了进一步验证上面所说的，我们改造一下 b.js 如下: const say = require(&quot;./a&quot;);const object = &#123; name: &quot;aaa&quot;, author: &quot;我不是外星人&quot;,&#125;;console.log(&quot;我是 b 文件&quot;);console.log(&quot;打印 a 模块&quot;, say);setTimeout(() =&gt; &#123; console.log(&quot;异步打印 a 模块&quot;, say);&#125;, 0);module.exports = function () &#123; return object;&#125;; 打印结果： $ node main.js我是 b 文件打印 a 模块我是 a 文件node 入口文件异步打印 a 模块 第一次打印 say 为空对象。 第二次打印 say 才看到 b.js 导出的方法。 那么如何获取到 say 呢，有两种办法： 一是用动态加载 a.js 的方法，马上就会讲到。 二个就是如上放在异步中加载。 我们注意到 a.js 是用 exports.say 方式导出的，如果a.js用 module.exports 结果会有所不同。至于有什么不同，为什么？我接下来会讲到。 require 动态加载上述我们讲了 require 查找文件和加载流程。接下来介绍 commonjs 规范下的 require 的另外一个特性——动态加载。 require 可以在任意的上下文，动态加载模块。我对上述 a.js 修改。 a.js console.log(&quot;我是 a 文件&quot;);exports.say = function () &#123; const getMes = require(&quot;./b&quot;); const message = getMes(); console.log(message);&#125;; main.js const a = require(&quot;./a&quot;);a.say(); 如上在 a.js 模块的 say 函数中，用 require 动态加载 b.js 模块。然后执行在 main.js 中执行 a.js 模块的 say 方法。 打印结果如下： $ node main.js&#123; name: &#x27;aaa&#x27;, author: &#x27;我不是外星人&#x27; &#125; exports 就是传入到当前模块内的一个对象，本质上就是 module.exports。 问题：为什么 exports=&#123;&#125; 直接赋值一个对象就不可以呢？ 比如我们将如上 a.js 修改一下： exports = &#123; name: &quot;asd&quot;, author: &quot;我不是外星人&quot;, say() &#123; console.log(666); &#125;,&#125;; 打印结果： $ node main.js&#123;&#125; 理想情况下是通过 exports = &#123;&#125; 直接赋值，不需要在 exports.a = xxx 每一个属性，但是如上我们看到了这种方式是无效的。为什么会这样？实际这个是 js 本身的特性决定的。 通过上述讲解都知道 exports ， module 和 require 作为形参的方式传入到 js 模块中。我们直接 exports = &#123;&#125; 修改 exports ，等于重新赋值了形参，那么会重新赋值一份，但是不会在引用原来的形参。举一个简单的例子 function wrap(myExports) &#123; myExports = &#123; name: &quot;我不是外星人&quot;, &#125;;&#125;let myExports = &#123; name: &quot;alien&quot;,&#125;;wrap(myExports);console.log(myExports); 打印： $ node main.js&#123; name: &#x27;alien&#x27; &#125; 我们期望修改 myExports ，但是没有任何作用。 假设 wrap 就是 Commonjs 规范下的包装函数，我们的 js 代码就是包装函数内部的内容。当我们把 myExports 对象传进去，但是直接赋值 myExports = &#123; name:&#39;我不是外星人&#39; &#125; 没有任何作用，相等于内部重新声明一份 myExports 而和外界的 myExports 断绝了关系。所以解释了为什么不能 exports=&#123;...&#125; 直接赋值。 那么解决上述也容易，只需要函数中像 exports.name 这么写就可以了。 function wrap(myExports) &#123; myExports.name = &quot;我不是外星人&quot;;&#125; 打印: $ node main.js&#123; name: &#x27;我不是外星人&#x27; &#125; module.exports 使用module.exports 本质上就是 exports ，我们用 module.exports 来实现如上的导出。 module.exports = &#123; name: &quot;aaa&quot;, author: &quot;我不是外星人&quot;, say() &#123; console.log(666); &#125;,&#125;; module.exports 也可以单独导出一个函数或者一个类。比如如下： module.exports = function () &#123; // ...&#125;; 从上述 require 原理实现中，我们知道了 exports 和 module.exports 持有相同引用，因为最后导出的是 module.exports 。那么这就说明在一个文件中，我们最好选择 exports 和 module.exports 两者之一，如果两者同时存在，很可能会造成覆盖的情况发生。比如如下情况： exports.name = &quot;alien&quot;; // 此时 exports.name 是无效的module.exports = &#123; name: &quot;aaa&quot;, author: &quot;我不是外星人&quot;, say() &#123; console.log(666); &#125;,&#125;; 上述情况下 exports.name 无效，会被 module.exports 覆盖。 Q &amp; A1 那么问题来了？既然有了 exports，为何又出了 module.exports? 答：如果我们不想在 commonjs 中导出对象，而是只导出一个类或者一个函数再或者其他属性的情况，那么 module.exports 就更方便了，如上我们知道 exports 会被初始化成一个对象，也就是我们只能在对象上绑定属性，但是我们可以通过 module.exports 自定义导出出对象外的其他类型元素。 let a = 1;module.exports = a; // 导出函数module.exports = [1, 2, 3]; // 导出数组module.exports = function () &#123;&#125;; //导出方法 2 与 exports 相比，module.exports 有什么缺陷 ？ 答：module.exports 当导出一些函数等非对象属性的时候，也有一些风险，就比如循环引用的情况下。对象会保留相同的内存地址，就算一些属性是后绑定的，也能间接通过异步形式访问到。但是如果 module.exports 为一个非对象其他属性类型，在循环引用的时候，就容易造成属性丢失的情况发生了。 Es ModuleNodejs 借鉴了 Commonjs 实现了模块化 ，从 ES6 开始， JavaScript 才真正意义上有自己的模块化规范， Es Module 的产生有很多优势，比如: 借助 Es Module 的静态导入导出的优势，实现了 tree shaking。 Es Module 还可以 import() 懒加载方式实现代码分割。 在 Es Module 中用 export 用来导出模块，import 用来导入模块。但是 export 配合 import 会有很多种组合情况，接下来我们逐一分析一下。 导出 export 和导入 import所有通过 export 导出的属性，在 import 中可以通过结构的方式，解构出来。 export 正常导出，import 导入导出模块：a.js const name = &quot;aaa&quot;;const author = &quot;我不是外星人&quot;;export &#123; name, author &#125;;export const say = function () &#123; console.log(&quot;hello , world&quot;);&#125;; 导入模块：main.js // name , author , say 对应 a.js 中的 name , author , sayimport &#123; name, author, say &#125; from &quot;./a.js&quot;; export &#123; &#125;， 与变量名绑定，命名导出。 import &#123; &#125; from &#39;module&#39;， 导入 module 的命名导出 ，module 为如上的 ./a.js 这种情况下 import &#123; &#125; 内部的变量名称，要与 export &#123; &#125; 完全匹配。 默认导出 export default导出模块：a.js const name = &quot;aaa&quot;;const author = &quot;我不是外星人&quot;;const say = function () &#123; console.log(&quot;hello , world&quot;);&#125;;export default &#123; name, author, say,&#125;; 导入模块：main.js import mes from &quot;./a.js&quot;;console.log(mes); //&#123; name: &#x27;aaa&#x27;,author:&#x27;我不是外星人&#x27;, say:Function &#125; export default anything 导入 module 的默认导出。anything 可以是函数，属性方法，或者对象。 对于引入默认导出的模块，import anyName from &#39;module&#39;， anyName 可以是自定义名称。 混合导入｜导出ES6 module 可以使用 export default 和 export 导入多个属性。 导出模块：a.js export const name = &quot;aaa&quot;;export const author = &quot;我不是外星人&quot;;export default function say() &#123; console.log(&quot;hello , world&quot;);&#125; 导入模块：main.js 中有几种导入方式： 第一种： import theSay, &#123; name, author as bookAuthor &#125; from &quot;./a.js&quot;;console.log( theSay, // ƒ say() &#123;console.log(&#x27;hello , world&#x27;) &#125; name, // &quot;aaa&quot; bookAuthor // &quot;我不是外星人&quot;); 第二种： import theSay, * as mes from &quot;./a&quot;;console.log( theSay, // ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125; mes // &#123; name:&#x27;aaa&#x27; , author: &quot;我不是外星人&quot; ，default: ƒ say() &#123; console.log(&#x27;hello , world&#x27;) &#125; &#125;); 导出的属性被合并到 mes 属性上， export 被导入到对应的属性上，export default 导出内容被绑定到 default 属性上。theSay 也可以作为被 export default 导出属性。 重属名导入import &#123; bookName as name, say, bookAuthor as author &#125; from &quot;module&quot;;console.log(bookName, bookAuthor, say); //aaa 我不是外星人 从 module 模块中引入 name ，并重命名为 bookName ，从 module 模块中引入 author ，并重命名为 bookAuthor。然后在当前模块下，使用被重命名的名字。 重定向导出可以把当前模块作为一个中转站，一方面引入 module 内的属性，然后把属性再给导出去。 export * from &#x27;module&#x27; // 第一种方式export &#123; name, author, ..., say &#125; from &#x27;module&#x27; // 第二种方式export &#123; bookName as name, bookAuthor as author, ..., say &#125; from &#x27;module&#x27; //第三种方式 第一种方式：重定向导出 module 中的所有导出属性， 但是不包括 module 内的 default 属性。 第二种方式：从 module 中导入 name ，author ，say 再以相同的属性名，导出。 第三种方式：从 module 中导入 name ，重属名为 bookName 导出，从 module 中导入 author ，重属名为 bookAuthor 导出，正常导出 say 。 无需导入模块，只运行模块import &quot;module&quot;; 执行 module 不导出值 多次调用 module 只运行一次。 动态导入const promise = import(&quot;module&quot;); import(&#39;module&#39;)，动态导入返回一个 Promise。为了支持这种方式，需要在 webpack 中做相应的配置处理。 ES6 module 特性接下来我们重点分析一下 ES6 module 一些重要特性。 1 静态语法ES6 module 的引入和导出是静态的，import 会自动提升到代码的顶层 ，import , export 不能放在块级作用域或条件语句中。🙅 错误写法一： function say() &#123; import name from &quot;./a.js&quot;; export const author = &quot;我不是外星人&quot;;&#125; 🙅 错误写法二： isexport &amp;&amp; export const name = &#x27;aaa&#x27; 这种静态语法，在编译过程中确定了导入和导出的关系，所以更方便去查找依赖，更方便去 tree shaking (摇树) ， 可以使用 lint 工具对模块依赖进行检查，可以对导入导出加上类型信息进行静态的类型检查。 import 的导入名不能为字符串或在判断语句，下面代码是错误的 🙅 错误写法三： import &#x27;defaultExport&#x27; from &#x27;module&#x27;let name = &#x27;Export&#x27;import &#x27;default&#x27; + name from &#x27;module&#x27; 2 执行特性ES6 module 和 Common.js 一样，对于相同的 js 文件，会保存静态属性。 但是与 Common.js 不同的是 ，CommonJS 模块同步加载并执行模块文件，ES6 模块提前加载并执行模块文件，ES6 模块在预处理阶段分析模块依赖，在执行阶段执行模块，两个阶段都采用深度优先遍历，执行顺序是子 -&gt; 父。 为了验证这一点，看一下如下 demo。main.js console.log(&quot;main.js开始执行&quot;);import say from &quot;./a&quot;;import say1 from &quot;./b&quot;;console.log(&quot;main.js执行完毕&quot;); a.js import b from &quot;./b&quot;;console.log(&quot;a模块加载&quot;);export default function say() &#123; console.log(&quot;hello , world&quot;);&#125; b.js console.log(&quot;b模块加载&quot;);export default function sayhello() &#123; console.log(&quot;hello,world&quot;);&#125; main.js 和 a.js 都引用了 b.js 模块，但是 b 模块也只加载了一次。执行顺序是子 -&gt; 父 效果如下： b模块加载a模块加载main.js开始执行main.js执行完毕 3 导出绑定不能修改 import 导入的属性 a.js export let num = 1;export const addNumber = () =&gt; &#123; num++;&#125;; main.js中 import &#123; num, addNumber &#125; from &quot;./a&quot;;num = 2; 如果直接修改，那么会报错。如下所示： Uncaught Error: &quot;num&quot; is read-only. 属性绑定所以可以在 main.js 中这么修改。 import &#123; num, addNumber &#125; from &quot;./a&quot;;console.log(num); // num = 1addNumber();console.log(num); // num = 2 如上属性 num 的导入是绑定的。 接下来对 import 属性作出总结： 使用 import 被导入的模块运行在严格模式下。 使用 import 被导入的变量是只读的，可以理解默认为 const 装饰，无法被赋值 使用 import 被导入的变量是与原变量绑定/引用的，可以理解为 import 导入的变量无论是否为基本类型都是引用传递。 import() 动态引入import() 返回一个 Promise 对象， 返回的 Promise 的 then 成功回调中，可以获取模块的加载成功信息。我们来简单看一下 import() 是如何使用的。 main.js setTimeout(() =&gt; &#123; const result = import(&quot;./b&quot;); result.then((res) =&gt; &#123; console.log(res); &#125;);&#125;, 0); b.js export const name = &quot;alien&quot;;export default function sayhello() &#123; console.log(&quot;hello,world&quot;);&#125; 打印如下： &#123; default: f sayhello() name: &#x27;alien&#x27; _esModule: true&#125; 从打印结果可以看出 import()的基本特性。 import() 可以动态使用，加载模块。 import() 返回一个 Promise ，成功回调 then 中可以获取模块对应的信息。name 对应 name 属性， default 代表 export default 。__esModule 为 es module 的标识。 import() 可以做一些什么动态加载首先 import() 动态加载一些内容，可以放在条件语句或者函数执行上下文中。 if (isRequire) &#123; const result = import(&quot;./b&quot;);&#125; 懒加载import() 可以实现懒加载，举个例子 vue 中的路由懒加载； [ &#123; path: &quot;home&quot;, name: &quot;首页&quot;, component: () =&gt; import(&quot;./home&quot;), &#125;,]; React 中动态加载const LazyComponent = React.lazy(() =&gt; import(&quot;./text&quot;));class index extends React.Component &#123; render() &#123; return ( &lt;React.Suspense fallback=&#123; &lt;div className=&quot;icon&quot;&gt; &lt;SyncOutlinespin /&gt; &lt;/div&gt; &#125; &gt; &lt;LazyComponent /&gt; &lt;/React.Suspense&gt; ); &#125;&#125; React.lazy 和 Suspense 配合一起用，能够有动态加载组件的效果。React.lazy 接受一个函数，这个函数需要动态调用 import() 。 import() 这种加载效果，可以很轻松的实现代码分割。避免一次性加载大量 js 文件，造成首次加载白屏时间过长的情况。 tree shaking 实现Tree Shaking 在 Webpack 中的实现，是用来尽可能的删除没有被使用过的代码，一些被 import 了但其实没有被使用的代码。比如以下场景： a.js： export let num = 1;export const addNumber = () =&gt; &#123; num++;&#125;;export const delNumber = () =&gt; &#123; num--;&#125;; main.js： import &#123; addNumber &#125; from &quot;./a&quot;;addNumber(); 如上 a.js 中暴露两个方法，addNumber 和 delNumber，但是整个应用中，只用到了 addNumber，那么构建打包的时候，delNumber 将作为没有引用的方法，不被打包进来。 Commonjs 和 Es Module 总结接下来贯穿全文，讲一下 Commonjs 和 Es Module 的特性。 Commonjs 总结Commonjs 的特性如下： CommonJS 模块由 JS 运行时实现。 CommonJs 是单个值导出，本质上导出的就是 exports 属性。 CommonJS 是可以动态加载的，对每一个加载都存在缓存，可以有效的解决循环引用问题。 CommonJS 模块同步加载并执行模块文件。 es module 总结Es module 的特性如下： ES6 Module 静态的，不能放在块级作用域内，代码发生在编译时。 ES6 Module 的值是动态绑定的，可以通过导出方法修改，可以直接访问修改结果。 ES6 Module 可以导出多个属性和方法，可以单个导入导出，混合导入导出。 ES6 模块提前加载并执行模块文件， ES6 Module 导入模块在严格模式下。 ES6 Module 的特性可以很容易实现 Tree Shaking 和 Code Splitting。 转载Commonjs 和 Es Module 区别","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"前端缓存","date":"2021-08-29T07:25:04.000Z","path":"2021/08/29/2021-08-29-http-cache/","text":"缓存，这是一个老生常谈的话题，也常被作为前端面试的一个知识点。 本文，重点在与探讨在实际项目中，如何进行缓存的设置，并给出一个较为合理的方案。 在介绍缓存的时候，我们习惯将缓存分为强缓存和协商缓存两种。两者的主要区别是使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。顾名思义，协商缓存，就是需要和服务器进行协商，最终确定是否使用本地缓存。 强缓存我们知道，强缓存主要是通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制。Expire 是 HTTP1.0 标准下的字段，在这里我们可以忽略。我们重点来讨论的 Cache-Control 这个字段。 一般，我们会设置 Cache-Control 的值为 “public, max-age=xxx”，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。 显而易见，如果在 xxx 秒内，服务器上面的资源更新了，客户端在没有强制刷新的情况下，看到的内容还是旧的。如果说你不着急，可以接受这样的，那是不是完美？然而，很多时候不是你想的那么简单的，如果发布新版本的时候，后台接口也同步更新了，那就 gg 了。有缓存的用户还在使用旧接口，而那个接口已经被后台干掉了。怎么办？ 协商缓存协商缓存最大的问题就是每次都要向服务器验证一下缓存的有效性，似乎看起来很省事，不管那么多，你都要问一下我是否有效。但是，对于一个有追求的码农，这是不能接受的。每次都去请求服务器，那要缓存还有什么意义。 实践缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 在更新版本之后，如何让用户第一时间使用最新的资源文件呢？机智的前端们想出了一个方法，在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。 伟大的 webpack 可以让我们在打包的时候，在文件的命名上带上 hash 值。 output:&#123; path:path.join(__dirname,./dist ), publicPath:/dist/, filname:bundle.[chunkhash].js&#125; 综上所述，我们可以得出一个较为合理的缓存方案： HTML：使用协商缓存。 CSS&amp;JS&amp;图片：使用强缓存，文件命名带上 hash 值。 哈希也有讲究webpack 给我们提供了三种哈希值计算方式，分别是 hash、chunkhash 和 contenthash。那么这三者有什么区别呢？ hash：跟整个项目的构建相关，构建生成的文件 hash 值都是一样的，只要项目里有文件更改，整个项目构建的 hash 值都会更改。 chunkhash：根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的 hash 值。 contenthash：由文件内容产生的 hash 值，内容不同产生的 contenthash 值也不一样。 显然，我们是不会使用第一种的。改了一个文件，打包之后，其他文件的 hash 都变了，缓存自然都失效了。这不是我们想要的。 那 chunkhash 和 contenthash 的主要应用场景是什么呢？ 在实际在项目中，我们一般会把项目中的 css 都抽离出对应的 css 文件来加以引用。如果我们使用 chunkhash，当我们改了 css 代码之后，会发现 css 文件 hash 值改变的同时，js 文件的 hash 值也会改变。这时候，contenthash 就派上用场了。 ETag 计算Nginx 官方默认的 ETag 计算方式是为”文件最后修改时间 16 进制-文件长度 16 进制”。 例：ETag：“59e72c84-2404” ETag 的用处HTTP1.1 用 ETag 来判断请求的文件是否被修改，主要为了解决 Last-Modified 无法解决的一些问题 1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候并不希望客户端认为这个文件被修改了重新 GET; 2、某些文件修改非常频繁，1 秒内修改了 N 次，If-Modified-Since 能检查到的粒度是秒级的，这种修改无法判断 3、某些服务器不能精确的得到文件的最后修改时间； 为此，HTTP1.1 引入了 ETag.但标准并没有规定 ETag 的内容是什么或者说要怎么实现，唯一规定的是 ETag 需要放在双引号内。ETag 由服务器端生成，客户端通过 If-Match 或者说 If-None-Match 这个条件判断请求来验证资源是否修改。我们常见的是使用 If-None-Match.请求一个文件的流程可能如下： 第一次请求： 客户端发起 HTTP get 请求一个文件 服务器处理请求，返回文件内容和一堆 Header，当然包括 ETag(例如”1ec5-502264e2ae4c0”)(假设服务器支持 ETag 生成和已经开启了 ETag).状态码 200 第二次请求： 客户端发起 HTTP GET 请求一个文件，这个时候客户端同时发送一个 If-None-Match 头，这个头的内容就是我们第一次请求时服务器返回的 ETag：1ec5-502264e2ae4c0 服务器判断发送过来的 ETag 和计算出来的 ETag 是匹配的，不返回 200，返回 304，让客户端继续使用本地缓存。 站点启用 ETag 的好处1、Sitemap 启用 ETag 后，百度就可以快速的知道 Sitemap 的更新。在内容没有做更改的情况下，服务器只发回 304 应答头，对流量的消耗极小。平均每个 head 在 227B 大小的通常下，如果 24 个小时每秒回应的流量消耗仅为 18.7M。 2、站长平台对每个站点的 Sitemap 主动抓取次数是有上限的，且 这项功能没有对所有站点开放，如果你的站点 Sitemap 开启了 ETag，并通过了测试，就可以用较小的流量享受百度及时更新网站的 Sitemap 的功能。 后端需要怎么设置上文主要说的是前端如何进行打包，那后端怎么做呢？我们知道，浏览器是根据响应头的相关字段来决定缓存的方案的。所以，后端的关键就在于，根据不同的请求返回对应的缓存字段。以 nodejs 为例，如果需要浏览器强缓存，我们可以这样设置： res.setHeader(&quot;Cache-Control&quot;, &quot;public, max-age=xxx&quot;); 如果需要协商缓存，则可以这样设置： res.setHeader(&quot;Cache-Control&quot;, &quot;public, max-age=0&quot;);res.setHeader(&quot;Last-Modified&quot;, &quot;xxx&quot;);res.setHeader(&quot;ETag&quot;, &quot;xxx&quot;); 实践实际使用的时候，我们通常会 2 种缓存都使用，比如 github pages 这是这篇博客的请求示例，下面是返回头的参数 cache-control max-age=600etag W/&quot;6868c122-420c1&quot;expires Sat, 05 Jul 2025 06:34:39 GMTlast-modified Sat, 05 Jul 2025 06:07:30 GMT 既设置了 cache-control 又设置了 etag，那浏览器会根据 cache-control 来判断是否需要强缓存,这里的有效时间是 600s，所以在 600s 内，浏览器都不会请求服务器，而是会在状态码里面有一个（from memory cache），表示强缓存 Status Code 200 OK (from memory cache) 而一旦超过了 600s，浏览器就会在请求头里面添加if-modified-since、if-none-match这两个字段 下面是超过 600s 后，浏览器请求头的参数 if-modified-since Sat, 05 Jul 2025 06:07:30 GMTif-none-match W/&quot;6868c122-420c1&quot; 后端服务器接收到这个请求，会根据 if-modified-since、if-none-match 这两个字段来判断是否命中协商缓存，如果命中则直接返回 304 状态码，此时客户端的请求接口状态就会变成 304，依然是使用缓存的情况","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"}]},{"title":"正则表达式中的 .+*？","date":"2021-08-21T14:11:01.000Z","path":"2021/08/21/2021-08-21-regex-lazy-match/","text":"(.+)默认是贪婪匹配 (.+?)为惰性匹配 正则表达式的惰性匹配疑问号让.+的搜索模式从贪婪模式变成惰性模式。 var str = &#39;aaa&lt;div style=&quot;font-color:red;&quot;&gt;123456&lt;/div&gt;bbb&#39; &lt;.+?&gt;会匹配&lt;div style=&quot;font-color:red;&quot;&gt; &lt;.+&gt;会匹配&lt;div style=&quot;font-color:red;&quot;&gt;123456&lt;/div&gt; 要在浏览器测试结果的话，输入: var str = &#x27;aaa&lt;div style=&quot;font-color:red;&quot;&gt;123456&lt;/div&gt;bbb&#x27;;str.match(/&lt;.+?&gt;/);str.match(/&lt;.+&gt;/);","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"js","slug":"js","permalink":"https://luckyship.github.io/tags/js/"},{"name":"regexp","slug":"regexp","permalink":"https://luckyship.github.io/tags/regexp/"}]},{"title":"基于vue2实现一个简单的minVue","date":"2021-08-19T02:15:02.000Z","path":"2021/08/19/2021-08-19-min-vue/","text":"基于 vue2 实现一个简单的可以双向绑定的 minVue 模版插值 数据劫持，变量更新 多依赖更新 实现 vue 指令， v-text，v-model，v-click 模版插值首先 实现模版编译的功能对于 vue 的 option，我们只传入 el 和 data，其他的属性暂时我们不做处理，让 html 中的文本传值可以被 data 中的数据替换 &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;,&#125;); 此处我们只考虑元素中只有一个文本插值的情况 class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; // 编译模板 new Compile(this); &#125;&#125;class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.compile(document.querySelector(this.$el)); &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; if (this.isTextNode(node)) &#123; this.compileTextNode(node); &#125; else if (this.isElementNode(node)) &#123; this.compileElement(node); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node); &#125;); &#125; isTextNode(node) &#123; return node.nodeType === 3; &#125; isElementNode(node) &#123; return node.nodeType === 1; &#125; compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); &#125; &#125; compileElement(node) &#123;&#125;&#125; 这样我们就实现了文本插入的功能，我们看一下完整代码 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; // 编译模板 new Compile(this); &#125; &#125; class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.compile(document.querySelector(this.$el)); &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; if (this.isTextNode(node)) &#123; this.compileTextNode(node); &#125; else if (this.isElementNode(node)) &#123; this.compileElement(node); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node); &#125;); &#125; isTextNode(node) &#123; return node.nodeType === 3; &#125; isElementNode(node) &#123; return node.nodeType === 1; &#125; compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); &#125; &#125; compileElement(node) &#123;&#125; &#125; new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 数据劫持，变量更新我们都知道 vue2 是通过 Object.defineProperty 来实现数据劫持的，我们也来实现一个简单的 observer class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; new Observer(this.$data); // 编译模板 new Compile(this); &#125;&#125;class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; Object.defineProperty(obj, key, &#123; get() &#123; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; &#125; &#125;, &#125;); &#125;&#125; 这样我们就实现了数据劫持，接下来我们想一下，如何去实现数据代理的功能 首先我们想要在哪里去做依赖收集比较合适，那就是在compileTextNode方法里面，他会访问所有的文本插值的内容，所以我们可以在这里进行依赖收集。 dep = null;class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; let updateCallBack = () =&gt; &#123;&#125;; Object.defineProperty(obj, key, &#123; get() &#123; if (dep) &#123; updateCallBack = dep; &#125; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; updateCallBack &amp;&amp; updateCallBack(newValue); &#125; &#125;, &#125;); &#125;&#125;compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); // 绑定数据更新 dep = (newValue) =&gt; &#123; console.log(newValue); node.textContent = newValue; &#125;; // 触发get方法 console.log(this.$data[key]); dep = null; &#125;&#125; 我们先使用一个全局变量 dep，用来存储依赖收集的回调函数，当数据发生改变时，我们可以调用这个回调函数来更新视图，我们在defineReactive方法里面进行依赖收集，当数据发生改变时，我们可以调用updateCallBack回调函数来更新视图。 我们此处先考虑依赖只有一个模版字符串的情况，所以我们dep只是一个变量，后续我们会考虑多个模版字符串的情况，所以我们dep是一个数组或类，用来存储多个回调函数。 完整代码 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button type=&quot;button&quot; onclick=&quot;increase()&quot;&gt;add+&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function increase() &#123; minVue.$data.count = minVue.$data.count + 1; &#125; class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; new Observer(this.$data); // 编译模板 new Compile(this); &#125; &#125; dep = null; class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; let updateCallBack = () =&gt; &#123;&#125;; Object.defineProperty(obj, key, &#123; get() &#123; if (dep) &#123; updateCallBack = dep; &#125; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; updateCallBack &amp;&amp; updateCallBack(newValue); &#125; &#125;, &#125;); &#125; &#125; class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.compile(document.querySelector(this.$el)); &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; if (this.isTextNode(node)) &#123; this.compileTextNode(node); &#125; else if (this.isElementNode(node)) &#123; this.compileElement(node); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node); &#125;); &#125; isTextNode(node) &#123; return node.nodeType === 3; &#125; isElementNode(node) &#123; return node.nodeType === 1; &#125; compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); // 绑定数据更新 dep = (newValue) =&gt; &#123; console.log(newValue); node.textContent = newValue; &#125;; // 触发get方法 console.log(this.$data[key]); dep = null; &#125; &#125; compileElement(node) &#123;&#125; &#125; let minVue = new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 多个依赖的情况如果我们有多个模版字符串的情况，比如有 2 个使用 count 的情况，就无法用一个 dep 去实现了，所以我们此处将 dep 改造成泪类，并把更新函数写到 Watch 类里面 &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; class Dep &#123; constructor() &#123; this.watchers = []; &#125; addWatcher(watcher) &#123; this.watchers.push(watcher); &#125; notify() &#123; this.watchers.forEach((watcher) =&gt; watcher.update()); &#125;&#125;class Watcher &#123; constructor($data, key, cb) &#123; Dep.target = this; this.key = key; this.cb = cb; // 此处调用get方法，触发get方法的defineProperty的get方法，将watcher添加到dep中 this.$data = $data; this._old = $data[key]; Dep.target = null; &#125; update() &#123; const newValue = this.$data[this.key]; this.cb(newValue); this._old = newValue; &#125;&#125; compileTextNode中我们改造一下，使用 Watcher 方法去更新 compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); // 绑定数据更新 new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125;&#125; 然后再把 Observer 中的代码更新为Dep类的方法 class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; if (Dep.target) &#123; dep.addWatcher(Dep.target); &#125; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; dep.notify(); &#125; &#125;, &#125;); &#125;&#125; &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;button type=&quot;button&quot; onclick=&quot;increase()&quot;&gt;add+&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function increase() &#123; minVue.$data.count = minVue.$data.count + 1; &#125; class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; new Observer(this.$data); // 编译模板 new Compile(this); &#125; &#125; class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; if (Dep.target) &#123; dep.addWatcher(Dep.target); &#125; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; dep.notify(); &#125; &#125;, &#125;); &#125; &#125; class Dep &#123; constructor() &#123; this.watchers = []; &#125; addWatcher(watcher) &#123; this.watchers.push(watcher); &#125; notify() &#123; this.watchers.forEach((watcher) =&gt; watcher.update()); &#125; &#125; class Watcher &#123; constructor($data, key, cb) &#123; Dep.target = this; this.key = key; this.cb = cb; // 此处调用get方法，触发get方法的defineProperty的get方法，将watcher添加到dep中 this.$data = $data; this._old = $data[key]; Dep.target = null; &#125; update() &#123; const newValue = this.$data[this.key]; this.cb(newValue); this._old = newValue; &#125; &#125; class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.compile(document.querySelector(this.$el)); &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; if (this.isTextNode(node)) &#123; this.compileTextNode(node); &#125; else if (this.isElementNode(node)) &#123; this.compileElement(node); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node); &#125;); &#125; isTextNode(node) &#123; return node.nodeType === 3; &#125; isElementNode(node) &#123; return node.nodeType === 1; &#125; compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); // 绑定数据更新 new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125; &#125; compileElement(node) &#123;&#125; &#125; let minVue = new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt; 这样我们就实现了多个依赖更新的情况 实现 vue 指令实现 v-text我们之前对非 text 节点没有作特殊处理，现在处理一下，实现 v-text 的功能 compileElement(node) &#123; const attrs = node.attributes; if (attrs.length) &#123; Array.from(attrs).forEach((attr) =&gt; &#123; if (this.isDirective(attr.name)) &#123; // 根据v-来截取一下后缀属性名 let attrName = attr.name.indexOf(&quot;:&quot;) &gt; -1 ? attr.name.substr(5) : attr.name.substr(2); let key = attr.value; this.update(node, attrName, key, this.$data[key]); &#125; &#125;); &#125;&#125;isDirective(dir) &#123; return dir.startsWith(&quot;v-&quot;);&#125;update(node, attrName, key, value) &#123; if (attrName === &quot;text&quot;) &#123; node.textContent = value; // 这里不再textnode处理， 所以我们要还是要做Watch的更新 new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125;&#125; 在 html 中试一下，能够正常展示 😊 &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt; v-model然后我们实现 v-model update(node, attrName, key, value) &#123; if (attrName === &quot;text&quot;) &#123; node.textContent = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125; if (attrName === &quot;model&quot;) &#123; node.value = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.value = newValue; &#125;); node.addEventListener(&quot;input&quot;, (e) =&gt; &#123; this.$data[key] = node.value; &#125;); &#125;&#125; &lt;input v-model=&quot;msg&quot; /&gt; 可以正常使用 v-click最后我们实现一下 v-click 指令 class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.methods = object.methods; // 注册 this.compile(document.querySelector(this.$el)); &#125; update(node, attrName, key, value) &#123; if (attrName === &quot;text&quot;) &#123; node.textContent = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125; if (attrName === &quot;model&quot;) &#123; node.value = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.value = newValue; &#125;); node.addEventListener(&quot;input&quot;, (e) =&gt; &#123; this.$data[key] = node.value; &#125;); &#125; if (attrName === &quot;click&quot;) &#123; node.addEventListener(attrName, this.methods[key].bind(this.$data)); &#125; &#125;&#125; class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; this.methods = options.methods; new Observer(this.$data); // 编译模板 new Compile(this); &#125;&#125;let minVue = new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;, methods: &#123; increase() &#123; this.count = this.count + 1; &#125;, &#125;,&#125;); &lt;button type=&quot;button&quot; v-click=&quot;increase&quot;&gt;vue add+&lt;/button&gt; 到这里，我们就实现了一个简单的 minVue 了，一起来看下最后的完整代码吧 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt; &lt;p v-text=&quot;msg&quot;&gt;&lt;/p&gt; &lt;input v-model=&quot;msg&quot; /&gt; &lt;button type=&quot;button&quot; onclick=&quot;increase()&quot;&gt;add+&lt;/button&gt; &lt;button type=&quot;button&quot; v-click=&quot;increase&quot;&gt;vue add+&lt;/button&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function increase() &#123; minVue.$data.count = minVue.$data.count + 1; &#125; class MinVue &#123; constructor(options) &#123; this.$el = options.el; this.$data = options.data; this.methods = options.methods; new Observer(this.$data); // 编译模板 new Compile(this); &#125; &#125; class Observer &#123; constructor(data) &#123; this.data = data; this.walk(data); &#125; walk(data) &#123; Object.keys(data).forEach((key) =&gt; &#123; this.defineReactive(data, key, data[key]); &#125;); &#125; defineReactive(obj, key, value) &#123; const dep = new Dep(); Object.defineProperty(obj, key, &#123; get() &#123; if (Dep.target) &#123; dep.addWatcher(Dep.target); &#125; return value; &#125;, set(newValue) &#123; if (newValue !== value) &#123; value = newValue; dep.notify(); &#125; &#125;, &#125;); &#125; &#125; class Dep &#123; constructor() &#123; this.watchers = []; &#125; addWatcher(watcher) &#123; this.watchers.push(watcher); &#125; notify() &#123; this.watchers.forEach((watcher) =&gt; watcher.update()); &#125; &#125; class Watcher &#123; constructor($data, key, cb) &#123; Dep.target = this; this.key = key; this.cb = cb; // 此处调用get方法，触发get方法的defineProperty的get方法，将watcher添加到dep中 this.$data = $data; this._old = $data[key]; Dep.target = null; &#125; update() &#123; const newValue = this.$data[this.key]; this.cb(newValue); this._old = newValue; &#125; &#125; class Compile &#123; constructor(object) &#123; this.$el = object.$el; this.$data = object.$data; this.methods = object.methods; this.compile(document.querySelector(this.$el)); &#125; compile(el) &#123; const childNodes = el.childNodes; Array.from(childNodes).forEach((node) =&gt; &#123; if (this.isTextNode(node)) &#123; this.compileTextNode(node); &#125; else if (this.isElementNode(node)) &#123; this.compileElement(node); &#125; if (node.childNodes &amp;&amp; node.childNodes.length) this.compile(node); &#125;); &#125; isTextNode(node) &#123; return node.nodeType === 3; &#125; isElementNode(node) &#123; return node.nodeType === 1; &#125; compileTextNode(node) &#123; // .+?正则懒惰匹配, 非贪婪匹配, 匹配花括号里面的内容 // 只匹配第一个花括号，后续的不匹配（只考虑元素里面只有一个模版字符串的情况） const reg = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/g; const text = node.textContent; if (reg.test(text)) &#123; // 如果匹配成功, 获取第一个匹配的内容 let key = RegExp.$1.trim(); node.textContent = text.replace(reg, this.$data[key]); // 绑定数据更新 new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125; &#125; compileElement(node) &#123; const attrs = node.attributes; if (attrs.length) &#123; Array.from(attrs).forEach((attr) =&gt; &#123; if (this.isDirective(attr.name)) &#123; // 根据v-来截取一下后缀属性名 let attrName = attr.name.indexOf(&quot;:&quot;) &gt; -1 ? attr.name.substr(5) : attr.name.substr(2); let key = attr.value; this.update(node, attrName, key, this.$data[key]); &#125; &#125;); &#125; &#125; isDirective(dir) &#123; return dir.startsWith(&quot;v-&quot;); &#125; update(node, attrName, key, value) &#123; if (attrName === &quot;text&quot;) &#123; node.textContent = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.textContent = newValue; &#125;); &#125; if (attrName === &quot;model&quot;) &#123; node.value = value; new Watcher(this.$data, key, (newValue) =&gt; &#123; node.value = newValue; &#125;); node.addEventListener(&quot;input&quot;, (e) =&gt; &#123; this.$data[key] = node.value; &#125;); &#125; if (attrName === &quot;click&quot;) &#123; node.addEventListener(attrName, this.methods[key].bind(this.$data)); &#125; &#125; &#125; let minVue = new MinVue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;hello,mini vue.js&quot;, count: 666, &#125;, methods: &#123; increase() &#123; this.count = this.count + 1; &#125;, &#125;, &#125;); &lt;/script&gt;&lt;/html&gt;","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"手写javascript方法","date":"2021-08-09T08:27:43.000Z","path":"2021/08/09/2021-08-09-javascript-method-implement/","text":"数组扁平化效果： [1, [2, [3]]].flat(2); // [1, 2, 3] es5 实现：递归调用Array.prototype.newFlat = function (depth) &#123; var arr = this; var result = []; for (var i = 0; i &lt; arr.lenght; i++) &#123; if (Array.isArray(arr[i]) &amp;&amp; depth &gt;= 1) &#123; depth--; result = result.concat(arr[i].newFlat(depth)); &#125; else &#123; result.push(arr[i]); &#125; &#125; return result;&#125;; es6 实现Array.prototype.newFlat = function (depth) &#123; var arr = this; // var result = []; while (arr.some((item) =&gt; Array.isArray(item))) &#123; if (depth &gt;= 1) &#123; depth--; arr = [].concat(...arr); &#125; &#125; return arr;&#125;; 实现 new实现要点： new 会产生一个新对象 新对象需要能够访问到构造函数的属性，所以需要重新指定它的原型 构造函数可能会显示返回 function objectFactory() &#123; var obj = new Object(); // 取出第一个参数为构造函数，同时删除第一个参数，剩余参数为构造函数的参数 var constructorFunction = [].shift.call(arguments); obj.__proto__ = constructorFunction.prototype; var result = constructorFunction.apply(obj, arguments); // result || obj 这里这么写，是考虑到构造函数返回为null return typeof result === &quot;object&quot; ? result || obj : obj;&#125; 实例 function person(name, age) &#123; this.name = name; this.age = age;&#125;var p = objectFactory(person, &quot;asd&quot;, 13);console.log(p); 本质上是利用了，实例的__proto__属性 等于构造函数的 prototype 实现 instanceof 关键字instanceof 就是判断构造函数的 prototype 属性是否出现在实例的原型链上 function newInstanceof(left, right) &#123; /** * 前置判断，不符合直接访问false * 根据语法A instanceof B，我们可以得知两点，首先A得是一个实例对象，B得是一个构造器函数。 */ if (typeof left !== &quot;object&quot; || left === null || typeof right !== &quot;function&quot;) &#123; return false; &#125; var proto = left.__proto__; while (true) &#123; if (proto === null) &#123; return false; &#125; if (proto === right.prototype) &#123; return true; &#125; proto = proto.__proto__; &#125;&#125; Promise.allpromiseAll 源码实现 function isPromise(obj) &#123; return !!obj &amp;&amp; (typeof obj === &quot;object&quot; || typeof obj === &quot;function&quot;) &amp;&amp; typeof obj.then === &quot;function&quot;;&#125;const myPromiseAll = (arr) =&gt; &#123; let result = []; return new Promise((resolve, reject) =&gt; &#123; console.log(&quot;promiseAll&quot;); for (let i = 0; i &lt; arr.length; i++) &#123; if (isPromise(arr[i])) &#123; arr[i].then((data) =&gt; &#123; result[i] = data; if (result.length === arr.length) &#123; resolve(result); &#125; &#125;, reject); &#125; else &#123; result[i] = arr[i]; &#125; &#125; &#125;);&#125;;let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 5000, &quot;foo1&quot;);&#125;);let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 1000, &quot;foo2&quot;);&#125;);let p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function () &#123; resolve(&quot;foo3&quot;); &#125;, 10000);&#125;);myPromiseAll([p1, p2, p3]).then((values) =&gt; &#123; console.log(values); // [&quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot;]&#125;); 函数柯里化function add(num) &#123; var sum = 0; sum = sum + num; var tempFun = function (numB) &#123; if (arguments.length === 0) &#123; return sum; &#125; else &#123; sum = sum + numB; return tempFun; &#125; &#125;; tempFun.valueOf = function () &#123; return sum; &#125;; tempFun.toString = function () &#123; return sum + &quot;&quot;; &#125;; return tempFun;&#125; 参考","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"vscode配置项","date":"2021-08-07T09:15:37.000Z","path":"2021/08/07/2021-08-07-vscode-setting/","text":"prettier 配置强制 prettier 不生效 &lt;!-- prettier-ignore --&gt;&lt;div class=&quot;x&quot;&gt;hello world&lt;/div&gt;&lt;!-- prettier-ignore-attribute --&gt; vscode 配置 自用配置 &#123; &quot;editor.formatOnSave&quot;: true, // 自动保存 &quot;prettier.singleQuote&quot;: true, // 单引号 &quot;prettier.printWidth&quot;: 120, &quot;prettier.useEditorConfig&quot;: false, &quot;prettier.endOfLine&quot;: &quot;auto&quot;, // 最后一行 &quot;prettier.arrowParens&quot;: &quot;avoid&quot; // 箭头函数括号&#125; 各类语言自动格式化 &#123; &quot;[typescript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[json]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;vscode.json-language-features&quot; &#125;, &quot;[jsonc]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;vscode.json-language-features&quot; &#125;, &quot;[css]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[scss]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;editor.formatOnSave&quot;: true&#125; 文档 &#123; // 使能每一种语言默认格式化规则 &quot;[html]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[css]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[less]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, &quot;[javascript]&quot;: &#123; &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot; &#125;, /* prettier的配置 */ &quot;prettier.printWidth&quot;: 100, // 超过最大值换行 &quot;prettier.tabWidth&quot;: 4, // 缩进字节数 &quot;prettier.useTabs&quot;: false, // 缩进不使用tab，使用空格 &quot;prettier.semi&quot;: true, // 句尾添加分号 &quot;prettier.singleQuote&quot;: true, // 使用单引号代替双引号 &quot;prettier.proseWrap&quot;: &quot;preserve&quot;, // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 &quot;prettier.arrowParens&quot;: &quot;avoid&quot;, // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 &quot;prettier.bracketSpacing&quot;: true, // 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot; &quot;prettier.disableLanguages&quot;: [&quot;vue&quot;], // 不格式化vue文件，vue文件的格式化单独设置 &quot;prettier.endOfLine&quot;: &quot;auto&quot;, // 结尾是 \\n \\r \\n\\r auto &quot;prettier.htmlWhitespaceSensitivity&quot;: &quot;ignore&quot;, &quot;prettier.ignorePath&quot;: &quot;.prettierignore&quot;, // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 &quot;prettier.jsxBracketSameLine&quot;: false, // 在jsx中把&#x27;&gt;&#x27; 是否单独放一行 &quot;prettier.jsxSingleQuote&quot;: false, // 在jsx中使用单引号代替双引号 &quot;prettier.parser&quot;: &quot;babylon&quot;, // 格式化的解析器，默认是babylon &quot;prettier.requireConfig&quot;: false, // Require a &#x27;prettierconfig&#x27; to format prettier &quot;prettier.stylelintIntegration&quot;: false, //不让prettier使用stylelint的代码格式进行校验 &quot;prettier.trailingComma&quot;: &quot;es5&quot;, // 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号） &quot;prettier.tslintIntegration&quot;: false, // 不让prettier使用tslint的代码格式进行校验 &quot;prettier.eslintIntegration&quot;: false, //不让prettier使用eslint的代码格式进行校验 &quot;prettier.useEditorConfig&quot;: false // 取消优先配置editconfig，不取消prettier不起作用&#125;","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"base","slug":"base","permalink":"https://luckyship.github.io/tags/base/"}]},{"title":"js call、apply、bind源码实现","date":"2021-07-24T11:10:37.000Z","path":"2021/07/24/2021-07-24-js-call-apply-bind-source-code/","text":"call首先上一个 call 使用 function add(c, d) &#123; return this.a + this.b + c + d;&#125;const obj = &#123; a: 1, b: 2,&#125;;console.log(add.call(obj, 3, 4)); // 10 大统上的说法就是，call 改变了 this 的指向, 然后，介绍 this xxx 什么一大堆名词，反正不管你懂不懂，成功绕晕你就已经 ok 了，但是实际发生的过程，可以看成下面的样子。 const o = &#123; a: 1, b: 2, add: function (c, d) &#123; return this.a + this.b + c + d; &#125;,&#125;; 给 o 对象添加一个 add 属性，这个时候 this 就指向了 o， o.add(5, 7)得到的结果和 add.call(o, 5, 6)相同。 但是给对象 o 添加了一个额外的 add 属性，这个属性我们是不需要的，所以可以使用 delete 删除它。 so, 基本为以下三部。 // 1. 将函数设为对象的属性o.fn = bar;// 2. 执行该函数o.fn();// 3. 删除该函数delete o.fn; 所以我们基于 ES5 实现 call Function.prototype.es3Call = function (context) &#123; var content = context || window; content.fn = this; var args = []; // arguments是类数组对象，遍历之前需要保存长度，过滤出第一个传参 for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; // 避免object之类传入 args.push(&#x27;arguments[&#x27; + i + &#x27;]&#x27;); &#125; var result = eval(&#x27;content.fn(&#x27; + args + &#x27;)&#x27;); delete content.fn; return result;&#125;;console.error(add.es3Call(obj, 3, 4)); // 10console.log( add.es3Call( &#123; a: 3, b: 9, &#125;, 3, 4 )); // 19console.log( add.es3Call( &#123; a: 3, b: 9, &#125;, &#123; xx: 1, &#125;, 4 )); // 12[object Object]4 基于 ES6 实现 call, 其实差别不大，es6 新增… rest，这就可以放弃 eval 的写法，如下 // ES6 call 实现Function.prototype.es6Call = function (context) &#123; var content = context || window; content.fn = this; var args = []; for (var i = 1, len = arguments.length; i &lt; len; i++) &#123; args.push(arguments[i]); &#125; const result = content.fn(...args); delete content.fn; return result;&#125;;console.error(add.es6Call(obj, 3, 4));console.log( add.es6Call( &#123; a: 3, b: 9, &#125;, &#123; xx: 1, &#125;, 4 )); // 12[object Object]4 applyapply 和 call 区别在于 apply 第二个参数是 Array，而 call 是将一个个传入 基于 es3 实现 Function.prototype.es3Apply = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; // 获取参数 var args = []; for (var i = 0, len = arr.length; i &lt; len; i++) &#123; args.push(&#x27;arr[&#x27; + i + &#x27;]&#x27;); &#125; // 执行函数 result = eval(&#x27;context.fn(&#x27; + args + &#x27;)&#x27;); &#125; delete context.fn; return result;&#125;;console.log(add.es3Apply(obj, [1, &#x27;abc&#x27;, &#x27;2&#x27;])); // 4abc 基于 es6 实现 Function.prototype.es6Apply = function (context, arr) &#123; var context = context || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; if (!(arr instanceof Array)) throw new Error(&#x27;params must be array&#x27;); result = context.fn(...arr); &#125; delete context.fn; return result;&#125;;console.error(add.es6Apply(obj, [1, 2])); // 6 bindbind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。先看一个使用 bind 方法的实例 function foo(c, d) &#123; this.b = 100; console.log(this.a); console.log(this.b); console.log(c); console.log(d);&#125;// 我们将foo bind到&#123;a: 1&#125;var func = foo.bind( &#123; a: 1, &#125;, &#x27;1st&#x27;);func(&#x27;2nd&#x27;); // 1 100 1st 2nd// 即使再次call也不能改变this。func.call( &#123; a: 2, &#125;, &#x27;3rd&#x27;); // 1 100 1st 3rd// 当 bind 返回的函数作为构造函数的时候，// bind 时指定的 this 值会失效，但传入的参数依然生效。// 所以使用func为构造函数时，this不会指向&#123;a: 1&#125;对象，this.a的值为undefined。如下// new func(&#x27;4th&#x27;); //undefined 100 1st 4th 首先使用 ES3 实现 Function.prototype.es3Bind = function (context) &#123; if (typeof this !== &#x27;function&#x27;) throw new TypeError(&#x27;what is trying to be bound is not callback&#x27;); var self = this; var args = Array.prototype.slice.call(arguments, 1); const fBound = function () &#123; // 获取函数的参数 var bindArgs = Array.prototype.slice.call(arguments); // 返回函数的执行结果 // 判断函数是作为构造函数还是普通函数 // 构造函数this instanceof fNOP返回true，将绑定函数的this指向该实例，可以让实例获得来自绑定函数的值。 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs)); &#125;; // 创建空函数 var fNOP = function () &#123;&#125;; // fNOP函数的prototype为绑定函数的prototype fNOP.prototype = this.prototype; // 返回函数的prototype等于fNOP函数的实例实现继承 fBound.prototype = new fNOP(); // 以上三句相当于Object.create(this.prototype) return fBound;&#125;;var func = foo.es3Bind( &#123; a: 1, &#125;, &#x27;1st&#x27;);func(&#x27;2nd&#x27;); // 1 100 1st 2ndfunc.call( &#123; a: 2, &#125;, &#x27;3rd&#x27;); // 1 100 1st 3rdnew func(&#x27;4th&#x27;); //undefined 100 1st 4th es6 实现 Function.prototype.es6Bind = function (context, ...rest) &#123; if (typeof this !== &#x27;function&#x27;) throw new TypeError(&#x27;invalid invoked!&#x27;); var self = this; return function F(...args) &#123; if (this instanceof F) &#123; return new self(...rest, ...args); &#125; return self.apply(context, rest.concat(args)); &#125;;&#125;;var func = foo.es6Bind( &#123; a: 1, &#125;, &#x27;1st&#x27;);func(&#x27;2nd&#x27;); // 1 100 1st 2ndfunc.call( &#123; a: 2, &#125;, &#x27;3rd&#x27;); // 1 100 1st 3rdnew func(&#x27;4th&#x27;); //undefined 100 1st 4th","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"使用node快速启动一个服务器","date":"2021-07-24T03:37:10.000Z","path":"2021/07/24/2021-07-24-start-web-server-quick/","text":"在实际生产环境中，有时我们可能需要启动一个服务器，来测试接口，我们使用node来快速启动一个服务器 启动node服务器这里我们使用 node 的 express 框架去启动一个服务器 npm install express path 新建 express.js 文件，内容如下 const express = require(&quot;express&quot;);const app = express();const PORT = 8080;const path = require(&quot;path&quot;);let count = 0;app.get(&quot;/test&quot;, (req, res) =&gt; &#123; res.send(&#x27;123&#x27;)&#125;);app.listen(PORT); 启动命令 node express.js","updated":"2025-08-02T05:46:04.177Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://luckyship.github.io/tags/nodejs/"}]},{"title":"react基础知识","date":"2021-07-18T14:28:03.000Z","path":"2021/07/18/2021-07-18-react-base/","text":"React 的响应式原理React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 “diff” 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新真实 DOM。虚拟DOM 作为一种缓存机制优化了 UI 渲染减少昂贵的 DOM 变化的数量。 开发者只需关注状态转移（数据），当状态发生变化，React 框架会自动根据新的状态重新构建 UI。 React 框架在接收到用户状态改变通知后，会根据当前渲染树，结合最新的状态改变，通过 Diff 算法，计算出树中变化的部分，然后只更新变化的部分（DOM 操作），从而避免整棵树重构，提高性能。状态变化后React 框架并不会立即去计算并渲染 DOM 树的变化部分，相反，React 会在 DOM 的基础上建立一个抽象层，即虚拟 DOM 树，对数据和状态所做的任何改动，都会被自动且高效的同步到虚拟 DOM，最后再批量同步到真实 DOM中，而不是每次改变都去操作一下 DOM。 为什么不能每次改变都直接去操作 DOM 树？这是因为在浏览器中每一次 DOM 操作都有可能引起浏览器的重绘或回流： 如果 DOM 只是外观风格发生变化，如颜色变化，会导致浏览器重绘界面。 如果 DOM 树的结构发生变化，如尺寸、布局、节点隐藏等导致，浏览器就需要回流（及重新排版布局）。而浏览器的重绘和回流都是比较昂贵的操作，如果每一次改变都直接对 DOM 进行操作，这会带来性能问题，而批量操作只会触发一次 DOM 更新。 使用 React 有何优点 只需查看 render 函数就会很容易知道一个组件是如何被渲染的 JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的 支持服务端渲染，这可以改进 SEO 和性能 易于测试 React 只关注 View 层，所以可以和其它任何框架(如 Backbone.js, Angular.js)一起使用 展示组件(Presentational component)和容器组件(Container component)之间有何不同展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions ，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 类组件(Class component)和函数式组件(Functional component)之间有何不同 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件 (组件的)状态(state)和属性(props)之间有何不同State 是一种数据结构，用于组件挂载时所需数据的默认值。 State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。 Props (properties 的简写)则是组件的配置。 props 由父组件传递给子组件，并且就子组件而言， props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。 指出(组件)生命周期方法的不同 componentWillMount – 多用于根组件中的应用程序配置 componentDidMount – 在这可以完成所有没有 DOM 就不能做的所有配置，并开始获取所有你需要的数据；如果需要设置事件监听，也可以在这完成 componentWillReceiveProps – 这个周期函数作用于特定的 prop 改变导致的 state 转换 shouldComponentUpdate – 如果你担心组件过度渲染，shouldComponentUpdate 是一个改善性能的地方，因为如果组件接收了新的 prop， 它可以阻止(组件)重新渲染。shouldComponentUpdate 应该返回一个布尔值来决定组件是否要重新渲染 componentWillUpdate – 很少使用。它可以用于代替组件的 componentWillReceiveProps 和 shouldComponentUpdate(但不能访问之前的 props) componentDidUpdate – 常用于更新 DOM，响应 prop 或 state 的改变 componentWillUnmount – 在这你可以取消网络请求，或者移除所有与组件相关的事件监听器 应该在 React 组件的何处发起 Ajax 请求在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。 何为受控组件(controlled component)在 HTML 中，类似 &lt;input&gt; , &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。 在 React 中，refs 的作用是什么Refs 可以用于获取一个 DOM 节点或者 React 组件(组件实例)的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。 三种 ref 方式 string 类型绑定类似于 vue 中的 ref 绑定方式，可以通过 this.refs. 绑定的 ref 的名字获取到节点 dom，注意的是这种方式已经不被最新版的 react 推荐使用，有可能会在未来版本中遗弃。 focus = () =&gt; &#123; this.refs.inputRef.focus() &#125; &lt;input ref = &quot;inputRef&quot; /&gt; // 获取子组件的div // 父组件 &lt;Child myRef = &#123; this.state.myDiv &#125;/&gt;// 子组件&lt;div ref = &#123; this.props.myRef&#125; &gt; 我是子组件 &lt;/div&gt; react.CreateRef()通过在 class 中使用 React.createRef()方法创建一些变量，可以将这些变量绑定到标签的 ref 中，该变量的 current 则指向绑定的标签 dom。 inputRef = React.createRef()focus = () =&gt; &#123; this.inputRef.current.focus() &#125; &lt; input ref = &#123; this.inputRef &#125;/&gt; 函数形式在 class 中声明函数，在函数中绑定 ref 使用这种方法可以将子组件暴露给父组件以使得父组件能够调用子组件的方法 inputRef = nullfocus = () =&gt; &#123; this.inputRef.focus() &#125; &lt; input ref = &#123; (el) =&gt; this.inputRef = el &#125;/&gt; useRef(实例属性) function UseRefDemo() &#123; const inputRef = useRef(null as any) const handleFocusInput = () =&gt; &#123; inputRef.current.focus() &#125; return ( &lt;div&gt; &lt;input ref = &#123; inputRef &#125; /&gt; &lt; button onClick = &#123; handleFocusInput &#125; &gt; click focus &lt; /button&gt; &lt; /div&gt; )&#125; forwardRef(获取组件内的引用) // 子组件const Child = forwardRef((props, ref) =&gt; &#123; return ( &lt; div ref = &#123; ref &#125; &gt; &#123; props.txt &#125; &lt; /div&gt; ) &#125;) // 父组件 &lt; Child ref = &#123; this.state.myDiv &#125;txt = &quot;parent props txt&quot; / &gt; 注意: react 并不推荐过度使用 ref，如果能通过 state 做到的事情，就不应该使用 refs 在你的 app 中“让事情发生”。过度使用 ref 并不符合数据驱动的思想。 何为高阶组件(higher order component)高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。装饰器@decoration优点: 逻辑复用 不影响被包裹组件的逻辑 缺点: 传递的 props 和包裹组件的 props 发生重名会覆盖 组件嵌套导致层级过深 渲染属性(render props)Render prop 是一个告知组件需要渲染什么内容的函数 prop优点: 逻辑复用 数据共享 缺点: 嵌套 无法在 return 语句外访问数据 使用箭头函数(arrow functions)的优点是什么 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 this 值。 简单：箭头函数易于阅读和书写 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。setState 在生命周期里是异步的，第二个参数是组件重新渲染完成后的回调。 除了在构造函数中绑定 this ，还有其它方式吗在 constructor 里使用 bind。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 怎么阻止组件的渲染在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法 react 与 vue 数组中 key 的作用是什么diff 算法需要比对虚拟 dom 的修改，然后异步的渲染到页面中，当出现大量相同的标签时，vnode 会首先判断 key 和标签名是否一致，如果一致再去判断子节点一致，使用 key 可以帮助 diff 算法提升判断的速度，在页面重新渲染时更快消耗更少。 (在构造函数中)调用 super(props) 的目的是什么在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super() 。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props 。 何为 JSXJSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React “元素”，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。 缺点：b&amp;&amp; 强转成 boolean 类型 否则如果 b=0 渲染出 0 怎么用 React.createElement 重写下面的代码Question： const element = &lt;h1 className=&quot;greeting&quot;&gt;Hello, world!&lt;/h1&gt;; Answer： const element = React.createElement( &#x27;h1&#x27;, &#123; className: &#x27;greeting&#x27;, &#125;, &#x27;Hello, world!&#x27;); 何为 Children在 JSX 表达式中，一个开始标签(比如 &lt;a&gt; )和一个关闭标签(比如 &lt;/a&gt; )之间的内容会作为一个特殊的属性 props.children 被自动传递给包含着它的组件。 这个属性有许多可用的方法，包括 React. Children.map ， React. Children.forEach ， React. Children.count ， React. Children.only ， React. Children.toArray 。 在 React 中，何为 stateState 和 props 类似，但它是私有的，并且完全由组件自身控制。State 本质上是一个持有数据，并决定组件如何渲染的对象。 你为何排斥 create-react-app在你排斥之前，你并不能去配置 webpack 或 babel presets。 何为 reduxRedux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该由任何副作用。 在 Redux 中，何为 storeStore 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责： 允许通过 getState() 访问 state 运行通过 dispatch(action) 改变 state 通过 subscribe(listener) 注册 listeners 通过 subscribe(listener) 返回的函数处理 listeners 的注销 何为 actionActions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。 何为 reducer一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。 Redux Thunk 的作用是什么Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)。 何为纯函数(pure function)一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。 同输入同输出 无副作用(函数内部的操作不会对外部产生影响(如修改全局变量的值、修改 dom 节点等)) redux 有哪些中间件，作用？中间件提供第三方插件的模式，自定义拦截 action -&gt; reducer 的过程。变为 action -&gt; middlewares -&gt; reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。 redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator 的返回值是 promise 示例项目 React Spotify React Soundcloud 虚拟 dom(虚拟节点)是用 JS 对象来模拟真实 DOM 中的节点虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。插入新组件有了 key 可以帮助 react 找到映射。 真实的元素节点 &lt;div id=&quot;wrap&quot;&gt; &lt;p class=&quot;title&quot;&gt;Hello world!&lt;/p&gt;&lt;/div&gt; vnode &#123; tag: &#x27;div&#x27;, attrs: &#123; id: &#x27;wrap&#x27; &#125;, children: [&#123; tag: &#x27;p&#x27;, text: &#x27;Hello world!&#x27;, attrs: &#123; class: &#x27;title&#x27;, &#125; &#125;]&#125; 为什么使用虚拟 dom起初我们在使用 JS/JQuery 时，不可避免的会大量操作 DOM，而 DOM 的变化又会引发回流或重绘，从而降低页面渲染性能。那么怎样来减少对 DOM 的操作呢？此时虚拟 DOM应用而生，所以虚拟 DOM 出现的主要目的就是 为了减少频繁操作DOM而引起回流重绘所引发的性能问题的 虚拟 dom 的作用兼容性好。因为 Vnode 本质是 JS 对象，所以不管 Node 还是浏览器环境，都可以操作；减少了对 Dom 的操作。页面中的数据和状态变化，都通过 Vnode 对比，只需要在比对完之后更新 DOM，不需要频繁操作，提高了页面性能。 每个 setState 重新渲染整个子树标记为 dirty。 如果要压缩性能，请尽可能调用 setState，并使用 shouldComponentUpdate 来防止重新渲染大型子树。把树形结构按照层级分解，只比较同级元素。给列表结构的每个单元添加唯一的 key 属性，方便比较。pureComponent(浅比较)+immutable 替换成 preact diff 算法 一开始会根据真实 DOM 生成虚拟 DOM，当虚拟 DOM 某个节点的数据改变后会生成一个新的 Vnode，然后 VNode 和 oldVnode 对比，把不同的地方修改在真实 DOM 上，最后再使得 oldVnode 的值为 Vnode。 diff过程就是调用patch函数，比较新老节点，一边比较一边给真实DOM打补丁(patch)； 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty. 到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 diff 的只是 html tag，并没有 diff 数据。 setState 的理解 setState 只在合成事件和钩子函数(除了componentDidUpdate)中是“异步”的，在原生事件和 setTimeout 中都是同步的。 setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和 setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState，setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 异步与同步: setState 并不是单纯的异步或同步，这其实与调用时的环境相关: 在 合成事件 和 生命周期钩子(除 componentDidUpdate) 中，setState 是”异步”的； 原因: 因为在 setState 的实现中，有一个判断: 当更新策略正在事务流的执行中时，该组件更新会被推入 dirtyComponents 队列中等待执行；否则，开始执行 batchedUpdates 队列更新； 在生命周期钩子调用中，更新策略都处于更新之前，组件仍处于事务流中，而 componentDidUpdate 是在更新之后，此时组件已经不在事务流中了，因此则会同步执行；在合成事件中，React 是基于 事务流完成的事件委托机制 实现，也是处于事务流中； 问题: 无法在 setState 后马上从 this.state 上获取更新后的值。 解决: 如果需要马上同步去获取新值，setState 其实是可以传入第二个参数的。setState(updater, callback)，在回调中即可获取最新值； 在 原生事件 和 setTimeout 中，setState 是同步的，可以马上获取更新后的值； 原因: 原生事件是浏览器本身的实现，与事务流无关，自然是同步；而 setTimeout 是放置于定时器线程中延后执行，此时事务流已结束，因此也是同步； 批量更新 在 合成事件 和 生命周期钩子 中，setState 更新队列时，存储的是合并状态(Object.assign)。因此前面设置的 key 值会被后面所覆盖，最终只会执行一次更新； 函数式 由于 Fiber 及 合并 的问题，官方推荐可以传入 函数 的形式。setState(fn)，在 fn 中返回新的 state 对象即可，例如 this.setState((state, props) =&gt; newState)； 使用函数式，可以用于避免 setState 的批量更新的逻辑，传入的函数将会被顺序调用； 注意点 当组件已被销毁，如果再次调用 setState，React 会报错警告，通常有两种解决办法: 将数据挂载到外部，通过 props 传入，如放到 Redux 或 父级中； 在组件内部维护一个状态量 (isUnmounted)，componentWillUnmount 中标记为 true，在 setState 前进行判断； 替换的属性 class/className for/htmlFor 插入 html 文本dangerouslySetInnerHTML = &#123; &#123; __html: content &#125;&#125; 15 版本的生命周期如下： 初始化阶段 constructor getDefaultProps getInitialState 挂载阶段 componentWillMount render componentDidMount 更新阶段props： componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdatestate： shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载阶段 componentWillUnmount 16 版本生命周期如下： 初始化阶段 constructor getDefaultProps getInitialState 挂载阶段 组件实例化。组件的props发生变化。父组件重新渲染。this.setState() 不会触发getDerivedStateFromProps()， 但是this.forceUpdate() 会。 getDerivedStateFromProps: 传入 nextProps 和 prevState，根据需要将 props 映射到 state，否则返回 null render componentDidMount 更新阶段 getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate：render 之后 dom 渲染之前会发生，返回一个值作为 componentDidUpdate 的第三个参数使用 componentDidUpdate 卸载阶段 componentWillUnmount 错误处理 componentDidCatch 事件机制react 事件并没有绑定到真实的 dom 节点上，而是通过事件代理，在最外层的 document 上对事件进行统一分发。 为什么 react 事件要自己绑定 this在 react 中事件处理函数是直接调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的 this 是不准确的，所以我们需要手动将当前组件绑定到 this 上。 react 和原生事件的执行顺序是什么，可以混用吗react 的所有事件都通过 document 进行统一分发，当真实 dom 触发事件后冒泡到 document 后才会对 react 事件进行处理 所以原生事件会先执行，然后执行 react 合成事件，最后执行真正在 document 上挂载的事件两者最好不要混用，原生事件中如果执行了 stopPropagation 方法，则会导致其他 react 事件失效。 虚拟 dom 比普通 dom 更快吗首次渲染时 vdom 不具有任何优势甚至要进行更多的计算，消耗更多的内存。 vdom 的优势在于 react 的 diff 算法和批处理策略，react 在页面更新之前，提前计算好了如何进行更新和渲染 dom。vdom 主要是能在重复渲染时帮助我们计算如何实现更高效的更新，而不是说它比 dom 操作快。 虚拟 dom 中的$$typeof 属性的作用是什么它被赋值为 REACT_ELEMENT_TYPE，是一个 symbol 类型的变量，这个变量可以防止 XSS。react 渲染时会把没有$$typeof标识以及规则校验不通过的组件全都过滤掉。当你的环境不支持Symbol时，$$typeof 被赋值为 0xeac7，为什么采用 0xeac7？ 0xeac7 看起来有点像 React。 HOC 在业务场景中有哪些实际的应用 组合渲染(属性代理) // 更改 propsfunction proxyHoc(Comp) &#123; return class extends React.Component &#123; render() &#123; const newProps = &#123; name: &#x27;tayde&#x27;, age: 1, &#125;; return &lt;Comp &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;;&#125; 很方便将 Input 组件转化为受控组件 条件渲染 // 反向继承传递过来的组件function withLoading(Comp) &#123; return class extends Comp &#123; render() &#123; if (this.props.isLoading) &#123; return &lt;Loading /&gt;; &#125; else &#123; return super.render(); &#125; &#125; &#125;;&#125; 操作 props 获取 refs 操作 state可以直接通过 this.state 获取到被包裹组件的状态，并进行操作。但这样的操作容易使 state 变得难以追踪，不易维护，谨慎使用。 渲染劫持 实际应用场景： 日志打点 // 性能监控埋点function withTiming(Comp)\u0010 &#123; return class extends Comp &#123; constructor(props) &#123; super(props); this.start = Date.now(); this.end = 0; &#125; componentDidMount() &#123; super.componentDidMount &amp;&amp; super.componentDidMount(); this.end = Date.now(); console.log(`$&#123;WrappedComponent.name&#125; 组件渲染时间为 $&#123;this.end - this.start&#125; ms`); &#125; render() &#123; return super.render(); &#125; &#125;;&#125; 权限控制 function withAdminAuth(WrappedComponent) &#123; return class extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isAdmin: false, &#125;; &#125; async componentWillMount() &#123; const currentRole = await getCurrentUserRole(); this.setState(&#123; isAdmin: currentRole === &#x27;Admin&#x27;, &#125;); &#125; render() &#123; if (this.state.isAdmin) &#123; return &lt;Comp &#123;...this.props&#125; /&gt;; &#125; else &#123; return &lt;div&gt; 您没有权限查看该页面， 请联系管理员！ &lt;/div&gt;; &#125; &#125; &#125;;&#125; 双向绑定 表单校验 代码复用 HOC 和 mixin 的异同点是什么 mixin 可能会互相依赖，互相耦合，不利于代码维护 不同的 mixin 中的方法可能会相互冲突 mixin 非常多的时候组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而 HOC 的出现则可以解决这些问题 hoc 是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些情况 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 hooks 有哪些优势(react 提供的 api, hoc 和 render props 开发模式) 组件逻辑越来越复杂(componentDidMount, componentDidUpdate)尤其是生命周期函数中常常包含一些不相关的逻辑，完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。 组件之间复用状态逻辑很难，避免地狱嵌套hook 和 mixin 在用法上有一定的相似之处，但是 mixin 引入的逻辑状态是可以互相覆盖的，而多个 hooks 之间互不影响，hoc 也可能带来一定冲突，比如 props 覆盖等等，使用 hooks 则可以避免这些问题。大量使用 hoc 让我们的代码变得嵌套层级非常深，使用 hooks 我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件变得更加容易理解 class 组件 this 钩子函数相比函数，编写一个 class 可能需要更多的知识，hooks 让你可以在 class 之外使用更多的 react 的新特性 后续中展示组件需要改造成类组件需要有自己的状态管理和生命周期方法将复用逻辑提升到代码顶部。 Fiber Fiber 核心是实现了一个基于优先级和 requestIdleCallback 的循环任务调度算法 reconciliation 阶段可以把任务拆分成多个小任务 reconciliation 阶段可随时中止或恢复任务 可以根据优先级不同来选择优先执行任务 在任务队列中选出高优先级的 fiber node 执行，调用 requestIdleCallback 获取所剩时间，若执行时间超过了 deathLine，或者突然插入更高优先级的任务，则执行中断，保存当前结果，修改 tag 标记一下，设置为 pending 状态，迅速收尾并再调用一个 requestIdleCallback，等主线程释放出来再继续 恢复任务执行时，检查 tag 是被中断的任务，会接着继续做任务或者重做 在 v16 之前，reconciliation 简单说就是一个自顶向下递归算法，产出需要对当前 DOM 进行更新或替换的操作列表，一旦开始，会持续占用主线程，中断操作却不容易实现。当 JS 长时间执行（如大量计算等），会阻塞样式计算、绘制等工作，出现页面脱帧现象。所以，v16 进行了一次重写，迎来了代号为 Fiber 的异步渲染架构。 React 的核心流程可以分为两个部分: reconciliation (调度算法，也可称为 render diff 阶段): 更新 state 与 props； 调用生命周期钩子； 生成 virtual dom； 这里应该称为 Fiber Tree 更为符合； 通过新旧 vdom 进行 diff 算法，获取 vdom change； 确定是否需要重新渲染 commit(操作 dom 阶段): 如需要，则操作 dom 节点更新； 问题: 随着应用变得越来越庞大，整个更新渲染的过程开始变得吃力，大量的组件渲染会导致主进程长时间被占用，导致一些动画或高频操作出现卡顿和掉帧的情况。而关键点，便是 同步阻塞。在之前的调度算法中，React 需要实例化每个类组件，生成一颗组件树，使用 同步递归 的方式进行遍历渲染，而这个过程最大的问题就是无法 暂停和恢复。 解决方案: 解决同步阻塞的方法，通常有两种: 异步与任务分割。而 React Fiber 便是为了实现任务分割而诞生的。 在 React V16 将调度算法进行了重构， 将之前的 stack reconciler 重构成新版的 fiber reconciler，变成了具有链表和指针的单链表树遍历算法。通过指针映射，每个单元都记录着遍历当下的上一步与下一步，从而使遍历变得可以被暂停和重启。 这里我理解为是一种任务分割调度算法，主要是将原先同步更新渲染的任务分割成一个个独立的小任务单位，根据不同的优先级，将小任务分散到浏览器的空闲时间执行，充分利用主进程的事件循环机制。 class Fiber &#123; constructor(instance) &#123; this.instance = instance; // 指向第一个 child 节点 this.child = child; // 指向父节点 this.return = parent; // 指向第一个兄弟节点 this.sibling = previous; &#125;&#125; 核心思想是 任务拆分和协同，主动把执行权交给主线程，使主线程有时间空挡处理其他高优先级任务。当遇到进程阻塞的问题时，任务分割、异步调用 和 缓存策略 是三个显著的解决思路。 任务优先级(7 种) &#123; NoWork: 0, // No work is pending. SynchronousPriority: 1, // 文本输入框 TaskPriority: 2, // 当前调度正执行的任务 AnimationPriority: 3, // 动画过渡 HighPriority: 4, // 用户交互反馈 LowPriority: 5, // 数据的更新 OffscreenPriority: 6, // 预估未来需要显示的任务&#125; 为什么生命周期有了变动在 Fiber 中，reconciliation 阶段进行了任务分割，涉及到 暂停 和 重启，因此可能会导致 reconciliation 中的生命周期函数在一次更新渲染循环中被 多次调用 的情况，产生一些意外错误。 class Component extends React.Component &#123; // 替换 `componentWillReceiveProps` ， // 初始化和 update 时被调用 // 静态函数，无法使用 this static getDerivedStateFromProps(nextProps, prevState) &#123;&#125; // 判断是否需要更新组件 // 可以用于组件性能优化 shouldComponentUpdate(nextProps, nextState) &#123;&#125; // 组件被挂载后触发 componentDidMount() &#123;&#125; // 替换 componentWillUpdate // 可以在更新之前获取最新 dom 数据 getSnapshotBeforeUpdate() &#123;&#125; // 组件更新后调用 componentDidUpdate() &#123;&#125; // 组件即将销毁 componentWillUnmount() &#123;&#125; // 组件已销毁 componentDidUnMount() &#123;&#125; // 错误边界捕获全局异常 componentDidCatch() &#123;&#125;&#125; 在 constructor 初始化 state； 在 componentDidMount 中进行事件监听，并在 componentWillUnmount 中解绑事件； 在 componentDidMount 中进行数据的请求，而不是在 componentWillMount； 需要根据 props 更新 state 时，使用 getDerivedStateFromProps(nextProps, prevState)； 旧 props 需要自己存储，以便比较； public static getDerivedStateFromProps(nextProps, prevState) &#123; // 当新 props 中的 data 发生变化时，同步更新到 state 上 if (nextProps.data !== prevState.data) &#123; return &#123; data: nextProps.data &#125; &#125; else &#123; return null &#125;&#125; 可以在 componentDidUpdate 监听 props 或者 state 的变化，例如: componentDidUpdate(prevProps) &#123; // 当 id 发生变化时，重新获取数据 if (this.props.id !== prevProps.id) &#123; this.fetchData(this.props.id); &#125;&#125; 在 componentDidUpdate 使用 setState 时，必须加条件，否则将进入死循环； getSnapshotBeforeUpdate(prevProps, prevState)可以在更新之前获取最新的渲染数据，它的调用是在 render 之后， update 之前； shouldComponentUpdate: 默认每次调用 setState，一定会最终走到 diff 阶段，但可以通过 shouldComponentUpdate 的生命钩子返回 false 来直接阻止后面的逻辑执行，通常是用于做条件渲染，优化渲染的性能。 废弃的原因主要是因为 react 在 16 版本重构了调度算法，新的调度可能会导致一些生命周期被反复调用，所以在 16 中就不建议使用了，而改在其他时机中暴露出其他生命周期钩子用来替代。 SSRSSR，俗称 服务端渲染 (Server Side Render)，讲人话就是: 直接在服务端层获取数据，渲染出完成的 HTML 文件，直接返回给用户浏览器访问。前后端分离: 前端与服务端隔离，前端动态获取数据，渲染页面。 痛点: 首屏渲染性能瓶颈: 空白延迟: HTML 下载时间 + JS 下载/执行时间 + 请求时间 + 渲染时间。在这段时间内，页面处于空白的状态。 SEO 问题: 由于页面初始状态为空，因此爬虫无法获取页面中任何有效数据，因此对搜索引擎不友好。 虽然一直有在提动态渲染爬虫的技术，不过据我了解，大部分国内搜索引擎仍然是没有实现。 原理 Node 服务: 让前后端运行同一套代码成为可能。 Virtual Dom: 让前端代码脱离浏览器运行。 为什么 react 没有双向绑定React 的设计思想是单向数据流，我觉得可以这样理解为什么没有双向数据绑定： 首先，React 是纯粹的 View 层；然后，对于 React 来说双向数据绑定是什么需求? – 明显是业务需求。因为单向数据流已经满足了 View 层渲染的要求并且更易测试与控制（来自 Props 或 State），更加的清晰可控，所以在纯粹的 React 中怎么会需要双向数据绑定这种功能呢。 如果需要解决双向数据绑定问题，可以借助第三方库如 Ant Design 的 rc-form 之类，你也可以存在 State 里甚至是 Redux 里，根据需求来吧。所以 React 没有双向数据绑定不是功能的缺失或冲突问题，而是 React 只关注解决纯粹的问题： View 层。 单向数据流单向数据流是指数据的流向只能由父组件通过 props 将数据传递给子组件，不能由子组件向父组件传递数据，要想实现数据的双向绑定，只能由子组件接收父组件 props 传过来的方法去改变父组件的数据，而不是直接将子组件的数据传递给父组件。 react 和 vue 的对比react 函数式思想 纯组件传入状态和逻辑，所以单项数据流结合 immutable setState 触发重新 render 单项数据流设计成不可变数据 purecomponent 对 shouldconponentupdate 是否触发重新渲染。不可变数据返回新的 state，计算虚拟 dom 的差异。数据流 props/callback，context vue 响应式的思想 监听数据的变化 初始化时对数据的每一个属性添加 watcher 基于数据可变 数据变化时触发 watcher 回调 更新虚拟 dom。可变数据直接修改，setter 能精确监听数据变化。数据流 props/event，inject/provide react 的性能优化需要手动去判断 vue 是自动的应为要给每个属性添加 watcher 所以大型项目 state 不比较多的时候 watcher 也会比较多容易造成卡顿的情况。redux 不能直接调用 reducer 进行修改。而 vuex 有 dispatch 和 commit React 中，cloneElement 与 createElement 各是什么，有什么区别React.cloneElement(element, [props], [...children]);React.createElement(type, [props], [...children]); React Portal 有哪些使用场景在以前， react 中所有的组件都会位于 #app 下，而使用 Portals 提供了一种脱离 #app 的组件。因此 Portals 适合脱离文档流(out of flow) 的组件，特别是 position: absolute 与 position: fixed 的组件。比如模态框，通知，警告，goTop 等。 const modalRoot = document.getElementById(&#x27;modal&#x27;);class Modal extends React.Component &#123; constructor(props) &#123; super(props); this.el = document.createElement(&#x27;div&#x27;); &#125; componentDidMount() &#123; modalRoot.appendChild(this.el); &#125; componentWillUnmount() &#123; modalRoot.removeChild(this.el); &#125; render() &#123; return ReactDOM.createPortal(this.props.children, this.el); &#125;&#125; 路由传参 params 传参(刷新页面后参数不消失，参数会在地址栏显示) 路由页面：&lt;Route path=&#x27;/demo/:id&#x27; component=&#123;Demo&#125;&gt;&lt;/Route&gt; //注意要配置 /:id路由跳转并传递参数： 链接方式：&lt;Link to=&#123;&#x27;/demo/&#x27;+&#x27;6&#x27;&#125;&gt;XX&lt;/Link&gt; 或：&lt;Link to=&#123;&#123;pathname:&#x27;/demo/&#x27;+&#x27;6&#x27;&#125;&#125;&gt;XX&lt;/Link&gt; js方式：this.props.history.push(&#x27;/demo/&#x27;+&#x27;6&#x27;) 或：this.props.history.push(&#123;pathname:&#x27;/demo/&#x27;+&#x27;6&#x27;&#125;)获取参数：this.props.match.params.id //注意这里是match而非history query 传参(刷新页面后参数消失) 路由页面：&lt;Route path=&#x27;/demo&#x27; component=&#123;Demo&#125;&gt;&lt;/Route&gt; //无需配置路由跳转并传递参数： 链接方式：&lt;Link to=&#123;&#123;pathname:&#x27;/demo&#x27;,query:&#123;id:22,name:&#x27;dahuang&#x27;&#125;&#125;&#125;&gt;XX&lt;/Link&gt; js方式：this.props.history.push(&#123;pathname:&#x27;/demo&#x27;,query:&#123;id:22,name:&#x27;dahuang&#x27;&#125;&#125;)获取参数： this.props.location.query.name state 传参(刷新页面后参数不消失，state 传的参数是加密的，比 query 传参好用) 路由页面：&lt;Route path=&#x27;/demo&#x27; component=&#123;Demo&#125;&gt;&lt;/Route&gt; //无需配置路由跳转并传递参数： 链接方式： &lt;Link to=&#123;&#123;pathname:&#x27;/demo&#x27;,state:&#123;id:12,name:&#x27;dahuang&#x27;&#125;&#125;&#125;&gt;XX&lt;/Link&gt; js方式：this.props.history.push(&#123;pathname:&#x27;/demo&#x27;,state:&#123;id:12,name:&#x27;dahuang&#x27;&#125;&#125;)获取参数： this.props.location.state.name create-react-app 配置文件修改 通过 package.json 或引用第三方的库增加配置 react 构建时通过 webpack，关于 webpack 配置查看 node_modules/react-scripts/config/webpack* npm run eject 暴露所有配置文件、(安装 react-app-rewired 包)建立新的配置文件覆盖部分默认的配置 HashRouter 支持配置 package-json homepage: ‘.’修改根目录路径，BrowerRouter 修改无效还得修改服务端配置 react diff 和 vue diff 的区别 vnode 作为数据和视图的一种映射关系 相同点：都是同层比较、不同点：vue 使用双指针比较，react 是 key 集合级比较 react StrictMode 严格模式StrictMode 是一种辅助组件，可以帮助编写更好的组件。 验证是否遵循推荐写法 验证是否使用了已经废弃的写法 通过识别一些潜在的风险预防副作用 react 事件的合成机制 div 或其他元素触发事件，该事件会冒泡到 document，然后被 React 的事件处理程序捕获 事件处理程序随后将事件传递给 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。 SyntheticEvent 触发 dispatchEvent，将 event 对象交由对应的处理器执行。 为什么要合成事件机制 更好的兼容性和跨平台 react 事件机制采用了事件池，大大节省内存 方便事件的统一管理 react 处理阻止冒泡 // 阻止事件冒泡，（阻止这个合成事件，往document上冒泡，因此不会触发click方法）e.stopPropagation();// 阻止合成事件间的冒泡，不会往最外层冒了e.nativeEvent.stopImmediatePropagation(); redux 存在的问题 =&gt; 重 一份 store 树，离开页面再次进入，数据不会初始化 reducer 拆分造成汇总困难 action 的 type 管理混乱，重复问题 繁杂的使用规则，index 页面 action 和 store 引入，纯函数 reducer 大量 case 仅仅为了改变一个值 常用 UI 库 移动端ant design mobile pc 端ant design reactstrap patternfly-react semantic-ui material-ui elemental-ui 常用组件 无限滚动加载react-infinite-scroller react-list react-infinite-scroll-component 国际化react-i18next react-intl date 库momentmimentdayjs 参考react","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://luckyship.github.io/tags/react/"}]},{"title":"手写promise","date":"2021-07-17T03:18:50.000Z","path":"2021/07/17/2021-07-17-promise/","text":"Promise 规范promise 最早是在 commonjs 社区提出来的，当时提出了很多规范。比较接受的是 promise/A 规范。但是 promise/A 规范比较简单，后来人们在这个基础上，提出了 promise/A+规范，也就是实际上的业内推行的规范；es6 也是采用的这种规范，但是 es6 在此规范上还加入了 Promise.all、Promise.race、Promise.catch、Promise.resolve、Promise.reject 等方法。 我们可以通过脚本来测试我们写的 Promise 是否符合 promise/A+的规范。将我们实现的 Promise 加入以下代码： Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;; 然后通过 module.exports 导出，安装测试的脚本： npm install -g promises-aplus-tests 在实现 Promise 的目录执行以下命令： promises-aplus-tests promise.js 接下来，脚本会对照着 promise/A+的规范，对我们的脚本来一条一条地进行测试。 Promise 基本结构我们先回顾一下，我们平时都是怎么使用 Promise 的： let p = new Promise(function (resolve, reject) &#123; console.log(&quot;执行&quot;); setTimeout(function () &#123; resolve(2); &#125;, 1000);&#125;);p.then( function (res) &#123; console.log(&quot;suc&quot;, res); &#125;, function (err) &#123; console.log(&quot;err&quot;, err); &#125;); 首先看出来，Promise 是通过构造函数实例化一个对象，然后通过实例对象上的 then 方法，来处理异步返回的结果。同时，promise/A+规范规定了： promise 是一个拥有 then 方法的对象或函数，其行为符合本规范；一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。 const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(executor) &#123; let _this = this; this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 function resolve(value) &#123;&#125; function reject(reason) &#123;&#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123;&#125;;module.exports = Promise; 当我们实例化 Promise 时，构造函数会马上调用传入的执行函数 executor，我们可以试一下： let p = new Promise((resolve, reject) =&gt; &#123; console.log(&quot;执行了&quot;);&#125;); 因此在 Promise 中构造函数立马执行，同时将 resolve 函数和 reject 函数作为参数传入： function Promise(executor) &#123; let _this = this; this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 function resolve(value) &#123;&#125; function reject(reason) &#123;&#125; executor(resolve, reject);&#125; 但是 executor 也会可能存在异常，因此通过 try/catch 来捕获一下异常情况： try &#123; executor(resolve, reject);&#125; catch (e) &#123; reject(e);&#125; 不可变promise/A+规范中规定，当 Promise 对象已经由等待态（Pending）改变为执行态（Fulfilled）或者拒绝态（Rejected）后，就不能再次更改状态，且终值也不可改变。 因此我们在回调函数 resolve 和 reject 中判断，只能是 pending 状态的时候才能更改状态： function resolve(value) &#123; if (_this.state === PENDING) &#123; _this.state = FULFILLED; _this.value = value; &#125;&#125;function reject(reason) &#123; if (_this.state === PENDING) &#123; _this.state = REJECTED; _this.reason = reason; &#125;&#125; 我们更改状态的同时，将回调函数中成功的结果或者失败的原因都保存在对应的属性中，方便以后来获取。 then 实现当 Promise 的状态改变之后，不管成功还是失败，都会触发 then 回调函数。因此，then 的实现也很简单，就是根据状态的不同，来调用不同处理终值的函数。 Promise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.state === FULFILLED) &#123; typeof onFulfilled === &quot;function&quot; &amp;&amp; onFulfilled(this.value); &#125; if (this.state === REJECTED) &#123; typeof onRejected === &quot;function&quot; &amp;&amp; onRejected(this.reason); &#125;&#125;; 在规范中也说了，onFulfilled 和 onRejected 是可选的，因此我们对两个值进行一下类型的判断： onFulfilled 和 onRejected 都是可选参数。如果 onFulfilled 不是函数，其必须被忽略。如果 onRejected 不是函数，其必须被忽略 代码写到这里，貌似该有的实现方式都有了，我们来写个 demo 测试一下： let myP = new Promise(function (resolve, reject) &#123; console.log(&quot;执行&quot;); setTimeout(function () &#123; reject(3); &#125;, 1000);&#125;);myP.then( function (res) &#123; console.log(res); &#125;, function (err) &#123; console.log(err); &#125;); 然鹅，很遗憾，运行起来我们发现只打印了构造函数中的执行，下面的 then 函数根本都没有执行。我们整理一下代码的运行流畅： 当 then 里面函数运行时，resolve 由于是异步执行的，还没有来得及修改 state，此时还是 PENDING 状态；因此我们需要对异步的情况做一下处理。 支持异步那么如何让我们的 Promise 来支持异步呢？我们可以参考发布订阅模式，在执行 then 方法的时候，如果当前还是 PENDING 状态，就把回调函数寄存到一个数组中，当状态发生改变时，去数组中取出回调函数；因此我们先在 Promise 中定义一下变量： function Promise(executor) &#123; this.onFulfilled = []; //成功的回调 this.onRejected = []; //失败的回调&#125; 这样，当 then 执行时，如果还是 PENDING 状态，我们不是马上去执行回调函数，而是将其存储起来： Promise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.state === FULFILLED) &#123; typeof onFulfilled === &quot;function&quot; &amp;&amp; onFulfilled(this.value); &#125; if (this.state === REJECTED) &#123; typeof onRejected === &quot;function&quot; &amp;&amp; onRejected(this.reason); &#125; if (this.state === PENDING) &#123; typeof onFulfilled === &quot;function&quot; &amp;&amp; this.onFulfilled.push(onFulfilled); typeof onRejected === &quot;function&quot; &amp;&amp; this.onRejected.push(onRejected); &#125;&#125;; 存储起来后，当 resolve 或者 reject 异步执行的时候就可以来调用了： function resolve(value) &#123; if (_this.state === PENDING) &#123; _this.state = FULFILLED; _this.value = value; _this.onFulfilled.forEach((fn) =&gt; fn(value)); &#125;&#125;function reject(reason) &#123; if (_this.state === PENDING) &#123; _this.state = REJECTED; _this.reason = reason; _this.onRejected.forEach((fn) =&gt; fn(reason)); &#125;&#125; 有童鞋可能会提出疑问了，为什么这边 onFulfilled 和 onRejected 要存在数组中，直接用一个变量接收不是也可以么？下面看一个例子： let p = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(4); &#125;, 0);&#125;);p.then((res) =&gt; &#123; //4 res console.log(res, &quot;res&quot;);&#125;);p.then((res1) =&gt; &#123; //4 res1 console.log(res1, &quot;res1&quot;);&#125;); 我们分别调用了两次 then，如果是一个变量的话，最后肯定只会运行后一个 then，把之前的覆盖了，如果是数组的话，两个 then 都能正常运行。 至此，我们运行 demo，就能如愿以偿的看到运行结果了；一个四十行左右的简单 Promise 垫片就此完成了。这里贴一下完整的代码： const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(executor) &#123; let _this = this; this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 this.onFulfilled = []; //成功的回调 this.onRejected = []; //失败的回调 function resolve(value) &#123; if (_this.state === PENDING) &#123; _this.state = FULFILLED; _this.value = value; _this.onFulfilled.forEach((fn) =&gt; fn(value)); &#125; &#125; function reject(reason) &#123; if (_this.state === PENDING) &#123; _this.state = REJECTED; _this.reason = reason; _this.onRejected.forEach((fn) =&gt; fn(reason)); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; if (this.state === FULFILLED) &#123; typeof onFulfilled === &quot;function&quot; &amp;&amp; onFulfilled(this.value); &#125; if (this.state === REJECTED) &#123; typeof onRejected === &quot;function&quot; &amp;&amp; onRejected(this.reason); &#125; if (this.state === PENDING) &#123; typeof onFulfilled === &quot;function&quot; &amp;&amp; this.onFulfilled.push(onFulfilled); typeof onRejected === &quot;function&quot; &amp;&amp; this.onRejected.push(onRejected); &#125;&#125;; 链式调用 then相信上面的 Promise 垫片应该很容易理解，下面链式调用才是 Promise 的难点和核心点；我们对照 promise/A+规范，一步一步地来实现，我们先来看一下规范是如何来定义的： then 方法必须返回一个 promise 对象promise2 = promise1.then(onFulfilled, onRejected); 也就是说，每个 then 方法都要返回一个新的 Promise 对象，这样我们的 then 方法才能不断的链式调用；因此上面的简单垫片中 then 方法就不适用了，因为它什么都没有返回，我们对其进行简单的改写，不论 then 进行什么操作，都返回一个新的 Promise 对象： Promise.prototype.then = function (onFulfilled, onRejected) &#123; let promise2 = new Promise((resolve, reject) =&gt; &#123;&#125;); return promise2;&#125;; 我们继续看 then 的执行过程： 如果 onFulfilled 或者 onRejected 返回一个值 x ，则运行下面的 Promise 解决过程：[[Resolve]](promise2, x) 如果 onFulfilled 或者 onRejected 抛出一个异常 e ，则 promise2 必须拒绝执行，并返回拒因 e 如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值 如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的据因 首先第一点，我们知道 onFulfilled 和 onRejected 执行之后都会有一个返回值 x，对返回值 x 处理就需要用到 Promise 解决过程，这个我们下面再说；第二点需要对 onFulfilled 和 onRejected 进行异常处理，没什么好说的；第三和第四点，说的其实是一个问题，如果 onFulfilled 和 onRejected 两个参数没有传，则继续往下传（值的传递特性）；举个例子： let p = new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(3); &#125;, 1000);&#125;);p.then(1, 1) .then(&quot;&quot;, &quot;&quot;) .then() .then(function (res) &#123; //3 console.log(res); &#125;); 这里不管 onFulfilled 和 onRejected 传什么值，只要不是函数，就继续向下传入，直到有函数进行接收；因此我们对 then 方法进行如下完善： //_this是promise1的实例对象let _this = this;onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value;onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (reason) =&gt; &#123; throw reason; &#125;;let promise2 = new Promise((resolve, reject) =&gt; &#123; if (_this.state === FULFILLED) &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; else if (_this.state === REJECTED) &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; else if (_this.state === PENDING) &#123; _this.onFulfilled.push(() =&gt; &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125;); _this.onRejected.push(() =&gt; &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125;); &#125;&#125;); 我们发现函数中有一个 resolvePromise，就是上面说的 Promise 解决过程，它是对新的 promise2 和上一个执行结果 x 的处理，由于具有复用性，我们把它抽成一个单独的函数，这也是上面规范中定义的第一点。 由于 then 的回调是异步执行的，因此我们需要把 onFulfilled 和 onRejected 执行放到异步中去执行，同时做一下错误的处理： //其他代码略if (_this.state === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;);&#125; else if (_this.state === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;);&#125; else if (_this.state === PENDING) &#123; _this.onFulfilled.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;); _this.onRejected.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;);&#125; Promise 解决过程 Promise 解决过程是一个抽象的操作，其需输入一个 promise 和一个值，我们表示为 [[Resolve]](promise, x)，如果 x 有 then 方法且看上去像一个 Promise ，解决程序即尝试使 promise 接受 x 的状态；否则其用 x 的值来执行 promise 。 这段话比较抽象，通俗一点的来说就是 promise 的解决过程需要传入一个新的 promise 和一个值 x，如果传入的 x 是一个 thenable 的对象（具有 then 方法），就接受 x 的状态： //promise2：新的Promise对象//x：上一个then的返回值//resolve：promise2的resolve//reject：promise2的rejectfunction resolvePromise(promise2, x, resolve, reject) &#123;&#125; 定义好函数后，来看具体的操作说明： x 与 promise 相等 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise x 为 Promise 如果 x 处于等待态， promise 需保持为等待态直至 x 被执行或拒绝 如果 x 处于执行态，用相同的值执行 promise 如果 x 处于拒绝态，用相同的据因拒绝 promise 1、x 为对象或函数 1、 把 x.then 赋值给 then 2、 如果取 x.then 的值时抛出错误 e ，则以 e 为据因拒绝 * promise 3、 如果 then 是函数，将 x 作为函数的作用域 this 调用之。传递两个回调函数作为参数，第一个参数叫做 resolvePromise ，第二个参数叫做 rejectPromise: 1、 如果 resolvePromise 以值 y 为参数被调用，则运行 * [Resolve] 2、 如果 rejectPromise 以据因 r 为参数被调用，则以据因 * r 拒绝 promise 3、 如果 resolvePromise 和 rejectPromise 均被调用，或* 者被同一参数调用了多次，则 * 优先采用首次调用并忽略剩* 下的调用 4、 如果 then 不是函数，以 x 为参数执行 promise 2、 如果 x 不为对象或者函数，以 x 为参数执行 promise首先第一点，如果 x 和 promise 相等，这是一种什么情况呢，就是相当于把自己返回出去了： let p = new Promise(function (resolve, reject) &#123; resolve(3);&#125;);//Uncaught (in promise) TypeError: Chaining cycle detected for promise #&lt;Promise&gt;let p2 = p.then(function () &#123; return p2;&#125;); 这样会陷入一个死循环中，因此我们首先要把这种情况给排除掉： function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&quot;Chaining cycle&quot;)); &#125;&#125; 接下来就是对不同情况的判断了，首先我们把 x 为对象或者函数的情况给判断出来： function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&quot;Chaining cycle&quot;)); &#125; if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; //函数或对象 &#125; else &#123; //普通值 resolve(x); &#125;&#125; 如果 x 为对象或函数，就把 x.then 赋值给 then 好理解，但是第二点取 then 有可能会报错是为什么呢？这是因为需要考虑到所有出错的情况（防小人不防君子），如果有人实现 Promise 对象的时候使用 Object.defineProperty()恶意抛错，导致程序崩溃，就像这样： let Promise = &#123;&#125;;Object.defineProperty(Promise, &quot;then&quot;, &#123; get: function () &#123; throw Error(&quot;error&quot;); &#125;,&#125;);//Uncaught Error: errorPromise.then; 因此，我们取 then 的时候也需要 try/catch： //其他代码略if (x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;)) &#123; //函数或对象 try &#123; let then = x.then; &#125; catch (e) &#123; reject(e); &#125;&#125; 取出 then 后，回到 3.3，判断如果是一个函数，就将 x 作为函数的作用域 this 调用，同时传入两个回调函数作为参数。 //其他代码略try &#123; let then = x.then; if (typeof then === &quot;function&quot;) &#123; then.call( x, (y) =&gt; &#123; resolve(y); &#125;, (r) =&gt; &#123; reject(r); &#125; ); &#125; else &#123; resolve(x); &#125;&#125; catch (e) &#123; reject(e);&#125; 这样，我们的链式调用就能顺利的调用起来了；但是还有一种特殊的情况，如果 resolve 的 y 值还是一个 Promise 对象，这时就应该继续执行，比如下面的例子： let p1 = new Promise((resolve, reject) =&gt; &#123; resolve(&quot;p1&quot;);&#125;);p1.then((res) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; resolve( new Promise((resolve, reject) =&gt; &#123; resolve(&quot;p2&quot;); &#125;) ); &#125;);&#125;).then((res1) =&gt; &#123; //Promise &#123;state: &quot;fulfilled&quot;, value: &quot;p2&quot;&#125; console.log(res1);&#125;); 这时候第二个 then 打印出来的是一个 promise 对象；我们应该继续递归调用 resolvePromise（参考规范 3.3.1），因此，最终 resolvePromise 的完整代码如下： function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&quot;Chaining cycle&quot;)); &#125; if ((x &amp;&amp; typeof x === &quot;object&quot;) || typeof x === &quot;function&quot;) &#123; let used; try &#123; let then = x.then; if (typeof then === &quot;function&quot;) &#123; then.call( x, (y) =&gt; &#123; if (used) return; used = true; resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; if (used) return; used = true; reject(r); &#125; ); &#125; else &#123; if (used) return; used = true; resolve(x); &#125; &#125; catch (e) &#123; if (used) return; used = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125; 到这里，我们的 Promise 也能够完整的实现链式调用了；然后把代码用 promises-aplus-tests 测试一下，最后完整的代码如下。 const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;function Promise(executor) &#123; let _this = this; this.state = PENDING; //状态 this.value = undefined; //成功结果 this.reason = undefined; //失败原因 this.onFulfilled = []; //成功的回调 this.onRejected = []; //失败的回调 function resolve(value) &#123; if (_this.state === PENDING) &#123; _this.state = FULFILLED; _this.value = value; _this.onFulfilled.forEach((fn) =&gt; fn(value)); &#125; &#125; function reject(reason) &#123; if (_this.state === PENDING) &#123; _this.state = REJECTED; _this.reason = reason; _this.onRejected.forEach((fn) =&gt; fn(reason)); &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); &#125;&#125;Promise.prototype.then = function (onFulfilled, onRejected) &#123; //_this是promise1的实例对象 let _this = this; onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (value) =&gt; value; onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (reason) =&gt; &#123; throw reason; &#125;; let promise2 = new Promise((resolve, reject) =&gt; &#123; if (_this.state === FULFILLED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125; else if (_this.state === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125; else if (_this.state === PENDING) &#123; _this.onFulfilled.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onFulfilled(_this.value); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;); _this.onRejected.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; let x = onRejected(_this.reason); resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;); &#125;); &#125; &#125;); return promise2;&#125;;function resolvePromise(promise2, x, resolve, reject) &#123; if (promise2 === x) &#123; reject(new TypeError(&quot;Chaining cycle&quot;)); &#125; if ((x &amp;&amp; typeof x === &quot;object&quot;) || typeof x === &quot;function&quot;) &#123; let used; try &#123; let then = x.then; if (typeof then === &quot;function&quot;) &#123; then.call( x, (y) =&gt; &#123; if (used) return; used = true; resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; if (used) return; used = true; reject(r); &#125; ); &#125; else &#123; if (used) return; used = true; resolve(x); &#125; &#125; catch (e) &#123; if (used) return; used = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;Promise.defer = Promise.deferred = function () &#123; let dfd = &#123;&#125;; dfd.promise = new Promise((resolve, reject) =&gt; &#123; dfd.resolve = resolve; dfd.reject = reject; &#125;); return dfd;&#125;;module.exports = Promise; 转载从零开始手写 Promise","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"js防抖和节流","date":"2021-07-10T04:09:42.000Z","path":"2021/07/10/2021-07-10-js-debounce-throttle/","text":"防抖(debounce)在第一次触发事件时，不立即执行函数，而是给出一个期限值比如200ms ，然后：如果在 200ms 内没有再次触发滚动事件，那么就执行函数如果在 200ms 内再次触发滚动事件，那么当前的计时取消，重新开始计时 function debounce(func, wait) &#123; var timer = null; return function () &#123; var self = this; var args = arguments; if (timer) clearTimeout(timer); timer = setTimeout(function () &#123; typeof func === &#x27;function&#x27; &amp;&amp; func.apply(self, args); &#125;, wait); &#125;;&#125; 节流(throttle)类似控制阀门一样定期开放的函数，也就是让函数执行一次后，在某个时间段内暂时失效，过了这段时间后再重新激活（类似于技能冷却时间） 如果短时间内大量触发同一事件，那么在函数执行一次之后，该函数在指定的时间期限内不再工作，直至过了这段时间才重新生效。 function throttle(func, wait) &#123; var timer = null; return function () &#123; var self = this; var args = arguments; if (timer) &#123; return; &#125; typeof func === &#x27;function&#x27; &amp;&amp; func.apply(self, args); timer = setTimeout(function () &#123; timer = null; &#125;, wait); &#125;;&#125; 应用讲完了这两个技巧，下面介绍一下平时开发中常遇到的场景： 防抖 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖 文本编辑器实时保存，当无任何更改操作一秒后进行保存 节流 DOM 元素的拖拽功能实现（mousemove） 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"js深拷贝和浅拷贝","date":"2021-05-26T14:29:56.000Z","path":"2021/05/26/2021-05-26-js-clone-deep/","text":"数组深拷贝数组深拷贝实现主要用到 生成新数组 的方法 silcelet a = [1, 2, 3];a.slice(0); concatlet a = [1, 2, 3];a.concat(); … 运算符let a = [1, 2, 3];let b = [...a]; 对象深拷贝JSON 方法利用 JSON.stringify() 和 JSON.parse() 方法 &gt; JSON.parse(JSON.stringify(&#123; a: 1&#125;)) &#123; a: 1&#125; 弊端// 函数var source = &#123; name: function () &#123; console.log(1); &#125;, child: &#123; name: &#x27;child&#x27;, &#125;,&#125;;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefined// 正则var source = &#123; name: function () &#123; console.log(1); &#125;, child: new RegExp(&#x27;e&#x27;),&#125;;var target = JSON.parse(JSON.stringify(source));console.log(target.name); //undefinedconsole.log(target.child); //Object &#123;&#125;// undefinedJSON.stringify(&#123; a: undefined &#125;);(&#x27;&#123;&#125;&#x27;);// NaN、Infinity和-InfinityJSON.stringify(&#123; a: NaN, b: Infinity, c: -Infinity,&#125;);(&#x27;&#123;&quot;a&quot;:null,&quot;b&quot;:null,&quot;c&quot;:null&#125;&#x27;); Object.assign 只能一级深拷贝一级属性中有对象时， 二级对象为浅拷贝，一级对象为深拷贝 let obj = &#123; a: 1, b: 2, c: &#123; d: 1 &#125; &#125;; // undefinedlet obj2 = Object.assign(&#123;&#125;, obj); // undefinedobj2.a = 2; // 2obj.a; // 1obj.c.d = 2; // 2obj2.c.d; // 2 递归调用var cloneObj = function (obj) &#123; var str, newobj = obj.constructor === Array ? [] : &#123;&#125;; if (typeof obj !== &#x27;object&#x27;) &#123; return; &#125; else &#123; for (var i in obj) &#123; newobj[i] = typeof obj[i] === &#x27;object&#x27; ? cloneObj(obj[i]) : obj[i]; &#125; &#125; return newobj;&#125;;","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"导出csv文件","date":"2021-05-20T10:11:50.000Z","path":"2021/05/20/2021-05-20-export-csv-file/","text":"支持IE11, chrome, firefox, safri tested on IE 11, Chrome 36 and Firefox 29 function exportToCsv(filename, rows) &#123; var processRow = function(row) &#123; var finalVal = &#x27;&#x27;; for (var j = 0; j &lt; row.length; j++) &#123; var innerValue = row[j] === null ? &#x27;&#x27; : row[j].toString(); if (row[j] instanceof Date) &#123; innerValue = row[j].toLocaleString(); &#125;; var result = innerValue.replace(/&quot;/g, &#x27;&quot;&quot;&#x27;); if (result.search(/(&quot;|,|\\n)/g) &gt;= 0) result = &#x27;&quot;&#x27; + result + &#x27;&quot;&#x27;; if (j &gt; 0) finalVal += &#x27;,&#x27;; finalVal += result; &#125; return finalVal + &#x27;\\n&#x27;; &#125;; var csvFile = &#x27;&#x27;; for (var i = 0; i &lt; rows.length; i++) &#123; csvFile += processRow(rows[i]); &#125; var blob = new Blob([csvFile], &#123; type: &#x27;text/csv;charset=utf-8;&#x27; &#125;); if (navigator.msSaveBlob) &#123; // IE 10+ navigator.msSaveBlob(blob, filename); &#125; else &#123; var link = document.createElement(&quot;a&quot;); if (link.download !== undefined) &#123; // feature detection // Browsers that support HTML5 download attribute var url = URL.createObjectURL(blob); link.setAttribute(&quot;href&quot;, url); link.setAttribute(&quot;download&quot;, filename); link.style.visibility = &#x27;hidden&#x27;; document.body.appendChild(link); link.click(); document.body.removeChild(link); &#125; &#125;&#125;","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"玩转git","date":"2021-05-15T06:49:47.000Z","path":"2021/05/15/2021-05-15-git-use/","text":"git 作为当前最流行的代码管理工具，用好 git 可以有效的提高团队开发效率 常用命令git add# 提交当前目录下的所有变更文件git add .# 提交当前仓库下的所有变更文件git add -all git commit# 提交commit 信息git commit -m &quot;sss&quot;# 提交commit 信息(可以多行)git commit -v# 修改上次提交commit的信息git commit --amend git fetch将某个远程主机的更新，全部/分支 取回本地（此时之更新了 Repository）它取回的代码对你本地的开发代码没有影响，如需彻底更新需合并或使用 git pull git pull拉取远程主机某分支的更新，再与本地的指定分支合并（相当与 fetch 加上了合并分支功能的操作） git push将本地分支的更新，推送到远程主机，其命令格式与 git pull 相似git push -f 强制推送( 如果本地commit和远程commit有冲突时，覆盖远程commit ) 分支操作 使用 Git 下载指定分支命令为：git clone -b 分支名仓库地址 拉取远程新分支 git checkout -b serverfix origin/serverfix 合并本地分支 git merge hotfix：(将 hotfix 分支合并到当前分支) 合并远程分支 git merge origin/serverfix 删除本地分支 git branch -d hotfix：(删除本地 hotfix 分支) 删除远程分支 git push origin --delete serverfix or git branch -D master; //删除本地master分支git push origin :master; //删除远程master分支git pull origin master:master // 远程:本地git push origin master:master // 本地:远程git push --set-upstream origin master // 将本地分支与远程同名分支相关联 上传新命名的本地分支：git push origin newName; 创建新分支：git branch branchName：(创建名为 branchName 的本地分支) 切换到新分支：git checkout branchName：(切换到 branchName 分支) 创建并切换分支：git checkout -b branchName：(相当于以上两条命令的合并) 查看本地分支：git branch 查看远程仓库所有分支：git branch -a 本地分支重命名： git branch -m oldName newName 重命名远程分支对应的本地分支：git branch -m oldName newName 把修改后的本地分支与远程分支关联：git branch --set-upstream-to origin/newName git 分支提交、合并常见问题主分支领先当前分支当前分支已经提交 commitgit checkout mastergit pullgit checkout localgit rebase master rebase 会自动合并领先的 commit 未提交 commit不用切换分支，即可同步主分支最新代码 git pull origin master# 有冲突解决冲突git commit git 回退git reset删除指定的 commit # 修改版本库，保留暂存区，保留工作区# 将版本库软回退1个版本，软回退表示将本地版本库的头指针全部重置到指定版本，且将这次提交之后的所有变更都移动到暂存区。git reset --soft HEAD~1# 修改版本库，修改暂存区，修改工作区# 将版本库回退1个版本，不仅仅是将本地版本库的头指针全部重置到指定版本，也会重置暂存区，并且会将工作区代码也回退到这个版本git reset --hard HEAD~1# git版本回退，回退到特定的commit_id版本，可以通过git log查看提交历史，以便确定要回退到哪个版本(commit 之后的即为ID);git reset --hard commit_id git revert撤销 某次操作，此次操作之前和之后的 commit 和 history 都会保留，并且把这次撤销 作为一次最新的提交 # 撤销前一次 commitgit revert HEAD# 撤销前前一次 commitgit revert HEAD^# (比如：fa042ce57ebbe5bb9c8db709f719cec2c58ee7ff）撤销指定的版本，撤销也会作为一次提交进行保存。git revert commit git revert 是提交一个新的版本，将需要 revert 的版本的内容再反向修改回去，版本会递增，不影响之前提交的内容 git revert 和 git reset 的区别 git revert是用一次新的 commit 来回滚之前的 commit，git reset是直接删除指定的 commit。 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别。因为git revert是用一次逆向的 commit“中和”之前的提交，因此日后合并老的 branch 时，导致这部分改变不会再次出现，但是git reset是之间把某些 commit 在某个 branch 上删除，因而和老的 branch 再次 merge 时，这些被回滚的 commit 应该还会被引入。 git reset 是把 HEAD 向后移动了一下，而git revert是 HEAD 继续前进，只是新的 commit 的内容和要 revert 的内容正好相反，能够抵消要被 revert 的内容。 git commit 相关git commit 提交多行 commit 信息git commit -v git 修改 commit 信息1. 提交信息出错更改 commit 信息 git commit --amend -m “新提交消息” 2. 漏提交commit 时，遗漏提交部分更新，有两种解决方案： 方案一：再次 commit git commit -m #提交消息 此时，git 上会出现两次 commit 方案二：遗漏文件提交到之前 commit 上 git add missed-file # missed-file 为遗漏提交文件git commit --amend --no-edit --no-edit 表示提交消息不会更改，在 git 上仅为一次提交 修改历史的 commitgit rebase -i HEAD~3表示要修改当前版本的倒数第三次状态.这个命令出来之后，会出来三行东东： pick:*******pick:*******pick:******* 如果你要修改哪个，就把那行的 pick 改成 edit，然后保存退出(点击 esc，输入 ZZ 退出)这时通过git log你可以发现，git 的最后一次提交已经变成你选的那个了，这时再使用：git commit --amend 来对 commit 进行修改。修改完成后使用git rebase --continue然后将变化 push 到远程：git push origin HEAD:master --force git 合并多个 commit过去总是使用 git reset --soft 回退到之前的状态，再 commit 后 push orgin master -f 强推到远程库，能够覆盖掉之前的 commit 。 但在团队协作时，每次 commit 前还需要 rebase upstream，这会自动将一些其他人做的修改也自动 merge 到本地的源码中。如果此时希望覆盖前一次 commit ，reset 到之前的状态后，再次 commit 的内容就包含了其他人的修改，这不是我们希望看到的。因此，我们需要使用 git rebase -i 。 基本步骤 git log 查看所有 commit 的情况，找到自己想要合并的 commit 之前的那个 commit 的 ssh 码(前 7 位)； git rebase -i 43jk2l3，这样会弹出一个文本编辑器；撤销 commitgit reset –softHEAD^ 上个 commit^^上上个 commitHEAD~2 最近 2 次的提交 修改 pick 为 squash 会将这个 commit 合并到前一个 commit 中，保存退出； 提示写下新的 commit message，之前的 message 可以用#注释掉，保存退出； 此时再 git log 就会发现，两个 commit 被合并到一个 commit 中。 修改 push 到远程的 commit git log git rebase -i Head~8 pick 修改为 edit git commit –amend 修改新的 commit message 保存 (修改作者信息 –author “luckyship &#x78;&#x78;&#x78;&#x40;&#x78;&#120;&#x78;&#x2e;&#x63;&#x6f;&#x6d;“) git rebase –continue // 处理完合并后 然后 git push -f 同理 git merge –continue git push -f Commit message 前缀规范提要 code info feat:msg 新功能 feature fix:msg 修复 bug merge:msg merge 信息 docs:msg 文档修改 style:msg 格式，不影响代码运行的变动 refactor: msg 重构即不是新增功能，也不是修改 bug 的代码变动 test:msg 增加测试 chore:msg 构建过程或辅助工具的变动 rm:msg 删除文件或代码 git stash(暂存区)暂存git stash 可用来暂存当前正在进行的工作，比如想 pull 最新代码又不想 commit ， 或者另为了修改一个紧急的 bug ，先 stash，使返回到自己上一个 commit, ，改完 bug 之后再 stash pop , 继续原来的工作； 添加缓存栈： git stash ; 查看缓存栈： git stash list ; 推出缓存栈： git stash pop ; 取出特定缓存内容： git stash apply stash@&#123;1&#125; ; 恢复误删除的 stash# 显示所有不可访问对象git fask --unreachablegit show 302063e31742cbce7c5fdb917edf520183154cc1 &gt; D:\\recovery\\backup.txt 在使用 git fsck –unreachable 命令输出的很多文件里面，有很多是带有 commit 和 tree 的标识的，这些可以使用 git stash apply 加标记号进行找回。而 blob 的文件是只能手动拷贝的，或者像上面一样使用&gt; 输出到指定的路径去 rebase 和 mege 的区别1. 拉取代码 pull –rebase在团队协作过程中，假设你和你的同伴在本地中分别有各自的新提交，而你的同伴先于你 push 了代码到远程分支上，所以你必须先执行 git pull 来获取同伴的提交，然后才能 push 自己的提交到远程分支。 而按照 Git 的默认策略，如果远程分支和本地分支之间的提交线图有分叉的话（即不是 fast-forwarded），Git 会执行一次 merge 操作，因此产生一次没意义的提交记录，从而造成了像上图那样的混乱。 其实在 pull 操作的时候，，使用 git pull --rebase 选项即可很好地解决上述问题。 加上 --rebase 参数的作用是，提交线图有分叉的话，Git 会 rebase 策略来代替默认的 merge 策略。 假设提交线图在执行 pull 前是这样的： A---B---C remotes/origin/master /D---E---F---G master 如果是执行 git pull 后，提交线图会变成这样： A---B---C remotes/origin/master / \\D---E---F---G---H master 结果多出了 H 这个没必要的提交记录。如果是执行 git pull --rebase 的话，提交线图就会变成这样： remotes/origin/master |D---E---A---B---C---F&#x27;---G&#x27; master F G 两个提交通过 rebase 方式重新拼接在 C 之后，多余的分叉去掉了，目的达到。 小结大多数时候，使用 git pull --rebase 是为了使提交线图更好看，从而方便 code review。 不过，如果你对使用 git 还不是十分熟练的话，我的建议是 git pull --rebase 多练习几次之后再使用，因为 rebase 在 git 中，算得上是『危险行为』。 另外，还需注意的是，使用 git pull --rebase 比直接 pull 容易导致冲突的产生，如果预期冲突比较多的话，建议还是直接 pull。 注意：git pull = git fetch + git mergegit pull –rebase = git fetch + git rebase 2. 合代码 merge –no-ff上述的 git pull --rebase 策略目的是修整提交线图，使其形成一条直线，而即将要用到的 git merge --no-ff &lt;branch-name&gt; 策略偏偏是反行其道，刻意地弄出提交线图分叉出来。 假设你在本地准备合并两个分支，而刚好这两个分支是 fast-forwarded 的，那么直接合并后你得到一个直线的提交线图，当然这样没什么坏处，但如果你想更清晰地告诉你同伴：这一系列的提交都是为了实现同一个目的，那么你可以刻意地将这次提交内容弄成一次提交线图分叉。 执行 git merge --no-ff &lt;branch-name&gt; 的结果大概会是这样的： |0 asdasd|0 asdasd|\\| 0 asdasd| || 0 asdasd| || 0 asdasd| || 0 asdasd| /0 asdasd|0 asdasd 中间的分叉线路图很清晰的显示这些提交都是为了实现 complete adjusting user domains and tags 更进一步往往我的习惯是，在合并分支之前（假设要在本地将 feature 分支合并到 dev 分支），会先检查 feature 分支是否『部分落后』于远程 dev 分支： git checkout devgit pull # 更新 dev 分支git log feature..dev 如果没有输出任何提交信息的话，即表示 feature 对于 dev 分支是 up-to-date 的。如果有输出的话而马上执行了 git merge --no-ff 的话，提交线图会变成这样： |0 asdasd|0 asdasd|\\| 0 asdasd| || 0 asdasd| |0 | asdasd| |0 | asdasd| /0 asdasd|0 asdasd 所以这时在合并前，通常我会先执行： git checkout featuregit rebase dev 这样就可以将 feature 重新拼接到更新了的 dev 之后，然后就可以合并了，最终得到一个干净舒服的提交线图。 再次提醒：像之前提到的，rebase 是『危险行为』，建议你足够熟悉 git 时才这么做，否则的话是得不偿失的。 总结使用 git pull --rebase 和 git merge --no-ff 其实和直接使用 git pull git merge 得到的代码应该是一样。 使用 git pull --rebase 主要是为是将提交的线图平坦化，而 git merge --no-ff 则是刻意制造分叉。 git rebase 和 git merge 主要的区别在于是否保留分支的 commit 提交节点，rebase 会给你一个简洁的线性历史树。rebase 适合小分支，大分支还是使用 merge –squash。 git patchgit patch 会生成一个补丁文件，这样在不能直接 git pull 和 git push 的情况下，直接把补丁文件合入 git 项目中 # 1为最新commit往前的commit的数量$ git format-patch -1$ git am xxx.patch git cherry-pick现网发现了 bug，现网分支需要修改代码出补丁版本；同时，代码也要合入主干，保证主干版本没问题。简言之，相同的代码，要合入两个分支，怎么办 $ git branch* dev master$ git cherry-pick 4c805e2 同步 Github fork 出来的分支1、配置 remote，指向原始仓库git remote add upstream https://github.com/luckyship/jelly.git 2、获取上游分支上游仓库获取到分支，及相关的提交信息，它们将被保存在本地的 upstream/master 分支 git fetch upstream# remote: Counting objects: 75, done.# remote: Compressing objects: 100% (53/53), done.# remote: Total 62 (delta 27), reused 44 (delta 9)# Unpacking objects: 100% (62/62), done.# From https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY# * [new branch] master -upstream/master 3、切换到本地的 master 分支git checkout master# Switched to branch &#x27;master&#x27; 4、合并分支把 upstream/master 分支合并到本地的 master 分支，本地的 master 分支便跟上游仓库保持同步了，并且没有丢失本地的修改。 git merge upstream/master# Updating a422352..5fdff0f# Fast-forward# README | 9 -------# README.md | 7 ++++++# 2 files changed, 7 insertions(+), 9 deletions(-)# delete mode 100644 README# create mode 100644 README.md 5、上传到自己的远程仓库中git push git 配置邮箱和用户名查看git config user.namegit config user.email 修改git config --global user.name &quot;username&quot;git config --global user.email &quot;email&quot; SSH 查看是否生成了 SSH 公钥 $ cd ~/.ssh$ lsid_rsa id_rsa.pub known_hosts 其中 id_rsa 是私钥，id_rsa.pub 是公钥。 如果没有那就开始生成，设置全局的 user.name 与 user.email git config --list # 查看是否设置了user.name与user.email，没有的话，去设置# 设置全局的user.name与user.emailgit config --global user.name &quot;XX&quot;git config --global user.email &quot;XX&quot; 输入 ssh-keygen 即可（或ssh-keygen -t rsa -C &quot;email&quot;） $ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /Users/schacon/.ssh/id_rsa.Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.The key fingerprint is: 生成之后获取公钥内容，输入 cat ~/.ssh/id_rsa.pub 即可， 复制 ssh-rsa 一直到 .local 这一整段内容 $ cat ~/.ssh/id_rsa.pubssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSUGPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XAt3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/EnmZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbxNrRFi9wrf+M7Q== schacon@agadorlaptop.local 打开 GitLab 或者 GitHub，点击头像，找到设置页 左侧找到 SSH keys 按钮并点击，输入刚刚复制的公钥即可 git push 报 HTTP Basic: Access denied 错误 永久记住密码git config --global credential.helper store 如果没 --global ，则在当前项目下的.git/config 文件中添加。 默认记住 15 分钟 git config –global credential.helper cache 自定义配置记住 1 小时： git config –global credential.helper ‘cache –timeout=3600’ 解决方案： 如果账号密码有变动 用这个命令 git config --system --unset credential.helper (清除用户名密码)重新输入账号密码应该就能解决了 如果用了第一个命令 还不能解决问题那么 用这个命令：git config –global http.emptyAuth true 文件名过长错误Filename too long warning: Clone succeeded, but checkout failed. git config --system core.longpaths true .gitignore 更新后生效：git rm -r --cached .git add .git commit -m .gitignore is now working git commit -v 使用 vim$ cat ~/.gitconfig[user] email = chaox.a.xu@intel.com name = Xu Chao[core] editor = vim -U none # git commit -sv 可以用vim git 统计查看 git 上个人代码量git log --author=&quot;username&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#x27; - 统计每个人的增删行数git log --format=&#x27;%aN&#x27; | sort -u | while read name; do echo -en &quot;$name\\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\\n&quot;, add, subs, loc &#125;&#x27; -; done 查看仓库提交者排名前 5git log --pretty=&#x27;%aN&#x27; | sort | uniq -c | sort -k1 -n -r | head -n 5 贡献者统计git log --pretty=&#x27;%aN&#x27; | sort -u | wc -l 提交数统计git log --oneline | wc -l 参考本文参考了git 相关问题场景和命令 客户端 sourcetree Tower sublimemerge gitkraken git-fork gitup 练习 Git 命令可视化学习","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"git","slug":"git","permalink":"https://luckyship.github.io/tags/git/"}]},{"title":"typescript基础","date":"2021-05-12T14:27:38.000Z","path":"2021/05/12/2021-05-12-typescript-base/","text":"TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。 区别 TypeScript JavaScript JavaScript 的超集用于解决大型项目的代码复杂性 一种脚本语言，用于创建动态网页 可以在编译期间发现并纠正错误 作为一种解释型语言，只能在运行时发现错误 强类型，支持静态和动态类型 弱类型，没有静态类型选项 最终被编译成 JavaScript 代码，使浏览器可以理解 可以直接在浏览器中使用 支持模块、泛型和接口 不支持模块，泛型或接口 支持 ES3，ES4，ES5 和 ES6 等 不支持编译其他 ES3，ES4，ES5 或 ES6 功能 社区的支持仍在增长，而且还不是很大 大量的社区支持以及大量文档和解决问题的支持 安装npm install - g typescript 编译tsc helloworld.ts// helloworld.ts =&gt; helloworld.js 在线学习语法和特性 类型 (11 种)Booleanlet isDone: boolean = false;// ES5：var isDone = false; Numberlet count: number = 10;// ES5：var count = 10; Stringlet name: string = &#x27;cosyer&#x27;;// ES5：var name = &#x27;cosyer&#x27;; Arraylet list: number[] = [1, 2, 3];// ES5：var list = [1,2,3];let list: Array&lt;number&gt; = [1, 2, 3]; // Array&lt;number&gt;泛型语法// ES5：var list = [1,2,3]; Enum使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。 数字枚举enum Direction &#123; NORTH, SOUTH, EAST, WEST,&#125;let dir: Direction = Direction.NORTH; 默认情况下，NORTH 的初始值为 0，其余的成员会从 1 开始自动增长。换句话说，Direction. SOUTH 的值为 1，Direction. EAST 的值为 2，Direction. WEST 的值为 3。上面的枚举示例代码经过编译后会生成以下代码： &#x27;use strict&#x27;;var Direction;(function (Direction) &#123; Direction[(Direction[&#x27;NORTH&#x27;] = 0)] = &#x27;NORTH&#x27;; Direction[(Direction[&#x27;SOUTH&#x27;] = 1)] = &#x27;SOUTH&#x27;; Direction[(Direction[&#x27;EAST&#x27;] = 2)] = &#x27;EAST&#x27;; Direction[(Direction[&#x27;WEST&#x27;] = 3)] = &#x27;WEST&#x27;;&#125;)(Direction || (Direction = &#123;&#125;));var dir = Direction.NORTH; 也可以设置 NORTH 的初始值，比如： enum Direction &#123; NORTH = 3, SOUTH, EAST, WEST,&#125; 字符串枚举enum Direction &#123; NORTH = &quot;NORTH&quot;, SOUTH = &quot;SOUTH&quot;, EAST = &quot;EAST&quot;, WEST = &quot;WEST&quot;,&#125; 编译生成： &#x27;use strict&#x27;;var Direction;(function (Direction) &#123; Direction[&#x27;NORTH&#x27;] = &#x27;NORTH&#x27;; Direction[&#x27;SOUTH&#x27;] = &#x27;SOUTH&#x27;; Direction[&#x27;EAST&#x27;] = &#x27;EAST&#x27;; Direction[&#x27;WEST&#x27;] = &#x27;WEST&#x27;;&#125;)(Direction || (Direction = &#123;&#125;)); 异构枚举异构枚举的成员值是数字和字符串的混合： enum Enum &#123; A, B, C = &quot;C&quot;, D = &quot;D&quot;, E = 8, F,&#125; 编译生成： &#x27;use strict&#x27;;var Enum;(function (Enum) &#123; Enum[(Enum[&#x27;A&#x27;] = 0)] = &#x27;A&#x27;; Enum[(Enum[&#x27;B&#x27;] = 1)] = &#x27;B&#x27;; Enum[&#x27;C&#x27;] = &#x27;C&#x27;; Enum[&#x27;D&#x27;] = &#x27;D&#x27;; Enum[(Enum[&#x27;E&#x27;] = 8)] = &#x27;E&#x27;; Enum[(Enum[&#x27;F&#x27;] = 9)] = &#x27;F&#x27;;&#125;)(Enum || (Enum = &#123;&#125;)); 数字枚举相对字符串枚举多了 “反向映射”： console.log(Enum.A); //输出：0console.log(Enum[0]); // 输出：A Any在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。 let notSure: any = 666;notSure = &#x27;cosyer&#x27;;notSure = false; any 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。 let value: any;value.foo.bar; // OKvalue.trim(); // OKvalue(); // OKnew value(); // OKvalue[0][1]; // OK 在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。AnyScript 2333. Unknown就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。下面我们来看一下 unknown 类型的使用示例： let value: unknown;value = true; // OKvalue = 42; // OKvalue = &#x27;Hello World&#x27;; // OKvalue = []; // OKvalue = &#123;&#125;; // OKvalue = Math.random; // OKvalue = null; // OKvalue = undefined; // OKvalue = new TypeError(); // OKvalue = Symbol(&#x27;type&#x27;); // OK 对 value 变量的所有赋值都被认为是类型正确的。但是，当我们尝试将类型为 unknown 的值赋值给其他类型的变量时会发生什么？ let value: unknown;let value1: unknown = value; // OKlet value2: any = value; // OKlet value3: boolean = value; // Errorlet value4: number = value; // Errorlet value5: string = value; // Errorlet value6: object = value; // Errorlet value7: any[] = value; // Errorlet value8: Function = value; // Error unknown 类型只能被赋值给 any 类型和 unknown 类型本身。直观地说，这是有道理的：只有能够保存任意类型值的容器才能保存 unknown 类型的值。毕竟我们不知道变量 value 中存储了什么类型的值。 将 value 变量类型设置为 unknown 后，这些操作都不再被认为是类型正确的。通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。 Tuple众所周知，数组一般由同种类型的值组成，但有时我们需要在单个变量中存储不同类型的值，这时候我们就可以使用元组。在 JavaScript 中是没有元组的，元组是 TypeScript 中特有的类型，其工作方式类似于数组。 元组可用于定义具有有限数量的未命名属性的类型。每个属性都有一个关联的类型。使用元组时，必须提供每个属性的值。为了更直观地理解元组的概念，我们来看一个具体的例子： let tupleType: [string, boolean]; // 强制类型匹配tupleType = [&#x27;cosyer&#x27;, true]; Void某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，你通常会见到其返回值类型是 void： // 声明函数返回值为voidfunction warnUser(): void &#123; console.log(&#x27;This is my warning message&#x27;);&#125; 需要注意的是，声明一个 void 类型的变量没有什么作用，因为它的值只能为 undefined 或 null： let unusable: void = undefined; Null/UndefinedTypeScript 里，undefined 和 null 两者有各自的类型分别为 undefined 和 null。 let u: undefined = undefined;let n: null = null; 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。然而，如果你指定了–strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自的类型。 Nevernever 类型表示的是那些永不存在的值的类型。 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。 // 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;function infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; 在 TypeScript 中，可以利用 never 类型的特性来实现全面性检查，具体示例如下： type Foo = string | number;function controlFlowAnalysisWithNever(foo: Foo) &#123; if (typeof foo === &#x27;string&#x27;) &#123; // 这里 foo 被收窄为 string 类型 &#125; else if (typeof foo === &#x27;number&#x27;) &#123; // 这里 foo 被收窄为 number 类型 &#125; else &#123; // foo 在这里是 never const check: never = foo; &#125;&#125; 注意在 else 分支里面，我们把收窄为 never 的 foo 赋值给一个显示声明的 never 变量。如果一切逻辑正确，那么这里应该能够编译通过。但是假如后来有一天你的同事修改了 Foo 的类型：type Foo = string | number | boolean;复制代码然而他忘记同时修改 controlFlowAnalysisWithNever 方法中的控制流程，这时候 else 分支的 foo 类型会被收窄为 boolean 类型，导致无法赋值给 never 类型，这时就会产生一个编译错误。通过这个方式，我们可以确保controlFlowAnalysisWithNever 方法总是穷尽了 Foo 的所有可能类型。 通过这个示例，我们可以得出一个结论： 使用 never 避免出现新增了联合类型没有对应的实现，目的就是写出类型绝对安全的代码。 类型断言尖括号let someValue: any = &quot;this is a string&quot;;let strLength: number = ( &lt; string &gt; someValue).length; aslet someValue: any = &quot;this is a string&quot;;let strLength: number = (someValue as string).length; !非空断言操作符(感叹号) x! 将从 x 值域中排除 null 和 undefined. myFunc = (maybeString: string | undefined | null) =&gt; &#123; const onlyString: string = maybeString; // Error const ignoreUndefinedAndNull: string = maybeString!; // Ok&#125;myFunc2 = (onlyString: string) =&gt; &#123; const a: string = onlyString;&#125;constructor() &#123; this.myFunc(&#x27;jerry&#x27;); this.myFunc(undefined); this.myFunc2(undefined); this.myFunc2(null);&#125; 没有编译错误，也能正常运行： 类型守卫类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护： in 关键字interface Admin &#123; name: string; privileges: string[];&#125;interface Employee &#123; name: string; startDate: Date;&#125;type UnknownEmployee = Employee | Admin;function printEmployeeInformation(emp: UnknownEmployee) &#123; console.log(&#x27;Name: &#x27; + emp.name); if (&#x27;privileges&#x27; in emp) &#123; console.log(&#x27;Privileges: &#x27; + emp.privileges); &#125; if (&#x27;startDate&#x27; in emp) &#123; console.log(&#x27;Start Date: &#x27; + emp.startDate); &#125;&#125; typeof 关键字function padLeft(value: string, padding: string | number) &#123; if (typeof padding === &#x27;number&#x27;) &#123; return Array(padding + 1).join(&#x27; &#x27;) + value; &#125; if (typeof padding === &#x27;string&#x27;) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got &#x27;$&#123;padding&#125;&#x27;.`);&#125; typeof 类型保护只支持两种形式：typeof v === “typename” 和 typeof v !== typename，”typename” 必须是 “number”， “string”， “boolean” 或 “symbol”。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 instanceof 关键字interface Padder &#123; getPaddingString(): string;&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123;&#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(&quot; &quot;); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123;&#125; getPaddingString() &#123; return this.value; &#125;&#125;let padder: Padder = new SpaceRepeatingPadder(6);if (padder instanceof SpaceRepeatingPadder) &#123; // padder的类型收窄为 &#x27;SpaceRepeatingPadder&#x27;&#125; 自定义类型保护的类型谓词function isNumber(x: any): x is number &#123; return typeof x === &quot;number&quot;;&#125;function isString(x: any): x is string &#123; return typeof x === &quot;string&quot;;&#125; 联合类型和类型别名联合类型联合类型通常与 null 或 undefined 一起使用： const sayHello = (name: string | undefined) =&gt; &#123; /* ... */&#125;; 例如，这里 name 的类型是 string | undefined 意味着可以将 string 或 undefined 的值传递给 sayHello 函数。 sayHello(&#x27;cosyer&#x27;);sayHello(undefined); 可辨识联合TypeScript 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。它包含 3 个要点： 可辨识、联合类型和类型守卫。 这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。 如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。 可辨识可辨识要求联合类型中的每个元素都含有一个单例类型属性(公共属性)，比如： enum CarTransmission &#123; Automatic = 200, Manual = 300&#125;interface Motorcycle &#123; vType: &quot;motorcycle&quot;; // discriminant make: number; // year&#125;interface Car &#123; vType: &quot;car&quot;; // discriminant transmission: CarTransmission&#125;interface Truck &#123; vType: &quot;truck&quot;; // discriminant capacity: number; // in tons&#125; 在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口，在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。 联合类型基于前面定义了三个接口，我们可以创建一个 Vehicle 联合类型： type Vehicle = Motorcycle | Car | Truck; 现在我们就可以开始使用 Vehicle 联合类型，对于 Vehicle 类型的变量，它可以表示不同类型的车辆。 类型守卫下面我们来定义一个 evaluatePrice 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格，具体实现如下： const EVALUATION_FACTOR = Math.PI;function evaluatePrice(vehicle: Vehicle) &#123; return vehicle.capacity * EVALUATION_FACTOR;&#125;const myTruck: Truck = &#123; vType: &#x27;truck&#x27;, capacity: 9.5,&#125;;evaluatePrice(myTruck); 对于以上代码，TypeScript 编译器将会提示以下错误信息： Property &#x27;capacity&#x27;does not exist on type &#x27;Vehicle&#x27;.Property &#x27;capacity&#x27;does not exist on type &#x27;Motorcycle&#x27;. 原因是在 Motorcycle 接口中，并不存在 capacity 属性，而对于 Car 接口来说，它也不存在 capacity 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 evaluatePrice 方法，重构后的代码如下： function evaluatePrice(vehicle: Vehicle) &#123; switch (vehicle.vType) &#123; case &#x27;car&#x27;: return vehicle.transmission * EVALUATION_FACTOR; case &#x27;truck&#x27;: return vehicle.capacity * EVALUATION_FACTOR; case &#x27;motorcycle&#x27;: return vehicle.make * EVALUATION_FACTOR; &#125;&#125; 类型别名类型别名用来给一个类型起个新名字(alias)。 type Message = string | string[];let greet = (message: Message) =&gt; &#123; // ...&#125;; 交叉类型TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 interface IPerson &#123; id: string; age: number;&#125;interface IWorker &#123; companyId: string;&#125;type IStaff = IPerson &amp; IWorker;const staff: IStaff = &#123; id: &#x27;E1006&#x27;, age: 33, companyId: &#x27;EFT&#x27;,&#125;;console.dir(staff); 在上面示例中，我们首先为 IPerson 和 IWorker 类型定义了不同的成员，然后通过 &amp; 运算符定义了 IStaff 交叉类型，所以该类型同时拥有 IPerson 和 IWorker 这两种类型的成员。 声明文件TypeScript 作为 JavaScript 的超集，在开发过程中不可避免要引用其他第三方的 JavaScript 的库。虽然通过直接引用可以调用库的类和方法，但是却无法使用 TypeScript 诸如类型检查等特性功能。为了解决这个问题，需要将这些库里的函数和方法体去掉后只保留导出类型声明，而产生了一个描述 JavaScript 库和模块信息的声明文件。通过引用这个声明文件，就可以借用 TypeScript 的各种特性来使用库文件了。 假如我们想使用第三方库，比如 jQuery ，我们通常这样获取一个 id 是 foo 的元素： $(&#x27;#foo&#x27;);// 或jQuery(&#x27;#foo&#x27;); 但是在 TypeScript 中，我们并不知道 $ 或 jQuery 是什么东西： jQuery(&#x27;#foo&#x27;);// index.ts(1,1): error TS2304: Cannot find name &#x27;jQuery&#x27;. 这时，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型对不对： declare var jQuery: (selector: string) =&gt; any;jQuery(&#x27;#foo&#x27;); declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 上例的编译结果是： jQuery(&#x27;#foo&#x27;); 函数区别 TypeScript JavaScript 含有类型 无类型 箭头函数 箭头函数（ES2015） 函数类型 无函数类型 必填和可选参数 所有参数都是可选的 默认参数 默认参数 剩余参数 剩余参数 函数重载 无函数重载 箭头函数myBooks.forEach(() =&gt; console.log(&#x27;reading&#x27;));myBooks.forEach(title =&gt; console.log(title));myBooks.forEach((title, idx, arr) =&gt; console.log(idx + &#x27;-&#x27; + title););myBooks.forEach((title, idx, arr) =&gt; &#123; console.log(idx + &#x27;-&#x27; + title);&#125;); 参数类型和返回类型function createUserId(name: string, id: number): string &#123; return name + id;&#125; 函数类型let IdGenerator: (chars: string, nums: number) =&gt; string;function createUserId(name: string, id: number): string &#123; return name + id;&#125;IdGenerator = createUserId; 可选参数和默认参数// 可选参数function createUserId(name: string, id: number, age?: number): string &#123; return name + id;&#125;// 默认参数function createUserId(name: string = &#x27;cosyer&#x27;, id: number, age?: number): string &#123; return name + id;&#125; 在声明函数时，可以通过 ? 号来定义可选参数，比如 age?: number 这种形式。在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。 剩余参数function push(array, ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 函数重载函数重载或方法重载是使用相同名称和不同参数数量或类型创建多个方法的一种能力。要解决前面遇到的问题，方法就是为同一个函数提供多个函数类型定义来进行函数重载，编译器会根据这个列表去处理函数的调用。 function add(a: number, b: number): number;function add(a: string, b: string): string;function add(a: string, b: number): string;function add(a: number, b: string): string;function add(a: Combinable, b: Combinable) &#123; if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) &#123; return a.toString() + b.toString(); &#125; return a + b;&#125; 方法重载是指在同一个类中方法同名，参数不同（参数类型不同、参数个数不同或参数个数相同时参数的先后顺序不同），调用时根据实参的形式，选择与它匹配的方法执行操作的一种技术。所以类中成员方法满足重载的条件是：在同一个类中，方法名相同且参数列表不同。下面我们来举一个成员方法重载的例子： class Calculator &#123; add(a: number, b: number): number; add(a: string, b: string): string; add(a: string, b: number): string; add(a: number, b: string): string; add(a: Combinable, b: Combinable) &#123; if (typeof a === &quot;string&quot; || typeof b === &quot;string&quot;) &#123; return a.toString() + b.toString(); &#125; return a + b; &#125;&#125;const calculator = new Calculator();const result = calculator.add(&quot;cosyer&quot;, &quot; chenyu&quot;); 这里需要注意的是，当 TypeScript 编译器处理函数重载时，它会查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。另外在 Calculator 类中，add(a: Combinable, b: Combinable){ } 并不是重载列表的一部分，因此对于 add 成员方法来说，我们只定义了四个重载方法。 数组数组解构let x: number;let y: number;let z: number;let five_array = [0, 1, 2, 3, 4];[x, y, z] = five_array; // 0 1 2 扩展运算符let two_array = [0, 1];let five_array = [...two_array, 2, 3, 4]; 数组遍历let colors: string[] = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;];for (let i of colors) &#123; console.log(i);&#125; 对象对象解构let person = &#123; name: &#x27;cosyer&#x27;, gender: &#x27;Male&#x27;,&#125;;let &#123; name, gender &#125; = person; 对象展开扩展let person = &#123; name: &#x27;cosyer&#x27;, gender: &#x27;Male&#x27;, address: &#x27;Nanjing&#x27;,&#125;;// 组装对象let personWithAge = &#123; ...person, age: 33,&#125;;// 获取除了某些项外的其它项let &#123; name, ...rest &#125; = person; 接口在面向对象语言中，接口是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类去实现。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述 对象的形状(描述)interface Person &#123; name: string; age: number;&#125;let cosyer: Person = &#123; name: &#x27;cosyer&#x27;, age: 25,&#125;; 可选、只读属性interface Person &#123; readonly name: string; age ? : number;&#125; 只读属性用于限制只能在对象刚刚创建的时候修改其值。此外 TypeScript 还提供了 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改。 let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 泛型软件工程中，我们不仅要创建一致的定义良好的 API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像 C# 和 Java 这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 设计泛型的关键目的是在成员之间提供有意义的约束，这些成员可以是：类的实例成员、类的方法、函数参数和函数返回值。 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。 泛型接口interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125; 泛型类class GenericNumber &lt; T &gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber &lt; number &gt; ();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y;&#125;; 泛型变量对刚接触 TypeScript 泛型的小伙伴来说，看到 T 和 E，还有 K 和 V 这些泛型变量时，估计会一脸懵逼。其实这些大写字母并没有什么本质的区别，只不过是一个约定好的规范而已。也就是说使用大写字母 A-Z 定义的类型变量都属于泛型，把 T 换成 A，也是一样的。下面我们介绍一下一些常见泛型变量代表的意思： T（Type）：表示一个 TypeScript 类型 K（Key）：表示对象中的键类型 V（Value）：表示对象中的值类型 E（Element）：表示元素类型 泛型工具类型(6 种)为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Record 和 ReturnType 等。 typeoftypeof 操作符可以用来获取一个变量声明或对象的类型。 interface Person &#123; name: string; age: number;&#125;const cosyer: Person = &#123; name: &#x27;cosyer&#x27;, age: 25,&#125;;type Cosyer = typeof cosyer; // -&gt; Personfunction toArray(x: number): Array&lt;number&gt; &#123; return [x];&#125;type Func = typeof toArray; // -&gt; (x: number) =&gt; number[] keyofkeyof 操作符可以用来一个对象中的所有 key 值： interface Person &#123; name: string; age: number;&#125;type K1 = keyof Person; // &quot;name&quot; | &quot;age&quot;type K2 = keyof Person[]; // &quot;length&quot; | &quot;toString&quot; | &quot;pop&quot; | &quot;push&quot; | &quot;concat&quot; | &quot;join&quot;type K3 = keyof &#123; [x: string]: Person&#125;; // string | number inin 用来遍历枚举类型： type Keys = &quot;a&quot; | &quot;b&quot; | &quot;c&quot;type Obj = &#123; [p in Keys]: any&#125; // -&gt; &#123; a: any, b: any, c: any &#125; infer在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。 type ReturnType &lt; T &gt; = T extends( ...args: any[]) =&gt; infer R ? R : any; 以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。 extends有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。 interface ILengthwise &#123; length: number;&#125;function loggingIdentity &lt; T extends ILengthwise &gt; (arg: T): T &#123; console.log(arg.length); return arg;&#125; // error, number doesn&#x27;t have a .length propertyloggingIdentity(3);loggingIdentity(&#123; length: 10, value: 3,&#125;); PartialPartial 的作用就是将某个类型里的属性全部变为可选项 ?。 /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */type Partial &lt; T &gt; = &#123; [P in keyof T] ? : T[P];&#125;; interface Todo &#123; title: string; description: string;&#125;function updateTodo(todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;) &#123; return &#123; ...todo, ...fieldsToUpdate, &#125;;&#125;const todo1 = &#123; title: &#x27;organize desk&#x27;, description: &#x27;clear clutter&#x27;,&#125;;const todo2 = updateTodo(todo1, &#123; description: &#x27;throw out trash&#x27;,&#125;); 装饰器装饰器是什么 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 装饰器的分类 类装饰器（Class decorators） 属性装饰器（Property decorators） 方法装饰器（Method decorators） 参数装饰器（Parameter decorators） 类装饰器declare type ClassDecorator = &lt; TFunction extends Function &gt; ( target: TFunction) =&gt; TFunction | void; 类装饰器顾名思义，就是用来装饰类的。它接收一个参数： target: TFunction - 被装饰的类 function Greeter(target: Function): void &#123; target.prototype.greet = function (): void &#123; console.log(&#x27;Hello cosyer!&#x27;); &#125;;&#125;@Greeterclass Greeting &#123; constructor() &#123; // 内部实现 &#125;&#125;let myGreeting = new Greeting();myGreeting.greet(); // console output: &#x27;Hello cosyer!&#x27;; 自定义参数 function Greeter(greeting: string) &#123; return function (target: Function) &#123; target.prototype.greet = function (): void &#123; console.log(greeting); &#125;; &#125;;&#125;@Greeter(&#x27;Hello TS!&#x27;)class Greeting &#123; constructor() &#123; // 内部实现 &#125;&#125;let myGreeting = new Greeting();myGreeting.greet(); // console output: &#x27;Hello TS!&#x27;; 属性装饰器declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void; 属性装饰器顾名思义，用来装饰类的属性。它接收两个参数： target: Object - 被装饰的类 propertyKey: string | symbol - 被装饰类的属性名 function logProperty(target: any, key: string) &#123; delete target[key]; const backingField = &quot;_&quot; + key; Object.defineProperty(target, backingField, &#123; writable: true, enumerable: true, configurable: true &#125;); // property getter const getter = function(this: any) &#123; const currVal = this[backingField]; console.log(`Get: $&#123;key&#125; =&gt; $&#123;currVal&#125;`); return currVal; &#125;; // property setter const setter = function(this: any, newVal: any) &#123; console.log(`Set: $&#123;key&#125; =&gt; $&#123;newVal&#125;`); this[backingField] = newVal; &#125;; // Create new property with getter and setter Object.defineProperty(target, key, &#123; get: getter, set: setter, enumerable: true, configurable: true &#125;);&#125;class Person &#123; @logProperty public name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;const p1 = new Person(&quot;cosyer&quot;);p1.name = &quot;chenyu&quot;;// Set: name =&gt; cosyer// Set: name =&gt; chenyu 方法装饰器declare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypePropertyDescript&lt;T&gt;) =&gt; TypedPropertyDescriptor&lt;T&gt; | void; 方法装饰器顾名思义，用来装饰类的方法。它接收三个参数： target: Object - 被装饰的类 propertyKey: string | symbol - 方法名 descriptor: TypePropertyDescript - 属性描述符 function LogOutput(tarage: Function, key: string, descriptor: any) &#123; let originalMethod = descriptor.value; let newMethod = function(...args: any[]): any &#123; let result: any = originalMethod.apply(this, args); if (!this.loggedOutput) &#123; this.loggedOutput = new Array &lt; any &gt; (); &#125; this.loggedOutput.push(&#123; method: key, parameters: args, output: result, timestamp: new Date() &#125;); return result; &#125;; descriptor.value = newMethod;&#125;class Calculator &#123; @LogOutput double(num: number): number &#123; return num * 2; &#125;&#125;let calc = new Calculator();calc.double(11);// console ouput: [&#123;method: &quot;double&quot;, output: 22, ...&#125;]console.log(calc.loggedOutput); 参数装饰器declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) =&gt; void; 参数装饰器顾名思义，是用来装饰函数参数，它接收三个参数： target: Object - 被装饰的类 propertyKey: string | symbol - 方法名 parameterIndex: number - 方法中参数的索引值 function Log(target: Function, key: string, parameterIndex: number) &#123; let functionLogged = key || target.prototype.constructor.name; console.log(`The parameter in position $&#123;parameterIndex&#125; at $&#123;functionLogged&#125; has been decorated`);&#125;class Greeter &#123; greeting: string; constructor(@Log phrase: string) &#123; this.greeting = phrase; &#125;&#125;// console output: The parameter in position 0// at Greeter has been decorated 类类的属性和方法在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。 class Greeter &#123; // 静态属性 static cname: string = &#x27;Greeter&#x27;; // 成员属性 greeting: string; // 构造函数 - 执行初始化操作 constructor(message: string) &#123; this.greeting = message; &#125; // 静态方法 static getClassName() &#123; return &#x27;Class name is Greeter&#x27;; &#125; // 成员方法 greet() &#123; return &#x27;Hello, &#x27; + this.greeting; &#125;&#125;let greeter = new Greeter(&#x27;world&#x27;); 编译生成： &#x27;use strict&#x27;;var Greeter = /** @class */ (function () &#123; // 构造函数 - 执行初始化操作 function Greeter(message) &#123; this.greeting = message; &#125; // 静态方法 Greeter.getClassName = function () &#123; return &#x27;Class name is Greeter&#x27;; &#125;; // 成员方法 Greeter.prototype.greet = function () &#123; return &#x27;Hello, &#x27; + this.greeting; &#125;; // 静态属性 Greeter.cname = &#x27;Greeter&#x27;; return Greeter;&#125;)();var greeter = new Greeter(&#x27;world&#x27;); 访问器(getter/setter)在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。 let passcode = &quot;Hello TypeScript&quot;;class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == &quot;Hello TypeScript&quot;) &#123; this._fullName = newName; &#125; else &#123; console.log(&quot;Error: Unauthorized update of employee!&quot;); &#125; &#125;&#125;let employee = new Employee();employee.fullName = &quot;cosyer&quot;;if (employee.fullName) &#123; console.log(employee.fullName);&#125; 继承继承 (Inheritance) 是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加自己新功能的能力，继承是类与类或者接口与接口之间最常见的关系。 class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(&#x27;Slithering...&#x27;); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(&#x27;Sammy the Python&#x27;);sam.move(); 私有字段在 TypeScript 3.8 版本就开始支持 ECMAScript 私有字段 class Person &#123; #name: string; constructor(name: string) &#123; this.#name = name; &#125; greet() &#123; console.log(`Hello, my name is $&#123;this.#name&#125;!`); &#125;&#125;let cosyer = new Person(&#x27;cosyer&#x27;);cosyer.#name;// Property &#x27;#name&#x27; is not accessible outside class &#x27;Person&#x27;// because it has a private identifier. 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则： 私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 编译上下文tsconfig.json 的作用 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 tsconfig.json 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项。 compilerOptions 选项&#123; &quot;compilerOptions&quot;: &#123; /* 基本选项 */ &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 目标版本: &#x27;ES3&#x27; (default), &#x27;ES5&#x27;, &#x27;ES6&#x27;/&#x27;ES2015&#x27;, &#x27;ES2016&#x27;, &#x27;ES2017&#x27;, or &#x27;ESNEXT&#x27; &quot;module&quot;: &quot;commonjs&quot;, // 指定使用模块: &#x27;commonjs&#x27;, &#x27;amd&#x27;, &#x27;system&#x27;, &#x27;umd&#x27; or &#x27;es2015&#x27; &quot;lib&quot;: [], // 指定要包含在编译中的库文件 &quot;allowJs&quot;: true, // 允许编译 javascript 文件 &quot;checkJs&quot;: true, // 报告 javascript 文件中的错误 &quot;jsx&quot;: &quot;preserve&quot;, // 指定 jsx 代码的生成: &#x27;preserve&#x27;, &#x27;react-native&#x27;, or &#x27;react&#x27; &quot;declaration&quot;: true, // 生成相应的 &#x27;.d.ts&#x27; 文件 &quot;sourceMap&quot;: true, // 生成相应的 &#x27;.map&#x27; 文件 &quot;outFile&quot;: &quot;./&quot;, // 将输出文件合并为一个文件 &quot;outDir&quot;: &quot;./&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 用来控制输出目录结构 --outDir. &quot;removeComments&quot;: true, // 删除编译后的所有的注释 &quot;noEmit&quot;: true, // 不生成输出文件 &quot;importHelpers&quot;: true, // 从 tslib 导入辅助工具函数 &quot;isolatedModules&quot;: true, // 将每个文件做为单独的模块 （与 &#x27;ts.transpileModule&#x27; 类似）. /* 严格的类型检查选项 */ &quot;strict&quot;: true, // 启用所有严格类型检查选项 &quot;noImplicitAny&quot;: true, // 在表达式和声明上有隐含的 any类型时报错 &quot;strictNullChecks&quot;: true, // 启用严格的 null 检查 &quot;noImplicitThis&quot;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 &quot;alwaysStrict&quot;: true, // 以严格模式检查每个模块，并在每个文件里加入 &#x27;use strict&#x27; /* 额外的检查 */ &quot;noUnusedLocals&quot;: true, // 有未使用的变量时，抛出错误 &quot;noUnusedParameters&quot;: true, // 有未使用的参数时，抛出错误 &quot;noImplicitReturns&quot;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 &quot;noFallthroughCasesInSwitch&quot;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ &quot;moduleResolution&quot;: &quot;node&quot;, // 选择模块解析策略： &#x27;node&#x27; (Node.js) or &#x27;classic&#x27; (TypeScript pre-1.6) &quot;baseUrl&quot;: &quot;./&quot;, // 用于解析非相对模块名称的基目录 &quot;paths&quot;: &#123;&#125;, // 模块名到基于 baseUrl 的路径映射的列表 &quot;rootDirs&quot;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 &quot;typeRoots&quot;: [], // 包含类型声明的文件列表 &quot;types&quot;: [], // 需要包含的类型声明文件名列表 &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ &quot;sourceRoot&quot;: &quot;./&quot;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 &quot;mapRoot&quot;: &quot;./&quot;, // 指定调试器应该找到映射文件而不是生成文件的位置 &quot;inlineSourceMap&quot;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 &quot;inlineSources&quot;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ &quot;experimentalDecorators&quot;: true, // 启用装饰器 &quot;emitDecoratorMetadata&quot;: true // 为装饰器提供元数据的支持 &#125;&#125; 参考typescript","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"typescript","slug":"typescript","permalink":"https://luckyship.github.io/tags/typescript/"}]},{"title":"angular7基础","date":"2021-05-12T14:24:02.000Z","path":"2021/05/12/2021-05-12-angular7-base/","text":"开始准备 安装 nodejs npm -v 安装@angular/cli npm i -g @angular/cli CLI 命令建立项目 ng new ng7demo 选择是否加入路由模块以及哪种 css 预处理器 可 ctrl+c 取消自动安装 node_modules，手动进入项目 npm installnode-sass 安装不上可切换淘宝镜像库或者用 cnpm 安装 npm config set registry https://registry.npm.taobao.orgnpm install or npm install -g cnpmcnpm install 启动项目 ng serve --open // 自动打开浏览器 http://localhost:4200/ 语法生成组件// 标签app-article 如果不想要或者自定义前缀可在angular.json里修改prefix属性ng generate component article// 可添加目录ng generate service ./serveices/eventBus// 组件引用// 标签方式引用&lt;app-article&gt;&lt;/app-article&gt;// 属性方式引用&lt;div app-article&gt;&lt;/div&gt;// 类方式引用&lt;div class=&quot;app-article&quot;&gt;&lt;/div&gt; // @Component装饰器标识这是一个组件@Component(&#123; //selector: &#x27;app-article&#x27;, //selector: &#x27;[app-article]&#x27;, //属性方式 selector: &#x27;.app-article&#x27;, //类方式 templateUrl: &#x27;./article.component.html&#x27;, styleUrls: [&#x27;./article.component.css&#x27;]&#125;) 插值表达式将业务逻辑中的数据通过插值表达式显示在模板文件，即 html 页面上，或者将 html 页面上的事件传输到业务逻辑。 &lt;p&gt;标题是&#123;&#123;title&#125;&#125;&lt;/p&gt; 属性绑定&lt;img [src]=&quot;imgSrc&quot; /&gt;&lt;input value=&quot;value&quot; /&gt; 插值运算 加减乘除/字符串拼接/三元/方法调用&#123;&#123;5+3&#125;&#125;,&#123;&#123;5-3&#125;&#125;,&#123;&#123;5*3&#125;&#125;,&#123;&#123;5/3&#125;&#125;,&#123;&#123; &quot;a&quot; + &quot;b&quot;&#125;&#125;,&#123;&#123;true?1:0&#125;&#125; 事件绑定&lt;button (click)=&quot;showModal(&#x27;click&#x27;)&quot;&gt;&lt;/button&gt;&lt;!-- 传递事件参数 --&gt;&lt;input type=&quot;text&quot; (keyup)=&quot;updateContent($event)&quot; /&gt;&lt;!-- 双向绑定 视图和数据，只要一方发生变化，另一方跟着变化。 --&gt;&lt;!-- 不需要在代码中手动更新视图，简化开发，增加代码内聚性，代码可读性更强。 --&gt;&lt;input type=&quot;text&quot; [(ngModel)]=&quot;title&quot; /&gt;&lt;!-- 为了ngModel能够解析需要引入 import &#123;FormsModule&#125; from &quot;@angular/forms&quot;; --&gt; 模板指令判断指令&lt;img *ngIf=&quot;imgShow;else #p1&quot; /&gt;&lt;p #p1&gt;&lt;/p&gt; 样式指令&lt;p [ngClass]=&quot;&#123;bg:true&#125;&quot;&gt;这段内容应用的是类样式。&lt;/p&gt;&lt;p [ngStyle]=&quot;&#123;backgroundColor:pink&#125;&quot;&gt;本段内容样式是内联样式。&lt;/p&gt; 循环指令&lt;ul&gt; &lt;li *ngFor=&quot;let race of raceList; let i = index; let l = last&quot;&gt;&#123;&#123; race.name &#125;&#125;-&#123;&#123; i + 1 &#125;&#125;&lt;/li&gt;&lt;/ul&gt; 属性 说明 $implicit: T 声明在构造函数中 ngForOf: U 声明在构造函数中 index: number 声明在构造函数中 count: number 声明在构造函数中 first: boolean 只读 last: boolean 只读 even: boolean 只读 odd: boolean 只读 管道符&#123;&#123;currentTime | date: &quot;yyyy-MM-dd HH:mm:ss&quot; &#125;&#125; 在 ts 中的用法import &#123; DatePipe &#125; from &#x27;@angular/common&#x27;;constructor(private datePipe: DatePipe) &#123;&#125;this.datePipe.transform() 自定义管道ng generate pipe search 为了节省性能，angular 内部对管道进行了优化，参数 pure 为 true 时(纯管道)，当只有数据变化时，才会触发管道的执行，基于这样的机制，angular 管道无法检测到数组，对象这样复杂数据类型的值的变化，所以针对这样的数据 pure 应设为 false(非纯管道) @Pipe(&#123; name: &quot;flyingHeroesImpure&quot;, pure: false,&#125;)export class FlyingHeroesImpurePipe extends FlyingHeroesPipe &#123;&#125; 参考 内置管道 管道名 用途 date 日期管道，格式化日期 json(非纯管道) 将输入数据对象经过，JSON.stringify()方法转换后输出对象的字符串 uppercase 将文本所有小写字母转换成大写字母 lowercase 将文本所有大写字母转换成小写字母 number 将数值按特定的格式显示文本 percent 将数值转百分比格式 currentcy 将数值进行货币格式化处理 slice(非纯管道) 将数组或者字符串裁剪成新子集 i18n 翻译管道 组件注册 declarations: 声明该模块中拥有哪些组件、指令和管道。这些组件等都是该模块中的局部组件。 imports: 声明该模块所依赖的其他模块。在该模块中使用了其他模块导出的组件、指令和服务时，必须先将这些模块引入进来。 exports: 声明该模块中可被外部访问的组件、指令和管道。这些组件等都是该模块中的全局组件。 providers: 声明该模块中提供的服务。这些服务可以被该模块以及该模块所依赖的其他模块使用。 bootstrap: 声明该模块的根组件。通常情况下，只有应用的根模块才会设置该属性。 import &#123; BrowserModule &#125; from &quot;@angular/platform-browser&quot;;import &#123; NgModule &#125; from &quot;@angular/core&quot;;import &#123; AppRoutingModule &#125; from &quot;./app-routing.module&quot;;import &#123; AppComponent &#125; from &quot;./app.component&quot;;@NgModule(&#123; declarations: [AppComponent], imports: [BrowserModule, AppRoutingModule], providers: [], bootstrap: [AppComponent],&#125;)export class AppModule &#123;&#125; 防抖方法实现withRefresh = false;packages$!: Observable&lt;NpmPackageInfo[]&gt;;private searchText$ = new Subject&lt;string&gt;();search(packageName: string) &#123; this.searchText$.next(packageName);&#125;ngOnInit() &#123; this.packages$ = this.searchText$.pipe( debounceTime(500), distinctUntilChanged(), switchMap(packageName =&gt; this.searchService.search(packageName, this.withRefresh)) );&#125;constructor(private searchService: PackageSearchService) &#123; &#125; searchText$ 是来自用户的搜索框值的序列。它被定义为 RxJS Subject 类型，这意味着它是一个多播 Observable，它还可以通过调用 next(value) 来自行发出值，就像在 search() 方法中一样。 除了把每个 searchText 的值都直接转发给 PackageSearchService 之外，ngOnInit() 中的代码还通过下列三个操作符对这些搜索值进行管道处理，以便只有当它是一个新值并且用户已经停止输入时，要搜索的值才会抵达该服务。 debounceTime(500)⁠—等待用户停止输入（本例中为 1/2 秒）。 distinctUntilChanged()⁠—等待搜索文本发生变化。 switchMap()⁠—将搜索请求发送到服务。 父子组件通信Input、Output 传值// 输入&lt;child title = &quot;我的子组件&quot;&gt; &lt;/child&gt;@Inputpublic title: string = &quot;&quot;;// 输出&lt;child title=&quot;我的子组件&quot; (follow)=&quot;getFollow($event)&quot; #child &gt;&lt;/child&gt;@Output()public follow = new EventEmitter();this.follow.emit(&quot;子组件传来的数据&quot;); 服务总线 注册服务 ng g s ./services/eventBus import &#123; Injectable&#125; from &quot;@angular/core&quot;;import &#123; Observable, Subject&#125; from &quot;rxjs&quot;;// 服务总线 组件间分享数据@Injectable(&#123; providedIn: &quot;root&quot; // 在所有组件共享数据&#125;)export class EventBusService &#123; public eventBus: Subject &lt; string &gt; = new Subject(); constructor() &#123;&#125;&#125; service 也可以指定在某个某块生效，比如下方 service 就只在UserModule中生效 import &#123; Injectable &#125; from &quot;@angular/core&quot;;import &#123; UserModule &#125; from &quot;./user.module&quot;;@Injectable(&#123; providedIn: UserModule,&#125;)export class UserService &#123;&#125; 组件内发射数据 this.eventBusService.eventBus.next(&quot;child组件发送的数据&quot;); 组件接收数据 this.eventBusService.eventBus.subscribe((arg) =&gt; &#123; console.log(`接收到事件$&#123;arg&#125;`);&#125;); 标签变量引用&lt;child title=&quot;我的子组件&quot; #child (follow)=&quot;getFollow($event)&quot;&gt;&lt;/child&gt;&lt;button (click)=&quot;child.sayHello()&quot;&gt;子组件说话&lt;/button&gt; 路由导航import &#123; NgModule &#125; from &quot;@angular/core&quot;;import &#123; Routes, RouterModule &#125; from &quot;@angular/router&quot;;import &#123; ChildComponent &#125; from &quot;./child/child.component&quot;;import &#123; BrotherComponent &#125; from &quot;./brother/brother.component&quot;;const routes: Routes = [ &#123; path: &quot;&quot;, component: ChildComponent, &#125;, &#123; path: &quot;brother&quot;, component: BrotherComponent, &#125;,];@NgModule(&#123; imports: [RouterModule.forRoot(routes)], exports: [RouterModule],&#125;)export class AppRoutingModule &#123;&#125; &lt;!-- RouterOutlet 相当于一个占位符, 在Angular中根据路由状态动态插入视图 --&gt;&lt;a [routerLink]=&quot;[&#x27;/&#x27;]&quot;&gt; child &lt;/a&gt;&lt;br /&gt;&lt;a [routerLink]=&quot;[&#x27;/brother&#x27;]&quot;&gt; brother &lt;/a&gt;&lt;router-outlet&gt;&lt;/router-outlet&gt; 路由懒加载使用loadChildren可以配置路由懒加载 const routes: Routes = [ &#123; path: &quot;items&quot;, loadChildren: () =&gt; import(&quot;./items/items.module&quot;).then((m) =&gt; m.ItemsModule), &#125;,]; http 服务// app.module.tsimport &#123; HttpModule &#125; from &quot;@angular/http&quot;;import &#123; HttpClientModule &#125; from &quot;@angular/common/http&quot;;// servicesimport &#123; Headers &#125; from &quot;@angular/http&quot;;import &#123; HttpClient, HttpResponse &#125; from &quot;@angular/common/http&quot;;this.httpClient.request(UserService.METHOD_POST, url, options).subscribe( (next) =&gt; &#123;&#125;, (error) =&gt; &#123;&#125;, (complete) =&gt; &#123;&#125; // 指next完成后，会执行complete, 并不是finally的意思); 如果想使用async语法，可以把angular观察对象转成promise this.httpClient.request(UserService.METHOD_POST, url, options).toPromise(); 集中处理 http 的 errorclass MyErrorHandler implements ErrorHandler &#123; handleError(error) &#123; // do something with the exception &#125;&#125;@NgModule(&#123; providers: [&#123; provide: ErrorHandler, useClass: MyErrorHandler &#125;],&#125;)class MyModule &#123;&#125; 参考 angular 通过 ip 访问绑定到0.0.0.0上 # ng serve --host 0.0.0.0 --port 4200 angular.json// angular.json&quot;budgets&quot;: [&#123; &quot;type&quot;: &quot;initial&quot;, &quot;maximumWarning&quot;: &quot;2mb&quot;, &quot;maximumError&quot;: &quot;5mb&quot;&#125;]// 这个配置适用于打包文件限制 ng build --prod// 打包生成生产环境时如果包大于2MB,那么CLI工具会提示waning,如果大于5MB,中断打包。&#123; &quot;project&quot;: &#123; &quot;name&quot;: &quot;ng-admin&quot;, //项目名称 &quot;ejected&quot;: false // 标记该应用是否已经执行过eject命令把webpack配置释放出来 &#125;, &quot;apps&quot;: [ &#123; &quot;root&quot;: &quot;src&quot;, // 源码根目录 &quot;outDir&quot;: &quot;dist&quot;, // 编译后的输出目录，默认是dist/ &quot;assets&quot;: [ // 记录资源文件夹，构建时复制到`outDir`指定的目录 &quot;assets&quot;, &quot;favicon.ico&quot; ], &quot;index&quot;: &quot;index.html&quot;, // 指定首页文件，默认值是&quot;index.html&quot; &quot;main&quot;: &quot;main.ts&quot;, // 指定应用的入门文件 &quot;polyfills&quot;: &quot;polyfills.ts&quot;, // 指定polyfill文件 &quot;test&quot;: &quot;test.ts&quot;, // 指定测试入门文件 &quot;tsconfig&quot;: &quot;tsconfig.app.json&quot;, // 指定tsconfig文件 &quot;testTsconfig&quot;: &quot;tsconfig.spec.json&quot;, // 指定TypeScript单测脚本的tsconfig文件 &quot;tsconfig&quot;: &quot;tsconfig.app.json&quot;, &quot;prefix&quot;: &quot;app&quot;, // 使用`ng generate`命令时，自动为selector元数据的值添加的前缀名 &quot;deployUrl&quot;: &quot;//cdn.com.cn&quot;, // 指定站点的部署地址，该值最终会赋给webpack的output.publicPath，常用于CDN部署 &quot;styles&quot;: [ // 引入全局样式，构建时会打包进来，常用于第三方库引入的样式 &quot;styles.css&quot; ], &quot;scripts&quot;: [ // 引入全局脚本，构建时会打包进来，常用语第三方库引入的脚本 ], &quot;environmentSource&quot;: &quot;environments/environment.ts&quot;, // 基础环境配置 &quot;environments&quot;: &#123; // 子环境配置文件 &quot;dev&quot;: &quot;environments/environment.ts&quot;, &quot;prod&quot;: &quot;environments/environment.prod.ts&quot; &#125; &#125; ], &quot;e2e&quot;: &#123; &quot;protractor&quot;: &#123; &quot;config&quot;: &quot;./protractor.conf.js&quot; &#125; &#125;, &quot;lint&quot;: [ &#123; &quot;project&quot;: &quot;src/tsconfig.app.json&quot; &#125;, &#123; &quot;project&quot;: &quot;src/tsconfig.spec.json&quot; &#125;, &#123; &quot;project&quot;: &quot;e2e/tsconfig.e2e.json&quot; &#125; ], &quot;test&quot;: &#123; &quot;karma&quot;: &#123; &quot;config&quot;: &quot;./karma.conf.js&quot; &#125; &#125;, &quot;defaults&quot;: &#123; // 执行`ng generate`命令时的一些默认值 &quot;styleExt&quot;: &quot;scss&quot;, // 默认生成的样式文件后缀名 &quot;component&quot;: &#123; &quot;flat&quot;: false, // 生成组件时是否新建文件夹包装组件文件，默认为false（即新建文件夹） &quot;spec&quot;: true, // 是否生成spec文件，默认为true &quot;inlineStyle&quot;: false, // 新建时是否使用内联样式，默认为false &quot;inlineTemplate&quot;: false, // 新建时是否使用内联模板，默认为false &quot;viewEncapsulation&quot;: &quot;Emulated&quot;, // 指定生成的组件的元数据viewEncapsulation的默认值 &quot;changeDetection&quot;: &quot;OnPush&quot; // 指定生成的组件的元数据changeDetection的默认值 &#125; &#125;&#125; 官网参考","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"浏览器页面渲染过程","date":"2021-05-12T14:13:17.000Z","path":"2021/05/12/2021-05-12-browser-render/","text":"浏览器的渲染方式 构建 DOM 树浏览器请求到 html 代码后，在生成 DOM 的最开始阶段，并行发起 css、图片、js 的请求。（解码-&gt;令牌化-&gt;词法分析-&gt;dom 树创建） 构建 CSSOMcss 文件加载完成，开始构建 CSSOM（CSSOM 只输出包含有样式的节点） 生成渲染树（Render Tree）CSSOM 构建结束后，和 DOM 一起生成 Render Tree 计算渲染树布局（Layout）有了 Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的 CSS 定义以及他们的从属关系。依照盒子模型，计算出每个节点在屏幕中的位置及尺寸。 将布局 Paint 绘制到屏幕上布局之后，浏览器知道哪些节点要显示，每个节点的 CSS 属性是什么，每个节点在屏幕中的位置。所以接下来按照算出来的规则，通过显卡，把内容画在屏幕上。 页面渲染优化避免 CSS 阻塞渲染：由于 CSSOM 负责存储渲染信息，浏览器就必须保证在合成渲染树之前，CSSOM 是完备的，这种完备是指所有的 CSS（内联、内部和外部）都已经下载完，并解析完，只有 CSSOM 和 DOM 的解析完全结束，浏览器才会进入下一步的渲染。CSS 阻塞渲染意味着，在 CSSOM 完备前，页面将一直处理白屏状态，这就是为什么样式放在 head 中，仅仅是为了更快的解析 CSS，保证更快的首次渲染。 避免 JS 阻塞页面：JS 可以操作 DOM 来修改 DOM 结构，可以操作 CSSOM 来修改节点样式，这就导致了浏览器在解析 HTML 时，一旦碰到 script，就会立即停止 HTML 的解析，也阻塞了其后的 CSS 解析，整个解析进程必须等待 JS 的执行完成才能够继续。从性能角度上讲，将 script 放在页面底部，也就合情合理了。 减少重绘（ Repaint ）：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制了一遍，于是页面的内容出现了，这个过程称之为 repaint。 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此 损耗较少。 触发重绘 DOM 改动 CSS 改动 减少重排（ Reflow ）：DOM 结构中的各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称之为 reflow。 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。 触发重排 当增加、删除、修改DOM节点时，会导致reflow或repaint 当移动DOM的位置，或是插入动画的时候 当修改 CSS 样式的时候 当 Resize 窗口的时候，或是滚动的时候 当修改网页的默认字体时 重排和重绘的区别他们的区别很大：回流必将引起重绘，而重绘不一定会引起回流。比如：只有颜色改变的时候就只会发生重绘而不会引起回流当页面布局和几何属性改变时就需要回流比如：添加或者删除可见的 DOM 元素，元素位置改变，元素尺寸改变——边距、填充、边框、宽度和高度，内容改变 最小化重绘和重排 避免频繁使用style，而是采用修改class的方式。 批量修改DOM：使用文档片段创建一个子树，然后再拷贝到文档中（document.fragment）使用 createDocumentFragment 进行批量的 DOM 操作。 缓存布局信息 对于 resize、scroll 等进行防抖/节流处理。 创建动画或者移动元素位置时尽量使用transform: translate 使用字体图标 iconfont 代替图片图标：图片会增加网络请求次数，从而拖慢页面加载时间iconfont 可以很好的缩放并且不会添加额外的请求 降低 css 选择器的复杂度：浏览器读取选择器，遵循的原则是从选择器的右边到左边读取。 减少嵌套：最多不要超过三层，并且后代选择器的开销较高，慎重使用 避免使用通配符，对用到的元素进行匹配即可 利用继承，避免重复匹配和定义 正确使用类选择器和 id 选择器","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"only-child和only-of-type区别","date":"2021-05-06T06:45:11.000Z","path":"2021/05/06/2021-05-06-css-diff-only-of-type-and-only-child/","text":"only-child选择器:only-child 选择器选择的是父元素中只有一个子元素，而且只有唯一的一个子元素。也就是说，匹配的元素的父元素中仅有一个子元素，而且是一个唯一的子元素。 only-of-type选择器:only-of-type 选择器用来选择一个元素是它的父元素的唯一一个相同类型的子元素。这样说或许不太好理解，换一种说法。 :only-of-type 是表示一个元素他有很多个子元素，而其中只有一种类型的子元素是唯一的，使用 :only-of-type 选择器就可以选中这个元素中的唯一一个类型子元素。 示例&lt;style&gt; p:only-of-type &#123; background: #ff0000; &#125; p:only-child &#123; border: 5px solid blue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;span&gt;123&lt;/span&gt; &lt;span&gt;123&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"css格式化上下文（BFC、IFC）","date":"2021-05-06T03:49:52.000Z","path":"2021/05/06/2021-05-06-css-block-format-context/","text":"BFCFormatting context (格式化上下文) 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。 那么 BFC 是什么呢？ BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述定位方案的普通流。 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素 ，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 创建新的块格式上下文只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 这很有用，因为新的 BFC 的行为与最外层的文档非常相似，它在主布局中创造了一个小布局。BFC 包含其内部的所有内容，float 和 clear 仅适用于同一格式上下文中的项目，而页边距仅在同一格式上下文中的元素之间折叠。 边距上的运用从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 50px，而不是 100px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 &lt;style type=&quot;text/css&quot;&gt; .container &#123; overflow: hidden; &#125; p &#123; width: 100px; height: 100px; background: lightblue; margin: 50px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; BFC 可以包含浮动的元素（清除浮动）我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 &lt;div style=&quot;border: 1px solid #000;&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div style=&quot;border: 1px solid #000;overflow: hidden&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; BFC 可以阻止元素被浮动元素覆盖先来看一个文字环绕效果： &lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt; 我是一个左浮动的元素&lt;/div&gt;&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt; 我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 IFC(行内格式化上下文)Inline Formatting Contexts，也就是“内联格式化上下文”。 符合以下条件即会生成一个 IFC 块级元素中仅包含内联级别元素 形成条件非常简单，需要注意的是当 IFC 中有块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC，这里不做过多介绍。 IFC 布局规则 子元素水平方向横向排列，并且垂直方向起点为元素顶部。 子元素只会计算横向样式空间，padding、border、margin，垂直方向样式空间不会被计算，padding、border、margin。 在垂直方向上，子元素会以不同形式来对齐（vertical-align） 能把在一行上的框都完全包含进去的一个矩形区域，被称为该行的行框（line box）。行框的宽度是由包含块（containing box）和与其中的浮动来决定。 IFC 中的“line box”一般左右边贴紧其包含块，但 float 元素会优先排列。 IFC 中的“line box”高度由 CSS 行高计算规则来确定，同个 IFC 下的多个 line box 高度可能会不同。 当 inline-level boxes 的总宽度少于包含它们的 line box 时，其水平渲染规则由 text-align 属性值来决定。 当一个“inline box”超过父元素的宽度时，它会被分割成多个 boxes，这些 oxes 分布在多个“line box”中。如果子元素未设置强制换行的情况下，“inline box”将不可被分割，将会溢出父元素。 上下间距不生效内联格式上下文存在于其他格式上下文中，可以将其视为段落的上下文。段落创建了一个内联格式上下文，其中在文本中使用诸如 &lt;strong&gt; 、 &lt;a&gt; 或 &lt;span&gt; 元素等内容。 box model 不完全适用于参与内联格式上下文。在水平书写模式行中，水平填充、边框和边距将应用于元素，并左右移动文本。但是，元素上方和下方边距将不适用。应用垂直填充和边框可能会在内容的上方和下方重叠，因为在内联格式上下文中，填充和边框不会将行框撑开。 多个元素水平居中.warp &#123; border: 1px solid red; width: 200px; text-align: center;&#125;.text &#123; background: green;&#125; &lt;div class=&quot;warp&quot;&gt; &lt;span class=&quot;text&quot;&gt;文本一&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;文本二&lt;/span&gt;&lt;/div&gt; float 元素优先排列.warp &#123; border: 1px solid red; width: 200px;&#125;.text &#123; background: green;&#125;.f-l &#123; float: left;&#125; &lt;div class=&quot;warp&quot;&gt; &lt;span class=&quot;text&quot;&gt;这是文本1&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;这是文本2&lt;/span&gt; &lt;span class=&quot;text f-l&quot;&gt;这是文本3&lt;/span&gt; &lt;span class=&quot;text&quot;&gt;这是文本4&lt;/span&gt;&lt;/div&gt; IFC 中具备 float 属性值的元素优先排列，在很多场景中用来在文章段落开头添加“tag”可以用到。 图片无法和文字垂直居中在图片上设置vertical: middle &lt;div class=&quot;warp&quot;&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; /&gt; &lt;span&gt;luckyship&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;warp&quot;&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;vertical-align: middle;&quot; /&gt; &lt;span&gt;luckyship&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;warp&quot;&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;vertical-align: middle;&quot; /&gt; &lt;span&gt;luckyship&lt;/span&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; /&gt;&lt;/div&gt;&lt;div class=&quot;warp&quot;&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;vertical-align: middle;&quot; /&gt; &lt;span&gt;luckyship&lt;/span&gt; &lt;img src=&quot;/img/head.jpg&quot; width=&quot;200&quot; height=&quot;200&quot; style=&quot;vertical-align: middle;&quot; /&gt;&lt;/div&gt; 这种设置垂直居中的方法，根本上是改变了行内元素的基线对齐方式 参考行内格式化上下文（Inline formatting context） 10 分钟理解 BFC 原理 CSS 之 IFC","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"css常用知识","date":"2021-05-06T02:35:44.000Z","path":"2021/05/06/2021-05-06-css-interview/","text":"什么是盒子模型盒模型分为标准盒模型和怪异盒模型（IE） box-sizing : content-box //标准盒模型box-sizing : border-box //怪异盒模型 标准盒模型: 这种盒模型设置width的时候的值是内容区的宽度, 如果再设置padding和margin, border的话盒子的实际宽度会增大； 怪异盒模型: 这种盒子的width设置的值为盒子实际的宽度, border和padding的设置不会影响盒子的实际宽度和高度 CSS 新特性transition //过渡transform //旋转、缩放、移动或者倾斜animation //动画gradient //渐变shadow //阴影border-radius //圆角 显示省略号样式overflow: hidden;text-overflow: ellipsis; link 和 @import 的区别 link 属于 HTML 标签，而@import 是 CSS 提供的。 页面加载的时候，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载。 import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题。 link 样式的权重高于@import 样式的权重。 介绍一下标准的 CSS 的盒子模型？与低版本 IE 的盒子模型有什么不同的？标准盒子模型：宽度=内容的宽度 （content）+ border + padding + margin 低版本 IE 盒子模型：宽度=内容宽度 （content+border+padding）+ margin box-sizing 属性？用来控制元素的盒子模型的解析模式，默认为 content-boxcontext-box：W3C 的标准盒子模型，设置元素的 height/width 属性指的是 content 部分的高/宽border-box：IE 传统盒子模型。设置元素的 height/width 属性指的是 border + padding + content 部分的高/宽 CSS 选择器有哪些？哪些属性可以继承？CSS 选择符：id 选择器(#myid)、类选择器(.myclassname)、标签选择器(div, h1, p)、相邻选择器(h1 + p)、子选择器（ul &gt; li）、后代选择器（li a）、通配符选择器（*）、属性选择器（a[rel=”external”]）、伪类选择器（a:hover, li:nth-child） 可继承的属性： font-size, font-family, color 不可继承的样式： border, padding, margin, width, height 优先级（就近原则）：!important &gt; [ id &gt; class &gt; tag ] !important 比内联优先级高 CSS 优先级算法如何计算？ 元素选择符： 1 class 选择符： 10 id 选择符：100 行内样式：1000 !important 声明的样式优先级最高，如果冲突再进行计算。如果优先级相同，则选择最后出现的样式。继承得到的样式的优先级最低。 数字只是为了同一级别的优先级比较，不会出现低级别数量多的情况覆盖高级别因为每个级别都有上限，超过一定数量后，优先级不会增加 CSS3 新增伪类有那些? p:first-of-type 选择属于其父元素的首个元素 p:last-of-type 选择属于其父元素的最后元素 p:only-of-type 选择属于其父元素唯一的元素 p:only-child 选择属于其父元素的唯一子元素 p:nth-child(2) 选择属于其父元素的第二个子元素 :enabled :disabled 表单控件的禁用状态。 :checked 单选框或复选框被选中。 display 有哪些值？说明他们的作用? inline（默认）–内联 none–隐藏 block–块显示 table–表格显示 list-item–项目列表 inline-block position 的值 static（默认）：按照正常文档流进行排列； relative（相对定位）：不脱离文档流，参考自身静态位置通过 top, bottom, left, right 定* 位； absolute(绝对定位)：参考距其最近一个不为 static 的父级元素通过 top, bottom, left, right * 定位； fixed(固定定位)：所固定的参照对像是可视窗口。 CSS3 有哪些新特性 RGBA 和透明度 background-image background-origin(content-box/padding-box/border-box) * background-size background-repeat word-wrap（对长的不可分割单词换行）word-wrap：break-word 文字阴影：text-shadow： 5px 5px 5px #FF0000; （水平阴影，垂直阴影，模糊距离，阴影颜色） font-face 属性：定义自己的字体 圆角（边框半径）：border-radius 属性用于创建圆角 边框图片：border-image: url(border.png) 30 30 round 盒阴影：box-shadow: 10px 10px 5px #888888 媒体查询：定义两套 css，当浏览器的尺寸变化时会采用不同的属性 用纯 CSS 创建一个三角形的原理是什么首先，需要把元素的宽度、高度设为 0。然后设置边框样式。 CSS 里的 visibility 属性有个 collapse 属性值？在不同浏览器下以后什么区别？当一个元素的 visibility 属性被设置成 collapse 值后，对于一般的元素，它的表现跟 hidden 是一样的。 chrome 中，使用 collapse 值和使用 hidden 没有区别。firefox，opera 和 IE，使用 collapse 值和使用 display：none 没有什么区别。 display:none 与 visibility：hidden 的区别？display：none 不显示对应的元素，在文档布局中不再分配空间（回流+重绘）visibility：hidden 隐藏对应元素，在文档布局中仍保留原来的空间（重绘） position 跟 display、overflow、float 这些特性相互叠加后会怎么样display 属性规定元素应该生成的框的类型； position 属性规定元素的定位类型； float 属性是一种布局方式，定义元素在哪个方向浮动。类似于优先级机制： position：absolute/fixed 优先级最高，有他们在时， float 不起作用， display 值需要调整。 float 或者 absolute 定位的元素，只能是块元素或表格。 对 BFC 规范(块级格式化上下文：block formatting context)的理解？BFC 规定了内部的 Block Box 如何布局。定位方案： 内部的 Box 会在垂直方向上一个接一个放置。 Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠。 每个元素的 margin box 的左边，与包含块 border box 的左边相接触。 BFC 的区域不会与 float box 重叠。 BFC 是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。 计算 BFC 的高度时，浮动元素也会参与计算。满足下列条件之一就可触发 BFC 根元素，即 html float 的值不为 none（默认） overflow 的值不为 visible（默认） display 的值为 inline-block、table-cell、table-caption position 的值为 absolute 或 fixed 浏览器是怎样解析 CSS 选择器的？CSS 选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面。而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。 参考元素竖向的百分比设定是相对于容器的高度吗？当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的，但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的也是父容器的宽度，而不是高度。 参考全屏滚动的原理是什么？用到了 CSS 的哪些属性？原理：有点类似于轮播，整体的元素一直排列下去，假设有 5 个需要展示的全屏页面，那么高度是 500%，只是展示 100%，剩下的可以通过 transform 进行 y 轴定位，也可以通过 margin-top 实现overflow：hidden；transition：all 1000ms ease； 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的 IE？响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有 meta 声明的 viewport。 ::before 和 :after 中双冒号和单冒号有什么区别？解释一下这 2 个伪元素的作用单冒号(:)用于 CSS3 伪类，双冒号(::)用于 CSS3 伪元素。:: before 就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于 dom 之中，只存在在页面之中。 你对 line-height 是如何理解的？行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS 中起高度作用的是 height 和 line-height ，没有定义 height 属性，最终其表现作用一定是 line-height 。单行文本垂直居中：把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中，其实也可以把 height 删除。多行文本垂直居中：需要设置 display 属性为 inline-block 。 怎么让 Chrome 支持小于 12px 的文字font-size: 12px;transform: 0.8; // 缩小比例 如果需要手动写动画，你认为最小时间间隔是多久，为什么？多数显示器默认频率是 60Hz，即 1 秒刷新 60 次，所以理论上最小间隔为 1/60＊1000ms ＝ 16.7ms li 与 li 之间有看不见的空白间隔是什么原因引起的？有什么解决办法？行框的排列会受到中间空白（回车空格）等的影响，因为空格也属于字符, 这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为 0，就没有空格了。解决方法： 可以将&lt;li&gt;代码全部写在一排 浮动 li 中 float：left 在 ul 中用 font-size：0（谷歌不支持）；可以使用 letter-space：-3px display:inline-block 什么时候会显示间隙？ 有空格时候会有间隙 解决：移除空格 margin 正值的时候 解决：margin 使用负值 使用 font-size 时候 解决：font-size:0、letter-spacing、word-spacing 有一个高度自适应的 div，里面有两个 div，一个高度 100px，希望另一个填满剩下的高度?外层 div 使用 position：relative；高度要求自适应的 div 使用 position: absolute; top: 100px; bottom: 0; left: 0 style 标签写在 body 后与 body 前有什么区别？页面加载自上而下 当然是先加载样式。写在 body 标签后由于浏览器以逐行方式对 HTML 文档进行解析，当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"angular生命周期函数","date":"2021-04-20T03:04:16.000Z","path":"2021/04/20/2021-04-20-angular-lifecycle/","text":"加载所有生命周期函数export class LifecircleComponent &#123; constructor() &#123; console.log(&#x27;00构造函数执行了---除了使用简单的值对局部变量进行初始化之外，什么都不应该做&#x27;) &#125; ngOnChanges() &#123; console.log(&#x27;01ngOnChages执行了---当被绑定的输入属性的值发生变化时调用(父子组件传值的时候会触发)&#x27;); &#125; ngOnInit() &#123; console.log(&#x27;02ngOnInit执行了--- 请求数据一般放在这个里面&#x27;); &#125; ngDoCheck() &#123; console.log(&#x27;03ngDoCheck执行了---检测，并在发生 Angular 无法或不愿意自己检测的变化时作出反应&#x27;); &#125; ngAfterContentInit() &#123; console.log(&#x27;04ngAfterContentInit执行了---当把内容投影进组件之后调用&#x27;); &#125; ngAfterContentChecked() &#123; console.log(&#x27;05ngAfterContentChecked执行了---每次完成被投影组件内容的变更检测之后调用&#x27;); &#125; ngAfterViewInit(): void &#123; console.log(&#x27;06 ngAfterViewInit执行了----初始化完组件视图及其子视图之后调用（dom操作放在这个里面）&#x27;); &#125; ngAfterViewChecked() &#123; console.log(&#x27;07ngAfterViewChecked执行了----每次做完组件视图和子视图的变更检测之后调用&#x27;); &#125; ngOnDestroy() &#123; console.log(&#x27;08ngOnDestroy执行了····&#x27;); &#125; //自定义方法 changeMsg() &#123; this.msg = &quot;数据改变了&quot;; &#125;&#125; 生命周期钩子详解constructorconstructor ，来初始化类。 Angular 中的组件就是基于 class 类实现的，在 Angular 中， constructor 用于注入依赖。组件的构造函数会在所有的生命周期钩子之前被调用，它主要用于依赖注入或执行简单的数据初始化操作。 ngOnChanges()@input 属性(输入属性)发生变化时，会调用。非此属性，不会调用。 当输入属性为对象时，当对象的属性值发生变化时，不会调用，当对象的引用变化时会触发 。首次调用一 定会发生在 ngOnInit()之前。 ngOnInit()在 Angular 第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。在第一轮 ngOnChanges () 完成之后调用，只调用一次。可以请求数据 使用 ngOnInit() 有两个原因: 在构造函数之后马上执行复杂的初始化逻辑在 Angular 设置完输入属性之后，对该组件进行准备。有经验的开发者会认同组件的构建应该很便宜和安全 ngDoCheck()检测，并在发生 Angular 无法或不愿意自己检测的变 化时作出反应。在每个 Angular 变更检测周期中调用， ngOnChanges() 和 ngOnInit()之后。 ngAfterContentInit()当把内容投影进组件之后调用。第一次 ngDoCheck() 之后调用，只调用一次 ngAfterContentChecked()每次完成被投影组件内容的变更检测之后调用。 ngAfterContentInit() 和每次 ngDoCheck() 之后调 ngAfterViewInit()–掌握初始化完组件视图及其子视图之后调用。第一 次 ngAfterContentChecked() 之后调用，只调用一次。在这里可以操作DOM ngAfterViewChecked()每次做完组件视图和子视图的变更检测之后调用。 ngAfterViewInit()和每次 ngAfterContentChecked() 之后 调用。 ngOnDestroy()–掌握当 Angular 每次销毁指令/组件之前调用并清扫。在这儿反订阅可观察对象和分离事件处理器，以防内存泄 漏。在 Angular 销毁指令/组件之前调用。比如：移除事件监听、清除定时器、退订 Observable 等。","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angualr","slug":"angualr","permalink":"https://luckyship.github.io/tags/angualr/"}]},{"title":"less和sass的区别","date":"2021-04-06T14:20:21.000Z","path":"2021/04/06/2021-04-06-difference-sass-and-less/","text":"LESS 和 SCSS 都属于 CSS 预处理器的范畴，也就是 CSS 的超集，但是两者的语法、如何使用和具体的功能实现还是有差异的。 声明和使用变量 LESS 采用 @ 符号，SCSS 采用 $ 符号。 在下面的示例中，我们首先在规则外声明了一个名为 link-color 的变量，然后在名为 #main 的规则内声明一个名为 width 的变量，接着把 width 变量赋值给了 CSS 的 width 属性。 LESS: @link-color: #428bca;#main &#123; @width: 5em; width: @width;&#125; SCSS: $link-color: #428bca;#main &#123; $width: 5em; width: $width;&#125; 变量插值（Variable Interpolation） LESS 采用 @&#123;xxxx&#125; 的形式，SCSS 采用 #&#123;xxxx&#125; 的形式。 LESS： // Variables @my-selector: banner;// Usage .@&#123;my-selector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; SCSS: // Variables $my-selector: banner;// Usage .#&#123;$my-selector&#125; &#123; font-weight: bold; line-height: 40px; margin: 0 auto;&#125; Mixins 的定义、使用及参数定义方法定义一个 Mixin：LESS 使用 dot 符号（也就是句点）来定义一个 Mixin，并且可以把任意的 CSS 规则作为 Mixin 使用；SCSS 使用 @mixin 指令来定义一个 Mixin。 示例 - 来自 BootStrap 的 alert-variant Mixin 的定义LESS： .alert-variant(@background; @border; @text-color) &#123; background-color: @background; border-color: @border; color: @text-color; hr &#123; border-top-color: darken(@border, 5%); &#125; .alert-link &#123; color: darken(@text-color, 10%); &#125;&#125; SCSS: @mixin alert-variant($background, $border, $text-color) &#123; background-color: $background; border-color: $border; color: $text-color; hr &#123; border-top-color: darken($border, 5%); &#125; .alert-link &#123; color: darken($text-color, 10%); &#125;&#125; 使用使用 Mixin：LESS 仍是使用 dot 符号（句点），如果 Mixin 没有参数的话可以省略后面的圆括号；SCSS 使用 @include 指令来引入一个 Mixin。 示例 - 引入一个名为 center-block 的 Mixin。LESS： .center-block() &#123; display: block; margin-left: auto; margin-right: auto;&#125;.a &#123; .center-block;&#125; SCSS: @mixin center-block() &#123; display: block; margin-left: auto; margin-right: auto;&#125;.a &#123; @include center-block;&#125; 参数形式如果存在多个参数的话，LESS 使用分号分隔；SCSS 使用逗号分隔。两者都支持为参数设置默认值。 示例 - 来在 BootStrap 的 form-control-validation Mixin 的使用 LESS： @state-success-text: #3c763d;@state-success-bg: #dff0d8;@state-success-border: darken(spin(@state-success-bg, -10), 5%);@state-info-text: #31708f;@state-info-bg: #d9edf7;@state-info-border: darken(spin(@state-info-bg, -10), 7%);@state-warning-text: #8a6d3b;@state-warning-bg: #fcf8e3;@state-warning-border: darken(spin(@state-warning-bg, -10), 5%);@state-danger-text: #a94442;@state-danger-bg: #f2dede;@state-danger-border: darken(spin(@state-danger-bg, -10), 5%);.box-shadow(@shadow) &#123; -webkit-box-shadow: @shadow; // iOS &lt;4.3 &amp; Android &lt;4.1 box-shadow: @shadow;&#125;.form-control-validation(@text-color: #555; @border-color: #ccc; @background-color: #f5f5f5) &#123; // Color the label and help text .help-block, .control-label, .radio, .checkbox, .radio-inline, .checkbox-inline, &amp;.radio label, &amp;.checkbox label, &amp;.radio-inline label, &amp;.checkbox-inline label &#123; color: @text-color; &#125; // Set the border and box shadow on specific inputs to match .form-control &#123; border-color: @border-color; .box-shadow(inset 0 1px 1px rgba(0, 0, 0, .075)); // Redeclare so transitions work &amp;:focus &#123; border-color: darken(@border-color, 10%); @shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px lighten(@border-color, 20%); .box-shadow(@shadow); &#125; &#125; // Set validation states also for addons .input-group-addon &#123; color: @text-color; border-color: @border-color; background-color: @background-color; &#125; // Optional feedback icon .form-control-feedback &#123; color: @text-color; &#125;&#125;// Feedback states .has-success &#123; .form-control-validation(@state-success-text; @state-success-text; @state-success-bg);&#125;.has-warning &#123; .form-control-validation(@state-warning-text; @state-warning-text; @state-warning-bg);&#125;.has-error &#123; .form-control-validation(@state-danger-text; @state-danger-text; @state-danger-bg);&#125; SCSS: $state-success-text: #3c763d;$state-success-bg: #dff0d8;$state-success-border: darken(adjust_hue($state-success-bg, -10), 5%);$state-info-text: #31708f;$state-info-bg: #d9edf7;$state-info-border: darken(adjust_hue($state-info-bg, -10), 7%);$state-warning-text: #8a6d3b;$state-warning-bg: #fcf8e3;$state-warning-border: darken(adjust_hue($state-warning-bg, -10), 5%);$state-danger-text: #a94442;$state-danger-bg: #f2dede;$state-danger-border: darken(adjust_hue($state-danger-bg, -10), 5%);@mixin box-shadow($shadow) &#123; -webkit-box-shadow: $shadow; // iOS &lt;4.3 &amp; Android &lt;4.1 box-shadow: $shadow;&#125;@mixin form-control-validation($text-color: #555, $border-color: #ccc, $background-color: #f5f5f5) &#123; // Color the label and help text .help-block, .control-label, .radio, .checkbox, .radio-inline, .checkbox-inline, &amp;.radio label, &amp;.checkbox label, &amp;.radio-inline label, &amp;.checkbox-inline label &#123; color: $text-color; &#125; // Set the border and box shadow on specific inputs to match .form-control &#123; border-color: $border-color; @include box-shadow(inset 0 1px 1px rgba(0, 0, 0, .075)); // Redeclare so transitions work &amp;:focus &#123; border-color: darken($border-color, 10%); $shadow: inset 0 1px 1px rgba(0, 0, 0, .075), 0 0 6px lighten($border-color, 20%); @include box-shadow($shadow); &#125; &#125; // Set validation states also for addons .input-group-addon &#123; color: $text-color; border-color: $border-color; background-color: $background-color; &#125; // Optional feedback icon .form-control-feedback &#123; color: $text-color; &#125;&#125;// Feedback states .has-success &#123; @include form-control-validation($state-success-text, $state-success-text, $state-success-bg);&#125;.has-warning &#123; @include form-control-validation($state-warning-text, $state-warning-text, $state-warning-bg);&#125;.has-error &#123; @include form-control-validation($state-danger-text, $state-danger-text, $state-danger-bg);&#125; 函数的使用字符串函数LESS 使用 e 或者 ~&quot;xxxx&quot; 这种语法进行 CSS 转义；SCSS 本身并没有提供 CSS 转义的函数，要达到相同的效果可以使用变量插值（Variable Interpolation）实现。 LESS: @input-border-focus: #66afe9;.box-shadow(@shadow) &#123; -webkit-box-shadow: @shadow; // iOS &lt;4.3 &amp; Android &lt;4.1 box-shadow: @shadow;&#125;.form-control-focus(@color: @input-border-focus) &#123; @color-rgba: rgba(red(@color), green(@color), blue(@color), .6); &amp;:focus &#123; border-color: @color; outline: 0; .box-shadow(~&quot;inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px @&#123;color-rgba&#125;&quot;); //或者 @str: &quot;inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px @&#123;color-rgba&#125;&quot; .box-shadow(e(@str)); &#125;&#125;.form-control &#123; .form-control-focus();&#125; SCSS: $input-border-focus: #66afe9;@mixin box-shadow($shadow) &#123; -webkit-box-shadow: $shadow; // iOS &lt;4.3 &amp; Android &lt;4.1 box-shadow: $shadow;&#125;@mixin form-control-focus($color: $input-border-focus) &#123; $color-rgba: rgba(red($color), green($color), blue($color), .6); &amp;:focus &#123; border-color: $color; outline: 0; @include box-shadow(#&#123;inset 0 1px 1px rgba(0,0,0,.075), 0 0 8px $color-rgba&#125;); &#125;&#125;.form-control &#123; @include form-control-focus();&#125; 颜色函数调节色相，LESS 使用名为 spin() 的函数；SCSS 使用名为 adjust_hue() 的函数。 LESS: @state-success-border: darken(spin(@state-success-bg, -10), 5%); SCSS: $state-success-border: darken(adjust_hue($state-success-bg, -10), 5%); 数学函数LESS 提供了一些 SCSS 中并不具备的数学函数，在 SCSS 中只能通过自定义函数实现，然后通过 node-sass 的接口传递给编译器。 SCSS： // rotate for ie8 and blow@mixin ie-rotate($rotation) &#123; -ms-filter: &quot;progid:DXImageTransform.Microsoft.BasicImage(rotation=@&#123;rotation&#125;)&quot;;&#125;// rotate for ie8 and blow// degrees unit@mixin ie-rotate-via-degrees($degrees) &#123; /* IE6-IE8 */ $radians: parseInt(&quot;#&#123;$degrees&#125;&quot;) * PI() * 2 / 360; $costheta: cos(&quot;#&#123;$radians&#125;&quot;); $sintheta: sin(&quot;#&#123;$radians&#125;&quot;); $negsintheta: &quot;#&#123;$sintheta&#125;&quot;* -1; -ms-filter: &quot;progid:DXImageTransform.Microsoft.Matrix(sizingMethod=&#x27;auto expand&#x27;, M11=@&#123;costheta&#125;, M12=@&#123;negsintheta&#125;, M21=@&#123;sintheta&#125;, M22=@&#123;costheta&#125;)&quot;; zoom: 1; :root &amp; &#123; filter: none; &#125;&#125;// support rotate for all browsers@mixin cross-rotate($degrees) &#123; @include rotate($degrees); @include ie-rotate-via-degrees($degrees);&#125;// Placeholder text@mixin placeholder($color: $input-placeholder-color) &#123; // Firefox &amp;::-moz-placeholder &#123; color: $color; opacity: 1; // Override Firefox&#x27;s unusual default opacity; see https://github.com/twbs/bootstrap/pull/11526 &#125; // Internet Explorer 10+ &amp;:-ms-input-placeholder &#123; color: $color; &#125; // Safari and Chrome &amp;::-webkit-input-placeholder &#123; color: $color; &#125;&#125; 上述 Math 实现所需的 JS 文件： module.exports = &#123; &#x27;parseInt($str)&#x27;: function(str) &#123; return parseInt(str, 10); &#125;, &#x27;Math.sin($degree)&#x27;: function(degree) &#123; return Math.sin(degree); &#125;, &#x27;Math.cos($degree)&#x27;: function(degree) &#123; return Math.cos(degree); &#125;, &#x27;Math.PI&#x27;: Math.PI&#125; 有关函数的区别还有：LESS 的 fade() 函数在 SCSS 中只能使用 rgba() 之类的实现，因为 SCSS 也没有这个函数。 @import 的实现 像 @media , @import 这些带 @ 符号的在 CSS 中都称为 At-rules。 值的一提的是 LESS 和 SCSS 对 @import 实现的区别。 LESS 如果扩展名为 .css，将文件识别为 CSS 文件 其他任何扩展名都将被作为 LESS 文件处理 没有扩展名会被附加一个 .less 的扩展名并且作为 LESS 文件处理 SCSS 默认情况下，SCSS 的 @import 实现会试图寻找一个 Sass 文件进行导入。 但是在下列情况出现时，@import 会直接被编译为 CSS 的 @import at-rule 文件扩展名是 .css 文件以 http:// 开头 文件名是一个 url() @import 具有媒体查询 SCSS 按约定认为下划线开始的文件是内联文件，不会被编译为单独的 CSS 文件输出。 示例 LESS: @import &quot;foo&quot;;@import &quot;bar.less&quot;;@import &quot;foo.php&quot;; // 当成 LESS 文件处理@import &quot;foo.css&quot;; SCSS: @import &quot;foo&quot;;@import &quot;foo.scss&quot;; 都会导入 foo.scss 文件。 其他区别 LESS 和 SCSS 均使用 &amp; 符号表示父选择器引用，但是 SCSS 的 &amp; 符号只能出现在一个组合选择器的开始位置，LESS 则没有这个限制。 示例 LESS： .bg-variant(@color) &#123; background-color: @color; a&amp;:hover, a&amp;:focus &#123; background-color: darken(@color, 10%); &#125;&#125; SCSS: a &#123; font-weight: bold; text-decoration: none; &amp;:hover &#123; text-decoration: underline; &#125; body.firefox &amp; &#123; font-weight: normal; &#125;&#125; SCSS 不支持 LESS 中的 CSS Guard 功能，比如 if, when ... ，在 SCSS 中需要换种方式实现。 LESS 示例： .my-optional-style() when (@my-option =true) &#123; button &#123; color: white; &#125;&#125;.my-optional-style(); Note：SCSS 需要换一种写法实现同样的功能。 SCSS 支持 !default，一般是用在基础 Rule 的声明中，告诉使用者这是可以被覆盖的。 SCSS 示例： $primary: $blue !default;$secondary: $gray-600 !default; SCSS支持 if, else, for, each 等方法, LESS不支持 SCSS: $type: monster;p &#123; @if $type==ocean &#123; color: blue; &#125; @else if $type==matador &#123; color: red; &#125; @else if $type==monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125;@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125;@each $animal in puma,sea-slug,egret,salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url(&#x27;/images/#&#123;$animal&#125;.png&#x27;); &#125;&#125; SCSS 不像 LESS 一样默认可以把 rule 作为 Mixin 使用，但是 SCSS 有类似的 @extend 指令；而 LESS 的 extend 语法看起来则像是伪类一样。 示例： LESS: .error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; SCSS: .error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 集成 JavaScript 功能的方式：LESS 使用 @functions 指令，可以把 js 代码直接放到 ~ xxx 中间即可；SCSS 可以把 JS 代码放到一个单独的文件中，然后使用 node-sass编译的时候指定参数传给 node-sass。 LESS 示例：ant-design/ant-design SCSS 示例：命令 node-sass --output-style expanded --source-map true --precision 6 --functions components/style/custom.js components/button/style/index.scss components/button/style/index.css LESS 支持 lazy evaluation，但是 SCSS 不支持，所以在 LESS 中可以先使用再定义，但是在 SCSS 中一定要先定义再使用。 SCSS 是不支持 Mixin 重载的, 也就是说 LESS 可以有同名但是参数个数不同的几个 Mixins, SCSS 同样名字的 Mixin 只能有一个. 参考less和sass或者scss 有什么区别吗？ LESS官网SASS官网","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://luckyship.github.io/tags/sass/"},{"name":"less","slug":"less","permalink":"https://luckyship.github.io/tags/less/"}]},{"title":"css中的换行","date":"2021-04-06T06:58:25.000Z","path":"2021/04/06/2021-04-06-css-wrap-line/","text":"强制不换行: p &#123; white-space:nowrap; &#125; 自动换行: p &#123; word-wrap:break-word; &#125; 强制英文单词断行: p &#123; word-break:break-all; &#125; 注意：设置强制将英文单词断行，需要将行内元素设置为块级元素。 超出显示省略号: p&#123;text-overflow:ellipsis;overflow:hidden;&#125; white-space: normal|pre|nowrap|pre-wrap|pre-line|inherit;white-space: 属性设置如何处理元素内的空白 normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 pre-wrap: 保留空白符序列，但是正常地进行换行。 pre-line: 合并空白符序列，但是保留换行符。 inherit: 规定应该从父元素继承 white-space 属性的值。 word-wrap: normal|break-word; word-wrap: 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。 normal: 只在允许的断字点换行(浏览器保持默认处理) break-word: 在长单词或 URL 地址内部进行换行 word-break: normal|break-all|keep-all; word-break 属性用来标明怎么样进行单词内的断句。 normal：使用浏览器默认的换行规则。 break-all: 允许再单词内换行 keep-all: 只能在半角空格或连字符处换行 实例&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;style&gt; .word &#123; background: #e4ffe9; width: 250px; margin: 50px auto; padding: 20px; font-family: &quot;microsoft yahei&quot;; &#125; /* 强制不换行 */ .nowrap &#123; white-space: nowrap; &#125; /* 允许单词内断句，首先会尝试挪到下一行，看看下一行的宽度够不够， 不够的话就进行单词内的断句 */ .breakword &#123; word-wrap: break-word; &#125; /* 断句时，不会把长单词挪到下一行，而是直接进行单词内的断句 */ .breakAll &#123; word-break: break-all; &#125; /* 超出部分显示省略号 */ .ellipsis &#123; text-overflow: ellipsis; overflow: hidden; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;word&quot;&gt; &lt;p class=&quot;normal&quot;&gt; wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihuivfsa &lt;/p&gt; &lt;p class=&quot;nowrap&quot;&gt; wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihuivfs &lt;/p&gt; &lt;p class=&quot;breakword&quot;&gt; wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihui &lt;/p&gt; &lt;p class=&quot;breakAll&quot;&gt; wordwrap:break-word;absavhsafhuafdfbjhfvsalguvfaihuivf &lt;/p&gt; &lt;p class=&quot;ellipsis&quot;&gt; wordwrap:breakword;absavhsafhuafdfbjhfvsalguvfaihuivfsab &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"escape, encodeURI, encodeURIComponent有什么区别","date":"2021-04-06T06:27:26.000Z","path":"2021/04/06/2021-04-06-difference-escape-encodeURI-encodeURIComponent/","text":"escape , encodeURI , encodeURIComponent 都是 javascript 的编码方法 escape简单来说，escape是对字符串(string)进行编码(而另外两种是对URL)，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其中 ASCII字母 、 数字 、 @*/+ 这几个字符不会被编码，其余的都会。最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。 encodeURI和encodeURIComponent区别对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。它们都是编码URL，唯一区别就是编码的字符范围，其中 encodeURI 方法不会对下列字符编码 ASCII字母 数字 ~!@#$&amp;*()=:/, ; ?+&#39; encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()&#39; 所以 encodeURIComponent 比 encodeURI 编码的范围更大。实际例子来说， encodeURIComponent 会把 http:// 编码成 http%3A%2F%2F 而 encodeURI 却不会。 使用场景1、如果只是编码字符串，不和URL有半毛钱关系，那么用 escape 。 2、如果你需要编码整个URL，然后需要使用这个URL，那么用 encodeURI 。 3、当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。 var param = &quot;http://www.cnblogs.com/season-huang/&quot;; //param为参数param = encodeURIComponent(param);var url = &quot;http://www.cnblogs.com?next=&quot; + param;console.log(url) //&quot;http://www.cnblogs.com?next=http%3A%2F%2Fwww.cnblogs.com%2Fseason-huang%2F&quot; 参考escape, encodeURI, encodeURIComponent有什么区别","updated":"2025-08-02T05:46:04.175Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"使用css实现4个角边框","date":"2021-03-20T09:45:39.000Z","path":"2021/03/20/2021-03-20-four-angle-border-by-css/","text":"目前发现2种实现方式，使用 css3 background 或者使用伪元素 css3 background实现.rect &#123; position: absolute; top: 20px; left: 20px; width: 100px; height: 100px; background: linear-gradient(to left, #f00, #f00) left top no-repeat, linear-gradient(to bottom, #f00, #f00) left top no-repeat, linear-gradient(to left, #f00, #f00) right top no-repeat, linear-gradient(to bottom, #f00, #f00) right top no-repeat, linear-gradient(to left, #f00, #f00) left bottom no-repeat, linear-gradient(to bottom, #f00, #f00) left bottom no-repeat, linear-gradient(to left, #f00, #f00) right bottom no-repeat, linear-gradient(to left, #f00, #f00) right bottom no-repeat; background-size: 1px 20px, 20px 1px, 1px 20px, 20px 1px;&#125; &lt;div class=&quot;rect&quot;&gt;&lt;/div&gt; 伪元素实现#border &#123; width: 100px; height: 50px; position: relative;&#125;#border:after &#123; position: absolute; top: 0; left: 0; content: &#x27;&#x27;; display: block; height: 25%; width: 25%; border-left: 1px solid black; border-top: 1px solid black;&#125;#border:before &#123; position: absolute; top: 0; right: 0; content: &#x27;&#x27;; display: block; height: 25%; width: 25%; border-right: 1px solid black; border-top: 1px solid black;&#125;#border2 &#123; width: 100px; height: 50px; position: relative;&#125;#border2:after &#123; position: absolute; bottom: 0; left: 0; content: &#x27;&#x27;; display: block; height: 25%; width: 25%; border-left: 1px solid black; border-bottom: 1px solid black;&#125;#border2:before &#123; position: absolute; bottom: 0; right: 0; content: &#x27;&#x27;; display: block; height: 25%; width: 25%; border-right: 1px solid black; border-bottom: 1px solid black;&#125; &lt;div id=&#x27;border&#x27;&gt;&lt;/div&gt;&lt;div id=&#x27;border2&#x27;&gt;&lt;/div&gt; 参考div只有四个角有边框怎么实现？","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"跨域（服务端解决）","date":"2021-03-20T09:31:30.000Z","path":"2021/03/20/2021-03-20-cross-domain-server/","text":"在开发web项目的时候，经常会遇见跨域问题，虽然是个前端，但是了解一些后端解决跨域的方法，有助于我们更快解决问题 nodejs express框架跨域解决app.all(&quot;*&quot;, function(req, res, next) &#123; //设置允许跨域的域名，*代表允许任意域名跨域 res.header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); //允许的header类型 res.header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept, Authorization&quot;); //跨域允许的请求方式 res.header(&quot;Access-Control-Allow-Methods&quot;, &quot;DELETE,PUT,POST,GET,OPTIONS&quot;); next();&#125;); nginx转发跨域nginx设置 location ~ ^/aaaa &#123; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;; add_header Access-Control-Allow-Headers &#x27;Origin, X-Requested-With, Content-Type, Accept, Authorization&#x27;; proxy_pass http://xx.xx.xx.xx:7071;&#125;","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://luckyship.github.io/tags/nodejs/"}]},{"title":"node-sass安装失败问题汇总","date":"2021-03-20T09:17:45.000Z","path":"2021/03/20/2021-03-20-node-sass-failure/","text":"node-scss 是我们常见的依赖包，但是安装的时候， node-scss 总是报错，特地汇总一下，以避免踩坑 npm 源速度慢由于众所周知的国内网络环境，从国内安装官方源的依赖包会很慢。可以将 npm 源设置成国内镜像源(如淘宝 npm)： npm config set registry https://registry.npm.taobao.org 或者通过 .npmrc 文件设置: // .npmrcregistry=https://registry.npm.taobao.org/ binding.node 源无法访问或速度慢node-sass 除了 npm 部分的代码，还会下载二进制文件 binding.node ，默认源是 github，国内访问较慢, 特殊时期甚至无法访问。我们也可以将其改成国内源： // linux、mac 下SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass// window 下set SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ &amp;&amp; npm install node-sass 有类似问题的还有 chromedriver, phantomjs, electron 等常见依赖包, 我们可以一并写到.npmrc 中: // .npmrcsass_binary_site=https://npm.taobao.org/mirrors/node-sasschromedriver_cdnurl=https://npm.taobao.org/mirrors/chromedriverphantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjselectron_mirror=https://npm.taobao.org/mirrors/electron 可以参考npm 安装 node 版本与 node-sass 版本不兼容node-sass 版本兼容性并不好，老项目中依赖的 node-sass 很可能已经不兼容新的 node，对应版本兼容如下(或参考官方仓库)： NodeJS Minimum node-sass version Node Module Node 8 4.5.3+ 57 Node 13 4.13+ 79 Node 12 4.12+ 72 Node 11 4.10+ 67 Node 10 4.9+ 64 缓存中 binding.node 版本不一致假如本地 node 版本改了，或在不同机器上运行，node 版本不一致，会报类似错误： Found bindings for the following environments: - Windows 64-bit with Node.js 6.x 这是因为原有 binding.node 缓存跟现 node 版本不一致。按提示 npm rebuild node-sass 或清除缓存重新安装即可。 安装失败后重新安装安装失败后重新安装，有可能无权限删除已安装内容，此时 npm uninstall node-sass 或手动删掉原目录后再安装即可。 提示没有安装 python、build 失败等假如拉取 binding.node 失败，node-sass 会尝试在本地编译 binding.node ，过程就需要 python 。假如你遇到前面几种情况解决了，实际上也不会出现在本地构建的情况了，我们就不谈这种失败中失败的情况吧 :-)","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyship.github.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://luckyship.github.io/tags/npm/"},{"name":"sass","slug":"sass","permalink":"https://luckyship.github.io/tags/sass/"}]},{"title":"angular css样式作用域","date":"2021-03-20T08:56:01.000Z","path":"2021/03/20/2021-03-20-angular-css-scope/","text":"在使用 angular 时，我们发现每个组件的 css 作用域都是独立的，且无法修改引用组件的样式，这是因为： 在封装组件的时候，组件会分配一个唯一的属性，并将这个属性添加到组件内的每一个标签上，封装后的样式表的选择器中会加上属性选择器，从而形成了一个样式表的作用域，域内样式不会影响外部这与 Vue 中的 scoped 属性原理一样，我们引入 ViewEncapsulation 类就可以解决这个问题 ViewEncapsulationenum ViewEncapsulation &#123; Emulated Native None&#125; ViewEncapsulation 的值是用来指定，在封装 Angular 组件的时候，如何处理样式和标签之间的关系，默认值是： ViewEncapsulation. Emulated ;用法是： import &#123; ViewEncapsulation&#125; from &quot;@angular/core&quot;;@Component(&#123; templateUrl: &quot;./login.html&quot;, styleUrls: [&#x27;./login.css&#x27;, &#x27;/bootstrap/css/bootstrap.min.css&#x27;], encapsulation: ViewEncapsulation.Emulated&#125;) ViewEncapsulation.Emulated（默认值）这种方式在封装组件的时候，会给组件分配一个唯一的属性，并将这个属性添加到组件内的每一个标签上，封装后的样式表的选择器中会加上属性选择器，从而形成了一个样式表的作用域，域内样式不会影响外部，但是组件会受到父级样式的影响 即：只进不出，全局样式能进来，组件样式出不去 ViewEncapsulation.ShadowDom这种方式把组件封装成一个 shadow DOM； 即： 不进不出，没有样式能进来，组件样式出不去。 什么是 shadow DOM ViewEncapsulation.None这种方法的样式表为全局的作用域，组件中声明的样式既可以影响到本组件，同时也会影响全局样式表；反过来，该组件收全局样式表的影响。 两种情况：1、外部样式表作用的标签是静态的（如 bootstrap ）: 直接在组件元数据中引入，使用默认方式： @Component(&#123; templateUrl: &quot;./login.html&quot;, styleUrls: [&#x27;./login.css&#x27;, &#x27;/bootstrap/css/bootstrap.min.css&#x27;]&#125;) 2、样式表作用于动态创建的标签（如创建一个富文本编辑器 CKEditor ， wangEditor 等）： 因为标签是动态创建的，也就是说打包组件的时候，引入的外部样式表作用的标签尚未存在（代码运行的时候，new 一个 Editor 之后才会创建标签），而打包的时候却给所有选择器都添加了一个属性选择器，因此，动态创建的标签就不会被引入的样式表影响。也就是说新创建的标签不属于组件这个作用域。为了避免这种情况，只能在打包组件的时候，不给这个组件创建作用于： import &#123; ViewEncapsulation&#125; from &quot;@angular/core&quot;;@Component(&#123; templateUrl: &quot;./login.html&quot;, styleUrls: [&#x27;./login.css&#x27;, &#x27;/bootstrap/css/bootstrap.min.css&#x27;], encapsulation: ViewEncapsulation.None&#125;) ::ng-deep::ng-deep 会跳过中间的步骤，直接找到对应的选择器，使用这个不会受 angular 作用域的影响 ::ng-deep .class &#123; color: white;&#125; 参考在 Angular 组件中引入外部样式","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"angular","slug":"angular","permalink":"https://luckyship.github.io/tags/angular/"}]},{"title":"jsonp的原理和实现","date":"2021-03-07T09:07:42.000Z","path":"2021/03/07/2021-03-07-jsonp/","text":"在应对浏览器跨域问题时，我们经常会遇到一种解决方法，使用 jsonp 。那么 jsonp 到底是什么呢？ 概述jsonp是一种跨域通信的手段，它的原理其实很简单： 首先是利用script标签的src属性来实现跨域。 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。 由于使用script标签的src属性，因此只支持get方法 实现流程设定一个script标签 &lt; script src = &quot;http://jsonp.js?callback=xxx&quot; &gt; &lt; /script&gt; callback 定义了一个函数名，而远程服务端通过调用指定的函数并传入参数来实现传递参数，将 fn(response) 传递回客户端 $callback = !empty($_GET[&#x27;callback&#x27;]) ? $_GET[&#x27;callback&#x27;] : &#x27;callback&#x27;;echo $callback.&#x27;(.json_encode($data).)&#x27;; 客户端接收到返回的js脚本，开始解析和执行 fn(response) jsonp简单实现一个简单的jsonp实现，其实就是拼接url，然后将动态添加一个script元素到头部。 function jsonp(req) &#123; var script = document.createElement(&#x27;script&#x27;); var url = req.url + &#x27;?callback=&#x27; + req.callback.name; script.src = url; document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(script);&#125; 前端js示例 function hello(res) &#123; alert(&#x27;hello &#x27; + res.data);&#125;jsonp(&#123; url: &#x27;&#x27;, callback: hello&#125;); 服务器端代码 var http = require(&#x27;http&#x27;);var urllib = require(&#x27;url&#x27;);var port = 8080;var data = &#123; &#x27;data&#x27;: &#x27;world&#x27;&#125;;http.createServer(function(req, res) &#123; var params = urllib.parse(req.url, true); if (params.query.callback) &#123; console.log(params.query.callback); //jsonp var str = params.query.callback + &#x27;(&#x27; + JSON.stringify(data) + &#x27;)&#x27;; res.end(str); &#125; else &#123; res.end(); &#125;&#125;).listen(port, function() &#123; console.log(&#x27;jsonp server is on&#x27;);&#125;); 然而，这个实现虽然简单，但有一些不足的地方： 我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。 需要加入一些参数校验，确保接口可以正常执行。 可靠的jsonp实现(function(global) &#123; var id = 0, container = document.getElementsByTagName(&quot;head&quot;)[0]; function jsonp(options) &#123; if (!options || !options.url) return; var scriptNode = document.createElement(&quot;script&quot;), data = options.data || &#123;&#125;, url = options.url, callback = options.callback, fnName = &quot;jsonp&quot; + id++; // 添加回调函数 data[&quot;callback&quot;] = fnName; // 拼接url var params = []; for (var key in data) &#123; params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(data[key])); &#125; url = url.indexOf(&quot;?&quot;) &gt; 0 ? (url + &quot;&amp;&quot;) : (url + &quot;?&quot;); url += params.join(&quot;&amp;&quot;); scriptNode.src = url; // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法 global[fnName] = function(ret) &#123; callback &amp;&amp; callback(ret); container.removeChild(scriptNode); delete global[fnName]; &#125; // 出错处理 scriptNode.onerror = function() &#123; callback &amp;&amp; callback(&#123; error: &quot;error&quot; &#125;); container.removeChild(scriptNode); global[fnName] &amp;&amp; delete global[fnName]; &#125; scriptNode.type = &quot;text/javascript&quot;; container.appendChild(scriptNode) &#125; global.jsonp = jsonp;&#125;)(this); 使用示例 jsonp(&#123; url: &quot;www.example.com&quot;, data: &#123; id: 1 &#125;, callback: function(ret) &#123; console.log(ret); &#125;&#125;); 参考jsonp的原理与实现","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"js正则方法","date":"2021-02-14T07:08:27.000Z","path":"2021/02/14/2021-02-14-js-regex-method/","text":"js有很多正则方法： test、search、match、replace、exec ，他们之间的区别是什么呢 定义正则： var re = new RegExp(“a”); //RegExp对象。参数就是我们想要制定的规则。当参数为变量时，可以使用这种方式var re = /a/; // 简写方法 推荐使用 性能更好 不能为空 不然以为是注释 ， javascript中正则表达式支持的正则表达式有三个， g、i、m ，分别代表全局匹配、忽略大小写、多行模式。三种属性可以自由组合共存。 test在字符串中查找符合正则的内容，若查找到返回true, 反之返回false.用法： reg.test(str) var str = &#x27;374829348791&#x27;;var re = /\\D/; // \\D代表非数字if (re.test(str)) &#123; // 返回true,代表在字符串中找到了非数字。 console.log(&#x27;不全是数字&#x27;);&#125; else &#123; console.log(&#x27;全是数字&#x27;);&#125; search在字符串搜索符合正则的内容，搜索到就返回出现的位置（从0开始，如果匹配的不只是一个字母，那只会返回第一个字母的位置）， 如果搜索失败就返回 -1用法: str.search(reg) var str = &#x27;abcdef&#x27;;var re = /B/i;//var re = new RegExp(&#x27;B&#x27;,&#x27;i&#x27;); 也可以这样写console.log(str.search(re)); // 1 match在字符串中搜索复合规则的内容，搜索成功就返回内容，格式为数组，失败就返回null。用法： str.match(reg) var str = &#x27;haj123sdk54hask33dkhalsd879&#x27;;var re = /\\d+/g;// 每次匹配至少一个数字 且全局匹配 如果不是全局匹配，当找到数字123，它就会停止了。// 就只会弹出123.加上全局匹配，就会从开始到结束一直去搜索符合规则的。如果没有加号，匹配的结果就是1，2，3，5，4，3，3，8，7，9并不是我们想要的，// 有了加号，每次匹配的数字就是至少一个了。console.log(str.match(re)); // [123，54，33，879] replace查找符合正则的字符串，就替换成对应的字符串。返回替换后的内容。用法： str.replace(//, 新的字符串/回调函数) 第一个参数也可以是字符串 var str = &quot;我爱北京天安门，天安门上太阳升。&quot;;var re = /北京|天安门/g; // 找到北京 或者天安门 全局匹配var str2 = str.replace(re, function(str) &#123; console.log(str); //用来测试：函数的第一个参数代表每次搜索到的符合正则的字符，所以第一次str指的是北京 第二次str是天安门 第三次str是天安门 var result = &#x27;&#x27;; for (var i = 0; i &lt; str.length; i++) &#123; result += &#x27;*&#x27;; &#125; return result; //所以搜索到了几个字就返回几个*&#125;);console.log(str2) //我爱*****，***上太阳升//整个过程就是，找到北京，替换成了两个*，找到天安门替换成了3个*，找到天安门替换成3个*。 replace()的第二个参数replacement是一个字符串，表示替换的文本，其中可以使用一些特殊字符串。 $&amp;：匹配的子字符串。 $` ：匹配结果前面的文本。 $’：匹配结果后面的文本。 $n：匹配成功的第n组内容，n是从1开始的自然数。这个参数生效的前提是，第一个参数必须是正则* 表达式。 $$：指代美元符号$。 参考replace exec和match方法一样，搜索符合规则的内容，并返回内容，格式为数组，失败就返回null。用法： reg.exec(str) var testStr = &quot;now test001 test002&quot;;var re = /test(\\d+)/; //只匹配一次var r = &quot;&quot;;var r = re.exec(testStr)console.log(r); // test001 001 返回匹配结果，以及子项console.log(r.length); //2 返回内容的长度console.log(r.input); //now test001 test002 代表每次匹配成功的字符串console.log(r[0]); //test001console.log(r[1]); //001 代表每次匹配成功字符串中的第一个子项 (\\d+)console.log(r.index); // 4 每次匹配成功的字符串中的第一个字符的位置 replaceAlles6新增，历史上，字符串的实例方法replace()只能替换第一个匹配。 &#x27;aabbcc&#x27;.replace(&#x27;b&#x27;, &#x27;_&#x27;)// &#x27;aa_bcc&#x27; 上面例子中，replace()只将第一个b替换成了下划线。如果要替换所有的匹配，不得不使用正则表达式的g修饰符。 &#x27;aabbcc&#x27;.replace(/b/g, &#x27;_&#x27;)// &#x27;aa__cc&#x27; 正则表达式毕竟不是那么方便和直观，ES2021 引入了replaceAll()方法，可以一次性替换所有匹配。 &#x27;aabbcc&#x27;.replaceAll(&#x27;b&#x27;, &#x27;_&#x27;)// &#x27;aa__cc&#x27; 如果searchValue是一个不带有g修饰符的正则表达式，replaceAll()会报错。这一点跟replace()不同。 // 不报错&#x27;aabbcc&#x27;.replace(/b/, &#x27;_&#x27;)// 报错&#x27;aabbcc&#x27;.replaceAll(/b/, &#x27;_&#x27;) 上面代码中，searchValue是搜索模式，可以是一个字符串，也可以是一个全局的正则表达式（带有g修饰符）。 matchAll","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"linux终端快捷键","date":"2021-02-10T06:01:24.000Z","path":"2021/02/10/2021-02-10-linux-terminal-keyboard-shortcut/","text":"linux终端下有很多快捷键，这些快捷键能大大提高我们的效率，例如：ctrl+shift+c是复制命令，ctrl+shift+v是粘贴 我想提一下一些快捷键可能依赖于你使用的 Shell。 Bash 是最受欢迎的 shell，所以列出的快捷键集中在 Bash。 如果你愿意，你也可以称其为 Bash 快捷键列表。 注意我在键盘快捷键中使用了大写字母，但这并不意味着你在使用快捷键时必须按下 shift 键。 常用Tab这是你不能没有的 Linux 快捷键。它将节省你 Linux 命令行中的大量时间。只需要输入一个命令，文件名，目录名甚至是命令选项的开头，并敲击 tab 键。它将自动完成你输入的内容，或为你显示全部可能的结果。如果你只记一个快捷键，这将是必选的一个。 Ctrl + C这些是为了在终端上中断命令或进程该按的键。它将立刻终止运行的程序。如果你想要停止使用一个正在后台运行的程序，只需按下这对组合键。 Ctrl + Z该快捷键将正在运行的程序送到后台。 通常，你可以在使用 &amp; 选项运行程序前之完成该操作， 但是如果你忘记使用选项运行程序，就使用这对组合键。 Ctrl + D这对键盘快捷键将使你退出当前终端。如果你使用 SSH 连接，它将会关闭。 如果你直接使用一个终端，该应用将会立刻关闭。把它当成”退出”命令。 Ctrl + L你怎么清空你的终端屏幕？我猜是用 clear 命令。你可以使用 Ctrl+L 清空终端，代替输入 C-L-E-A-R。得心应手，不是吗？ Ctrl + A该快捷键将移动光标到所在行首。假设你在终端输入了一个很长的命令或路径，并且你想要回到它的开头， 使用方向键移动光标将花费大量时间。注意你无法使用鼠标移动光标到行首。这是 Ctrl+A 节省时间的地方。 Ctrl + E这对快捷键与 Ctrl+A 相反。 Ctrl+A 送光标到行首，反之 Ctrl+E 移动光标到行尾。 Ctrl + U输入了错误的命令？ 代替用退格键来丢弃当前命令，使用 Linux 终端中的 Ctrl+U 快捷键。 该快捷键会擦除从当前光标位置到行首的全部内容。 Ctrl + K这对和 Ctrl+U 快捷键有点像。 唯一的不同在于不是行首，它擦除的是从当前光标位置到行尾的全部内容。 Ctrl + W你刚才了解了擦除到行首和行尾的文本。 但如果你只需要删除一个单词呢？使用 Ctrl+W 快捷键。使用 Ctrl+W 快捷键，你可以擦除光标位置前的单词。 如果光标在一个单词本身上，它将擦除从光标位置到词首的全部字母。最好的方法是用它移动光标到要删除单词后的一个空格上， 然后使用 Ctrl+W 键盘快捷键。 Ctrl + Y这将粘贴使用 Ctrl+W，Ctrl+U 和 Ctrl+K 快捷键擦除的文本。 如果你删除了错误的文本或需要在某处使用已擦除的文本，这将派上用场。 Ctrl + P你可以使用该快捷键来查看上一个命令。 你可以反复按该键来返回到历史命令。 在很多终端里，使用 PgUp 键来实现相同的功能。 Ctrl + N你可以结合 Ctrl+P 使用该快捷键。Ctrl+N 显示下一个命令。 如果使用 Ctrl+P 查看上一条命令，你可以使用 Ctrl+N 来回导航。 许多终端都把此快捷键映射到 PgDn 键。 Ctrl + R你可以使用该快捷键来搜索历史命令。 Ctrl+左右键在单词之间跳转 其他Alt – d ：由光标位置开始，往右删除单词。往行尾删 说明 Ctrl – k: 先按住 Ctrl 键，然后再按 k 键； Alt – k: 先按住 Alt 键，然后再按 k 键； M – k：先单击 Esc 键，然后再按 k 键。 移动光标 Ctrl – a ：移到行首 Ctrl – e ：移到行尾 Ctrl – b ：往回(左)移动一个字符 Ctrl – f ：往后(右)移动一个字符 Alt – b ：往回(左)移动一个单词 Alt – f ：往后(右)移动一个单词 Ctrl – xx ：在命令行尾和光标之间移动 M-b ：往回(左)移动一个单词 M-f ：往后(右)移动一个单词 编辑命令 Ctrl – h ：删除光标左方位置的字符 Ctrl – d ：删除光标右方位置的字符（注意：当前命令行没有任何字符时，会销系统或结束终端） Ctrl – w ：由光标位置开始，往左删除单词。往行首删 Alt – d ：由光标位置开始，往右删除单词。往行尾删 M – d ：由光标位置开始，删除单词，直到该单词结束。 Ctrl – k ：由光标所在位置开始，删除右方所有的字符，直到该行结束。 Ctrl – u ：由光标所在位置开始，删除左方所有的字符，直到该行开始。 Ctrl – y ：粘贴之前删除的内容到光标后。 ctrl – t ：交换光标处和之前两个字符的位置。 Alt + . ：使用上一条命令的最后一个参数。 Ctrl – _ ：回复之前的状态。撤销操作。 Ctrl -a + Ctrl -k 或 Ctrl -e + Ctrl -u 或 Ctrl -k + Ctrl -u 组合可删除整行。 Bang(!)命令 !! ：执行上一条命令。 ^foo^bar ：把上一条命令里的foo替换为bar，并执行。 !wget ：执行最近的以wget开头的命令。 !wget:p ：仅打印最近的以wget开头的命令，不执行。 !$ ：上一条命令的最后一个参数， 与 Alt - . 和 $_ 相同。 !* ：上一条命令的所有参数 !*:p ：打印上一条命令是所有参数，也即 !*的内容。 ^abc ：删除上一条命令中的abc。 ^foo^bar ：将上一条命令中的 foo 替换为 bar ^foo^bar^ ：将上一条命令中的 foo 替换为 bar !-n ：执行前n条命令，执行上一条命令： !-1， 执行前5条命令的格式是： !-5 查找历史命令 Ctrl – p ：显示当前命令的上一条历史命令 Ctrl – n ：显示当前命令的下一条历史命令 Ctrl – r ：搜索历史命令，随着输入会显示历史命令中的一条匹配命令，Enter键执行匹配命令；ESC键在命令行显示而不执行匹配命令。 Ctrl – g ：从历史搜索模式（Ctrl – r）退出。 控制命令 Ctrl – l ：清除屏幕，然后，在最上面重新显示目前光标所在的这一行的内容。 Ctrl – o ：执行当前命令，并选择上一条命令。 Ctrl – s ：阻止屏幕输出 Ctrl – q ：允许屏幕输出 Ctrl – c ：终止命令 Ctrl – z ：挂起命令 重复执行操作动作 M – 操作次数 操作动作 ： 指定操作次数，重复执行指定的操作。 总结： 在 Linux 下使用命令操作的时候，光标的移动令人头痛。命令输入完了，执行之后发现缺少权限，然后不得不移动光标到行首，而命令又极长……以上是一些每个 Linux 用户必须使用的键盘快捷键。使用命令行时，这些 Linux 快捷键将提升你的工作效率和效率。 参考Linux 用户必知：一分钟掌握14个常用Linux命令行快捷键","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"}]},{"title":"js fetch简介","date":"2021-02-03T10:34:45.000Z","path":"2021/02/03/2021-02-03-js-fetch/","text":"fetch 与 jquery 的ajax类似，提供一种访问http的方法，它是浏览器的全局方法， 目前IE不支持 简介Fetch API 提供了一个 JavaScript 接口，用于访问和操纵 HTTP 管道的一些具体部分，例如请求和响应。它还提供了一个全局 fetch() 方法，该方法提供了一种简单，合理的方式来跨网络异步获取资源。 这种功能以前是使用 XMLHttpRequest 实现的。Fetch 提供了一个更理想的替代方案，可以很容易地被其他技术使用，例如 Service Workers。Fetch 还提供了专门的逻辑空间来定义其他与 HTTP 相关的概念，例如 CORS 和 HTTP 的扩展。 请注意，fetch 规范与 jQuery.ajax() 主要有三种方式的不同： 当接收到一个代表错误的 HTTP 状态码时，从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 fetch() 可以接受跨域 cookies；你也可以使用 fetch() 建立起跨域会话。 fetch 不会发送 cookies。除非你使用了credentials 的初始化选项。（自 2017 年 8 月 25 日以后，默认的 credentials 政策变更为 same-origin。Firefox 也在 61.0b13 版本中进行了修改） 示例fetch(&#x27;http://example.com/movies.json&#x27;) .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); &#125;); 这里我们通过网络获取一个 JSON 文件并将其打印到控制台。最简单的用法是只提供一个参数用来指明想 fetch() 到的资源路径，然后返回一个包含响应结果的promise（一个 Response 对象）。 当然它只是一个 HTTP 响应，而不是真的JSON。为了获取JSON的内容，我们需要使用 json() 方法 参数// Example POST method implementation:postData(&#x27;http://example.com/answer&#x27;, &#123; answer: 42 &#125;) .then(data =&gt; console.log(data)) // JSON from `response.json()` call .catch(error =&gt; console.error(error))function postData(url, data) &#123; // Default options are marked with * return fetch(url, &#123; body: JSON.stringify(data), // must match &#x27;Content-Type&#x27; header cache: &#x27;no-cache&#x27;, // *default, no-cache, reload, force-cache, only-if-cached credentials: &#x27;same-origin&#x27;, // include, same-origin, *omit headers: &#123; &#x27;user-agent&#x27;: &#x27;Mozilla/4.0 MDN Example&#x27;, &#x27;content-type&#x27;: &#x27;application/json&#x27; &#125;, method: &#x27;POST&#x27;, // *GET, POST, PUT, DELETE, etc. mode: &#x27;cors&#x27;, // no-cors, cors, *same-origin redirect: &#x27;follow&#x27;, // manual, *follow, error referrer: &#x27;no-referrer&#x27;, // *client, no-referrer &#125;) .then(response =&gt; response.json()) // parses response to JSON&#125; 参考使用 Fetch","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"js箭头函数和普通函数区别","date":"2021-01-16T09:51:10.000Z","path":"2021/01/16/2021-01-16-diff-from-arrow-function-and-function/","text":"普通函数在 es5 中就有了，箭头函数是 es6 中出现的函数形式，当然也可以继续用普通函数。 箭头函数代码少，更利于阅读，但是在有些情况下，会表现出和普通函数不一样的特性 箭头函数语法 开发时根据实际情况可以省略一些东西 单条处理可以省略 return 和{大括号} 单个参数可以省略(小括号) &gt; [1, 2, 3].map(item =&gt; item * 2) // (3)[2, 4, 6] 不能作为构造函数箭头函数不能作为构造函数 不能 new。会报错 let A = () =&gt; &#123;&#125;;// undefinedlet a = new A();// VM423: 1 Uncaught TypeError: A is not a constructor// at &lt; anonymous &gt;: 1: 9 不绑定 arguments，但是可使用 …rest 参数普通函数使用 arguments let A = function (a) &#123; console.log(arguments);&#125;;// undefinedA(1, 2, 3, 4);// VM530: 2 Arguments(4)[1, 2, 3, 4, callee: ƒ, Symbol(Symbol.iterator): ƒ]// undefined 箭头函数使用，用了会报错。 但是可以使用 ...rest 函数 let A = (...a) =&gt; console.log(a);// undefinedA(1, 2, 3, 4);// VM680: 1(4)[1, 2, 3, 4]// undefined arguments 的一般使用场景是：允许传入 3 个参数，中间一个参数是可选。如果只传 1 个参就是参数 1 用，传入 2 个参就是参数 1 和参数 3 用… let f = function (a, b, c) &#123; if (arguments.length == 2) &#123; c = b; b = null; &#125; console.log(a, b, c);&#125;;f(1);// VM850: 6 1 undefined undefinedf(1, 2);// VM850: 6 1 null 2f(1, 2, 3);// VM850: 6 1 2 3 rest 参数使用效果：rest 默认是[]，多余的传参会加入数组 this 指向不一样 f1 是箭头函数，this 代表上层对象，若无自定义上层，则代表 window。 f2 是普通函数，this 代表当前对象。 箭头函数的 call()或 apply()函数，不会影响到 this 的代表对象： 箭头函数没有原型属性： prototype 是普通函数用于获取原型对象的。 总结箭头函数内的 this 指向上层对象，bind()、call()、apply()均无法改变指向。 普通函数内的 this 执行调用其函数的对象。 参考理解普通函数和箭头函数的区别点","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"css从右往左匹配规则","date":"2021-01-16T09:37:04.000Z","path":"2021/01/16/2021-01-16-css-match-principle/","text":"举个例子 .mod-nav h3 span &#123; font-size: 16px;&#125; 上述代码在css运行时，是从左往右匹配呢，还是从右往左匹配。 如果不知道匹配规则，可能的理解是从左向右匹配: 先找到.mod-nav，然后逐级匹配h3、span，在这个过程中如果遍历到叶子节点都没有匹配就需要回溯，继续寻找下一个分支。 但事实上，CSS选择器的读取顺序是从右向左。 还是上面的选择器，它的读取顺序变成：先找到所有的span，沿着span的父元素查找h3，中途找到了符合匹配规则的节点就加入结果集；如果直到根元素html都没有匹配，则不再遍历这条路径，从下一个span开始重复这个过程（如果有多个最右节点为span的话）。 为什么从右向左的规则要比从左向右的高效？ .mode-nav / \\ header div / \\ h3 ul | / \\span li ... li | | a a 假如DOM的结构如上图，匹配规则是 .mod-nav h3 span 。 若从左向右的匹配，过程是：从 .mod-nav 开始，遍历子节点 header 和子节点 div ，然后各自向子节点遍历。在右侧 div 的分支中，最后遍历到叶子节点 a ，发现不符合规则，需要回溯到 ul 节点，再遍历下一个 li-a ，假如有1000个 li ，则这1000次的遍历与回溯会损失很多性能。 再看看从右至左的匹配：先找到所有的最右节点 span ，对于每一个 span ，向上寻找节点 h3 ，由h3再向上寻找class=mod-nav的节点，最后找到根元素 html 则结束这个分支的遍历。 很明显，两种匹配规则的性能差别很大。之所以会差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点）；而从左向右的匹配规则的性能都浪费在了失败的查找上面。 当然这是比较明显情况，如果在叶子上存在多个不符合条件的 span ，从右向左的规则也会走一些弯路（这时就需要优化 CSS 选择器了）。但平均来说它还是更高效，因为大多时候，一个 DOM 树中，符合匹配条件的节点（如 .mod-nav h3 span ）远远远远少于不符合条件的节点。 jQuery 从1.3版本开始使用的 Sizzle 引擎，它按照了 CSS 选择器的匹配规则（从右至左）进行DOM元素的查找与匹配（当然其中做了很多优化），性能得到了很大的提升。 参考CSS选择器从右向左的匹配规则","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"js数据类型判断","date":"2021-01-01T03:19:20.000Z","path":"2021/01/01/2021-01-01-js-data-type-judge/","text":"javascrip中有几种判断数据类型的办法，不同的场景使用不同的方法 typeof 、 Object.prototype.toString.call 、 instance of typeoftypeof 是一个一元运算，放在一个运算数之前，运算数可以是任意类型。返回值是一个字符串，该字符串说明运算数的类型。typeof 一般只能返回如下几个结果：number, boolean, string, function, object, undefined 。一般可以使用 typeof 来获取一个变量是否存在，如 if (typeof a != &quot;undefined&quot;) &#123; alert(&quot;ok&quot;)&#125; 而不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错，对于 Array , Null 等特殊对象使用 typeof 一律返回 object ，这正是 typeof 的局限性。 Object.prototype.toString.call1. 判断基本类型：Object.prototype.toString.call(null); //&quot;[object Null]&quot;Object.prototype.toString.call(undefined); //&quot;[object Undefined]&quot;Object.prototype.toString.call(&quot;abc&quot;); //&quot;[object String]&quot;Object.prototype.toString.call(123); //&quot;[object Number]&quot;Object.prototype.toString.call(true); //&quot;[object Boolean]&quot; 2. 判断原生引用类型：函数类型Function fn() &#123; console.log(&quot;test&quot;);&#125;Object.prototype.toString.call(fn); //&quot;[object Function]&quot;日期类型var date = new Date();Object.prototype.toString.call(date); //&quot;[object Date]&quot;数组类型var arr = [1, 2, 3];Object.prototype.toString.call(arr); //&quot;[object Array]&quot;正则表达式var reg = /[hbc]at/gi;Object.prototype.toString.call(arr); //&quot;[object RegExp]&quot;自定义类型function Person(name, age) &#123; this.name = name; this.age = age;&#125;var person = new Person(&quot;Rose&quot;, 18);Object.prototype.toString.call(person); //&quot;[object Object]&quot; instance ofinstanceof 用于判断一个变量是否某个对象的实例，如 var a = new Array();alert(a instanceof Array); 会返回 true，同时 alert(a instanceof Object) 也会返回 true ; 这是因为 Array 是 object 的子类。 但是当我们用变量直接赋值时，它不是由构造函数产生的， instanceof 为 false var a = &#x27;123&#x27;undefineda instanceof Objectfalsevar a = new String(&#x27;123&#x27;)undefineda instanceof Objecttrue","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"浏览器从输入URL到渲染完页面的整个过程","date":"2020-12-29T02:22:01.000Z","path":"2020/12/29/2020-12-29-process-of-render-page/","text":"从输入 URL 到渲染出整个页面的过程包括以下部分： 1、DNS 解析 URL 的过程 2、浏览器发送请求与服务器交互的过程（3 次握手） 3、浏览器对接收到的 html 页面渲染的过程 4、浏览器和服务器断开连接（4 次握手） DNS 解析 URL 的过程DNS 解析的过程就是寻找哪个服务器上有请求的资源。因为 ip 地址不容易记忆，一般会使用 URL 域名（如www.baidu.com）作为网址。DNS 解析就是将域名翻译成 IP 地址的过程。 具体过程： 1 浏览器缓存：浏览器会按照一定的频率 缓存 DNS 记录 2 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，就会取操作系统中找 3 路由缓存：路由器也有 DNS 缓存 4 ISP 的 DNS 服务器：ISP 有专门的 DNS 服务器应对 DNS 查询请求 5 根服务器：ISP 的 DNS 服务器找不到之后，就要向根服务器发出请求，进行递归查询 浏览器与服务器交互过程 1 首先浏览器利用 tcp 协议通过三次握手与服务器建立连接 http 请求包括 header 和 body。header 中包括请求的方式（get 和 post）、请求的协议 （http、https、ftp）、请求的地址 ip、缓存 cookie。body 中有请求的内容。 tcp 将 http 长报文划分为短报文，通过三次握手与服务端建立连接，进行可靠传输。三次握手的步骤（抽象派）客户端：hello，你是 server 么？服务端：hello，我是 server，你是 client 么客户端：yes，我是 client 2 浏览器根据解析到的 IP 地址和端口号发起 http 的 get 请求. 3 服务器接收到 http 请求之后，开始搜索 html 页面，并使用 http 返回响应报文 4 若状态码为 200 显示响应成功，浏览器接收到返回的 html 页面之后，开始进行页面的渲染 浏览器页面渲染过程 1 浏览器根据深度遍历的方式把 html 节点遍历成 dom 树 2 将 css 解析成 CSS DOM 树 3 将 dom 树和 CSS DOM 树构造成 render 树 4 JS 根据得到的 render 树 计算所有节点在屏幕中的位置，进行布局（回流） 5 遍历 render 树并调用硬件 API 绘制所有节点（重绘） 浏览器与服务器断开连接断开连接时，需要进行四次挥手（因为是全双工的，所以需要四次挥手）。 四次挥手的步骤(抽象派) 主动方：我已经关闭了向你那边的主动通道了，只能被动接收了 被动方：收到通道关闭的信息 被动方：那我也告诉你，我这边向你的主动通道也关闭了 主动方：最后收到数据，之后双方无法通信","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"}]},{"title":"VUE基础知识","date":"2020-12-22T16:00:00.000Z","path":"2020/12/23/2020-12-23-vue-knownledge/","text":"vue 双向绑定的原理采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调，实现视图刷新。 具体流程：Vue 中先遍历 data 选项中所有的属性（发布者）用 Object.defineProperty 劫持这些属性将其转为 getter/setter。读取数据时候会触发 getter。修改数据时会触发 setter。 然后给每个属性对应 new Dep()，Dep 是专门收集依赖、删除依赖、向依赖发送消息的。先让每个依赖设置在 Dep.target 上，在 Dep 中创建一个依赖数组，先判断 Dep.target 是否已经在依赖中存在，不存在的话添加到依赖数组中完成依赖收集，随后将 Dep.target 置为上一个依赖。 组件在挂载过程中都会 new 一个 Watcher 实例。这个实例就是依赖（订阅者）。Watcher 第二参数是一个函数，此函数作用是更新且渲染节点。在首次渲染过程，会自动调用 Dep 方法来收集依赖，收集完成后组件中每个数据都绑定上该依赖。当数据变化时就会在 setter 中通知对应的依赖进行更新。在更新过程中要先读取数据，就会触发 Wacther 的第二个函数参数。一触发就再次自动调用 Dep 方法收集依赖，同时在此函数中运行patch（diff 运算)来更新对应的 DOM 节点，完成了双向绑定。 每一个组件默认都会创建一个 Watcher，自定义的 watch 和 computed 方法也会创建 Watcher Object.defineProperty()实现双向绑定的缺点 只能监听某个属性，不能监听整个对象 需要使用 for in 遍历对象属性绑定监听 不能监听数组，需要重写数组方法进行特异性操作 会污染原对象 直接给一个数组项赋值，vue 能检测到吗 由于 js 的限制(引用类型)，vue 不能检测到以下数组的变动(对象属性的添加和删除)： 当你利用索引直接设置一个数组项时，例如 vm.item[indexOfItem] = newValue 当你修改数组的长度时，例如 vm.items.length = newLength 为了解决第一个问题，vue 提供了以下操作方法： Vue.set(vm.items, indexOfItem, newValue)Vue.$set(vm.items, indexOfItem, newValue)Vue.$set(this.data, ”key”, value) // 动态添加单个属性// 动态添加多个属性this.obj = Object.assign(&#123;&#125;, this.obj, &#123; age: 18, name: &#x27;Chocolate&#x27;,&#125;)Vue.items.splice(indexOfItem, 1, newValue) 为了解决第二个问题，vue 提供了以下操作方法： vm.items.splice(newLength); Vue 是不能检测对象属性的添加或删除 data() &#123; return &#123; obj: &#123; name: &#x27;Vue&#x27; &#125; &#125;; &#125;, mounted() &#123; this.name = &#x27;zs&#x27; // 不是响应式的 this.$set(this.obj, &#x27;name&#x27;, &#x27;lisi&#x27;) //响应式 解决添加 // 用Object.assign来解决第二种情况。解决对象的删除 // Vue.delete &#125;, delete 和 Vue.delete 的区别delete 只是被删除的元素变成了 empty/undefined，其他元素的键值还是不变的。而 Vue.delete 直接删除了数组，改变了数组的键值。 Vue 中能监听到数组变化的方法有哪些？为什么这些方法能监听到呢？ push()、pop()、shift()、unshift()、splice()、sort()、reverse()，这些方法在 Vue 中被重新定义了，故可以监听到数组变化； filter()、concat()、slice()，这些方法会返回一个新数组，也可以监听到数组的变化。 组件中的 data 为什么是个函数因为组件是拿来复用的，且 js 里的对象是引用关系，如果组件中的 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中的 data 是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响，而 new Vue 的实例是不会被复用的，因此不存在引用对象的问题。 不需要响应式的数据应该怎么处理// 1 定义在data之外data() &#123; this.list1 = &#123; &#125;; this.list2 = &#123; &#125;; return &#123;&#125;&#125;// 2 Object.freezedata() &#123; return &#123; list1: Object.freeze(&#123;&#125;) list2: Object.freeze(&#123;&#125;) &#125;&#125; vue 指令v-show 和 v-if 有什么区别 v-if（初始化不会渲染）v-if 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听和子组件适当地被销毁和重建，也是惰性的，如果在初始渲染条件为假时，则什么也不做——直到条件第一次变为真时才开始渲染条件块，能用在 &lt;template&gt; 上。 v-show（初始化会渲染）v-show 就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 css 的 display 进行切换。 所以，v-if 适用于切换不频繁的场景，v-show 适用于切换频繁的场景，不能用在 &lt;template&gt; 上。 为什么在 v-for 中使用 key？为了标识每个唯一的节点，方便比较，v-for 中加 key 可以减少渲染次数，提升渲染性能。 举个例子 &lt;div v-for=&quot;(item, index) in list&quot; :key=&quot;index&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;list: [ &#123; name: &#x27;小明&#x27;, id: &#x27;11&#x27; &#125;, &#123; name: &#x27;小红&#x27;, id: &#x27;12&#x27; &#125;, &#123; name: &#x27;小蓝&#x27;, id: &#x27;13&#x27; &#125;,]&lt;!-- 渲染为 --&gt;&lt;div key=&quot;0&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;1&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;2&quot;&gt;小蓝&lt;/div&gt;&lt;!-- 现在执行 list.unshift(&#123; name: &#x27;小林&#x27;, id: &#x27;14&#x27; &#125;) --&gt;&lt;!-- 渲染为 --&gt;&lt;div key=&quot;0&quot;&gt;小林&lt;/div&gt;&lt;div key=&quot;1&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;2&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;3&quot;&gt;小蓝&lt;/div&gt;&lt;!-- 新旧对比 --&gt;&lt;div key=&quot;0&quot;&gt;小明&lt;/div&gt; &lt;div key=&quot;0&quot;&gt;小林&lt;/div&gt;&lt;div key=&quot;1&quot;&gt;小红&lt;/div&gt; &lt;div key=&quot;1&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;2&quot;&gt;小蓝&lt;/div&gt; &lt;div key=&quot;2&quot;&gt;小红&lt;/div&gt; &lt;div key=&quot;3&quot;&gt;小蓝&lt;/div&gt; 可以看出，如果用 index 作 key 的话，如果数组 index 发生了变化，没有提升渲染效率 &lt;!-- 现在我们用id作key --&gt;&lt;div key=&quot;11&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;12&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;13&quot;&gt;小蓝&lt;/div&gt;&lt;!-- 现在执行 list.unshift(&#123; name: &#x27;小林&#x27;, id: &#x27;14&#x27; &#125;) --&gt;&lt;div key=&quot;14&quot;&gt;小林&lt;/div&gt;&lt;div key=&quot;11&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;12&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;13&quot;&gt;小蓝&lt;/div&gt;&lt;!-- 新旧对比 --&gt;&lt;div key=&quot;14&quot;&gt;小林&lt;/div&gt;&lt;div key=&quot;11&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;11&quot;&gt;小明&lt;/div&gt;&lt;div key=&quot;12&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;12&quot;&gt;小红&lt;/div&gt;&lt;div key=&quot;13&quot;&gt;小蓝&lt;/div&gt;&lt;div key=&quot;13&quot;&gt;小蓝&lt;/div&gt;&lt;!-- 可以看出其他三项不变，只有小林是新增的 --&gt; 为什么 v-if 和 v-for 不建议用在同一标签在 vue 中 v-for 的优先级高于 v-if &lt;div v-for=&quot;item in [1,2,3,4,5]&quot; v-if=&quot;item !== 3&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/div&gt; 当 v-for 和 v-if 同时存在时，v-for 会把上面的 5 个元素全部渲染出来，然后在去执行 v-if，去把 3 节点隐藏起来，这样做的坏处在于渲染了无用的 dom 节点，可以使用 computed 去解决这个问题 &lt;div v-for=&quot;item in list&quot;&gt; &#123;&#123; item &#125;&#125;&lt;/div&gt;computed() &#123; list() &#123; return [1,2,3,4,5].filter(item =&gt; item !==3) &#125;&#125; class 和 style 如何动态绑定class 可以通过对象语法和数组语法进行动态绑定： 对象语法 &lt;div v-bind:class=&quot;&#123;active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; data: &#123; isActive: true, hasError: false &#125;&lt;/script&gt; 数组语法 &lt;div v-bind:class=&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;&gt;&lt;/div&gt;&lt;script&gt; data: &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125;&lt;/script&gt; style 也可以通过对象语法和数组语法进行动态绑定 动态绑定 Class 和 Style&lt;!--第一种对象语法 --&gt;&lt;div class=&quot;test&quot; :class=&quot;&#123;active:actived,&#x27;active-click&#x27;: clicked&amp;&amp;actived&#125;&quot;&gt;&lt;/div&gt;&lt;!-- 第二种数组语法 --&gt;&lt;div class=&quot;test&quot; :class=&quot;[actived?activeClass : &#x27;&#x27;, clicked&amp;&amp;actived?activeClickClass : &#x27;&#x27;]&quot;&gt;&lt;/div&gt;&lt;!-- 第三种对象和数组混合 --&gt;&lt;div :class=&quot;[testClass,&#123;active:actived&#125;,&#123;&#x27;active-click&#x27;:clicked&amp;&amp;actived&#125;]&quot;&gt;&lt;/div&gt;&lt;!-- 第四种对象和计算属性(推荐) --&gt;&lt;div :class=&quot;classObject&quot;&gt;&lt;/div&gt; v-model 的原理我们在 vue 项目中主要使用 v-model 指令在表单 input，textarea，select 等元素上创建双向绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件： text 和 textarea 元素使用 value 属性和 input 事件 checkbox 和 radio 使用 checked 和 change select 字段将 value 作为 prop 并将 change 作为事件 v-on 绑定多个方法&lt;template&gt; &lt;div v-on:&#123;click:a,dblclick:b&#125;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; methods: &#123; a() &#123; alert(1) &#125;, b() &#123; alert(2) &#125; &#125;&lt;/script&gt; slot 插槽分发很多时候，我们封装了一个子组件之后，在父组件使用的时候，想添加一些 dom 元素，这个时候就可以使用 slot 插槽了，但是这些 dom 是否显示以及在哪里显示，则是看子组件中 slot 组件的位置了。 v-clock 指令的作用 解决页面闪烁问题(会显示插值表达式)如果网速慢，而该标签内容是变量没有请求响应回来的时候，页面上先不显示该标签（vue 给该标签加了 css 样式），当响应回来的时候改标签默认将 css 样式去除。 此指令可以解决使用插值表达式页面闪烁问题 将该指令加在 html 标签中时，可以在该文件中加style 属性为 display：none &lt;div class=&quot;#app&quot; v-cloak&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt;&lt;/div&gt;[v-cloak] &#123; display: none; &#125; vue 父子组件实现双向绑定实例&lt;Child :name=&quot;name&quot; :change=&quot;changeName&quot; /&gt;&lt;script&gt; props: &#123; name: &#123; type: String, required: false &#125; &#125;, data() &#123; newName: &#x27;&#x27; &#125;, watch: &#123; name(val) &#123; this.newName = val &#125;, newName(val) &#123; this.$emit(&#x27;change&#x27;, val) &#125; &#125;&lt;/script&gt; 自定义 v-model自定义 v-model，设置子组件 model 属性，设置 v-model 侦听的属性值，同时绑定属性变化时执行的事件，实现自定义 v-model，即双向绑定。 // v-model只是一个语法糖&lt;input type=&quot;text&quot; v-model=&quot;price&quot; /&gt;&lt;input type=&quot;text&quot; :value=&quot;price&quot; @input=&quot;price=$event.target.value&quot; /&gt; Vue.extend 方法创建一个组件 // 注册组件Vue.component(&quot;base-checkbox&quot;, &#123; model: &#123; prop: &#x27;checked&#x27;, // 绑定属性 event: &#x27;change&#x27;, // 抛出事件 &#125;, props: &#123; checked: boolean &#125;, templete: `&lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;,$event.target.value)&quot;/&gt;` &#125;) &lt;base-checkbox v-model=&quot;value&quot; &gt; &lt;/base-checkbox&gt; 理解 vue 里的单向数据流所有的 prop 都使得其父子 prop 之间形成一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来不行，这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流难以解释. 额外地，每次父级组件发生更新时，子组件中的所有 prop 都会刷新为最新的值，这意味着你不应该在一个子组件内部改变 prop，如果你这样做了，vue 会在浏览器的控制台发出警告，子组件想修改时，只能通过$emit 派发一个自定义事件，父组件接收到后，由父组件修改. 双向数据流是指数据从父级向子级传递数据，子级可以通过一些手段改变父级向子级传递的数据。 computed 和 watchcomputed 和 watch 的区别和运用场景 computed：是计算属性，依赖其他属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变时下一次获取 computed 的值时候才会重新计算 computed 的值。避免在模板中放入太多的逻辑，导致模板过重且难以维护。当未发生改变时，则会返回上一次的数据。不能异步操作 watch：更多的是观察作用，类似于某些数据的监听回调，每当监听的数据发生变化时都会执行回调进行后续操作。可以进行异步操作 methods: 每次渲染时都需要重新执行。 简单的说： 1.methods 里面定义的是函数，你显然需要像fuc()这样去调用它（假设函数为 fuc）。 2.computed 是计算属性，事实上和和 data 对象里的数据属性是同一类的（使用上）。 3.watch: 类似于监听机制+事件机制。 watch 和 computed 的对比 首先它们都是以 Vue 的依赖追踪机制为基础的，它们的共同点是：都是希望在依赖数据发生改变的时候，被依赖的数据根据预先定义好的函数，发生“自动”的变化。我们当然可以自己写代码完成这一切，但却很可能造成写法混乱，代码冗余的情况。 但 watch 和 computed 也有明显不同的地方： watch 和 computed 各自处理的数据关系场景不同 1.watch 擅长处理的场景：一个数据影响多个数据 2.computed 擅长处理的场景：一个数据受多个数据影响 相比于 watch/computed，methods 不处理数据逻辑关系，只提供可调用的函数 运用场景： 当我们需要进行数值计算，并依赖于其他数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 但我们需要在数据变化时执行异步或开销较大的操作时应该使用 watch，使用 watch 选项允许我们执行异步操作，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态，这些都是计算属性无法做到的。 深入理解 vue computed 原理 computed 中的属性名和 data 中的属性名可以相同吗？也不能和 method 中属性同名不能同名，因为不管是 computed 属性名还是 data 数据名还是 props 数据名都会被挂载在 vm 实例上，因此这三个都不能同名。 watch 的属性使用箭头函数定义可以吗？不可以。this 会是 undefind, 因为箭头函数中的 this 指向的是定义时的 this，而不是执行时的 this，所以不会指向 Vue 实例的上下文。 watch 怎么深度监听对象变化监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值； watch: &#123; a: &#123; handler: function(val, oldval) &#123; &#125;, deep: true, // 一层层遍历给属性都加上监听器 immediate: true // 组件加载立即触发回调函数执行 &#125;, &#x27;obj.a&#x27;: &#123; &#125;&#125; Vue 生命周期vue 生命周期的理解（10 个） 生命周期是什么(创建到销毁的过程)vue 实例有一个完整的生命周期，也就是从开始创建，初始化数据，编译模板，挂载 dom-&gt;渲染更新-&gt;渲染卸载等一些过程，我们称这是 vue 的生命周期 各个生命周期的作用 beforeCreate：组件被创建之初，组件的属性生效之前 created：组件实例已经完全创建，属性也绑定，但是真实的 dom 还没有生成，$el 还不能用(vue 实例的数据对象data有了，el 和数据对象 data 都为 undefined，还未初始化。) beforeMount：在挂载开始之前被调用，相关的 render 函数首次被调用 mounted：el 被新创建的 vm.$el 替换，并挂载到实例上去后调用该钩子 beforeUpdate：组件数据更新之前调用，发生在虚拟 dom 打补丁之前 updated：组件数据更新之后 activated：keep-alive 专属，组件被激活时调用 deactivated：keep-alive 专属，组件被销毁时调用 beforeDestroy：组件被销毁前 destroyed：组件被销毁后调用 init initLifecycle/Event，往 vm 上挂载各种属性 callHook: beforeCreate: 实例刚创建 initInjection/initState: 初始化注入和 data 响应性 created: 创建完成，属性已经绑定， 但还未生成真实 dom 进行元素的挂载： $el / vm.$mount() 是否有 template: 解析成 render function *.vue 文件: vue-loader 会将&lt;template&gt;编译成 render function beforeMount: 模板编译/挂载之前 执行 render function，生成真实的 dom，并替换到 dom tree 中 mounted: 组件已挂载 update: 执行 diff 算法，比对改变是否需要触发 UI 更新 flushScheduleQueue watcher.before: 触发 beforeUpdate 钩子 watcher.run(): 执行 watcher 中的 notify，通知所有依赖项更新 UI 触发 updated 钩子: 组件已更新 actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活 destroy: beforeDestroy: 销毁开始 销毁自身且递归销毁子组件以及事件监听 remove(): 删除节点 watcher.teardown(): 清空依赖 vm.$off(): 解绑监听 destroyed: 完成后触发钩子 new Vue(&#123;&#125;)// 初始化Vue实例function _init() &#123; // 挂载属性 initLifeCycle(vm) // 初始化事件系统，钩子函数等 initEvent(vm) // 编译slot、vnode initRender(vm) // 触发钩子 callHook(vm, &#x27;beforeCreate&#x27;) // 添加inject功能 initInjection(vm) // 完成数据响应性 props/data/watch/computed/methods initState(vm) // 添加 provide 功能 initProvide(vm) // 触发钩子 callHook(vm, &#x27;created&#x27;) // 挂载节点 if (vm.$options.el) &#123; vm.$mount(vm.$options.el) &#125;&#125;// 挂载节点实现function mountComponent(vm) &#123; // 获取 render function if (!this.options.render) &#123; // template to render // Vue.compile = compileToFunctions let &#123; render &#125; = compileToFunctions() this.options.render = render &#125; // 触发钩子 callHook(&#x27;beforeMount&#x27;) // 初始化观察者 // render 渲染 vdom， vdom = vm.render() // update: 根据 diff 出的 patchs 挂载成真实的 dom vm._update(vdom) // 触发钩子 callHook(vm, &#x27;mounted&#x27;)&#125;// 更新节点实现function queueWatchecr(watcher) &#123; nextTick(flushScheduleQueue)&#125;// 清空队列function flushScheduleQueue() &#123; // 遍历队列中所有修改 for () &#123; // beforeUpdate watcher.before() // 依赖局部更新节点 watcher.update() callHook(&#x27;updated&#x27;) &#125;&#125;// 销毁实例实现Vue.prototype.$destory = function() &#123; // 触发钩子 callHook(vm, &#x27;beforeDestory&#x27;) // 自身及子节点 remove() // 删除依赖 watcher.teardown() // 删除监听 vm.$off() // 触发钩子 callHook(vm, &#x27;destoryed&#x27;)&#125; vue 父子组件生命周期钩子函数的执行顺序 加载渲染过程父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate-&gt;子 created-&gt;子 beforeMount-&gt;子 mounted-&gt;父 mounted 子组件更新过程父 beforeUpdate-&gt;子 beforeUpdate-&gt;子 updated-&gt;父 updated 父组件更新过程父 beforeUpdate-&gt;父 updated 销毁过程父 beforeDestroy-&gt;子 beforeDestroy-&gt;子 destroyed-&gt;父 destroy 在哪个生命周期内调用异步请求可以在函数 created，beforeMount，mounted 中进行调用，因为在这三个钩子函数中 data 已经可以创建，可以将服务端返回的数据进行赋值，但是比较推荐在 created 钩子函数中调用异步请求，因为： 能更快的获取到服务端数据，减少页面 loading 时间 ssr 不支持 beforeMount，mounted 钩子函数，所以放在 created 中有助于一致性 mounted 里能够操作 dom 在什么阶段才能访问操作 DOM在钩子函数 mounted 被调用之前，vue 已经把编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 dom，vue 具体的生命周期。 父组件可以监听到子组件的生命周期吗 手动设置$emit 来发布监听 // parent&lt;Child @mounted = &quot;fn&quot; / &gt; // child mounted() &#123; this.$emit(&quot;mounted&quot;); &#125; @hook // parent&lt;Child @hook: mounted = &quot;fn&quot; / &gt; fn() &#123; console.log(&#x27;get&#x27;) &#125;// childmounted() &#123; console.log(&#x27;emit&#x27;); 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？在 created 中，页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，DOM 节点没出来，无法操作 DOM 节点。在 mounted 不会这样，比较好。 组件什么时候下被销毁 没有使用 keep-alive 切换 v-if=&quot;false&quot; 执行 vm.$destroy() 谈谈你对 keep-alive 的了解keep-alive 是 vue 内置的一个组件，可以使被包含的组件保留状态，避免重复渲染，其有以下特性： 一般结合路由和动态组件使用，用于缓存组件 提供 include 和 exclude 属性，两者都支持字符串或正则表达式，include 表示只有名字匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存，其中 exclude 的优先级比 include 高 对应两个钩子函数 actived 和 deactivated vue 组件间通信有哪几种方式（6 种） props 和$emit适用父子组件通信 ref 和$parent $childrenref：如果在普通 dom 上使用，引用指向的就是 dom 元素，如果用在子组件上，引用就指向组件实例 $parent/$children：访问父子实例 EventBus（$emit/$on）这种方法通过一个空的 vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子，隔代，兄弟组件 $attrs/$listeners$attrs：包含了父作用域里不被 prop 所识别（且获取）的特性绑定（class 和 style 除外）。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定（class 和 style 除外），并且可以通过v-bind=&quot;$attrs&quot;传入内部组件。通常配合 inheritAttrs 选项一起使用 $listeners：包含了父作用域中的 v-on 事件监听器，它可以通过v-on=&quot;$listeners&quot;传入内部组件 provide、inject祖先组件通过 provide 来提供变量，然后在子孙组件中通过 inject 来注入变量，provide / inject API 主要解决了跨级组件间的通信问题，不过他的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立一种主动提供和依赖注入的关系 vuexvuex 是一个专为 vue 应用程序开发的状态管理模式，每一个 vuex 应用的核心就是 store，store 基本上就是一仓库，它包含着你的应用中大部分的状态 vuex 的状态存储是响应式的，当 vue 从 store 中读取状态时候，若 store 中的状态发生变化，那么相应的组件也会相应的得到高效更新 改变 store 中的状态的唯一的途径就是显式地提交 mutation，这样使我们可以方便地跟踪每一个状态的变化 provide/inject 有什么用？ 常用的父子组件通信方式都是父组件绑定要传递给子组件的数据，子组件通过 props 属性接收，一旦组件层级变多时，采用这种方式一级一级传递值非常麻烦，而且代码可读性不高，不便后期维护。 vue 提供了 provide 和 inject 帮助我们解决多层次嵌套嵌套通信问题。在 provide 中指定要传递给子孙组件的数据，子孙组件通过 inject 注入祖父组件传递过来的数据。 provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 provide() &#123; return &#123; elForm: this &#125;&#125;inject: [&#x27;elForm&#x27;]provide: &#123; name: &#x27;cosyer&#x27;&#125;inject: &#123; newName: &#123; from: &#x27;name&#x27;, default: &#x27;&#x27; &#125;&#125; vuex你使用过 vuex 吗vuex 是一个专门为 vue 应用程序开发的状态管理模式，每一个 vuex 应用的核心是 store，store 基本上就是一个容器，它包含着你的应用中大部分的状态（state） 主要包括以下几个模块： state：定义了应用状态的数据结构，可以在这里设置默认的初始状态 Getters：允许组件从 State 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性 Mutations：是唯一更改 store 中状态的方法，且必须是同步函数 Actions：用于提交 mutation，而不是直接更改状态，可以包含任意的异步操作 Modules：允许将单一的 Store 拆分成多个 store 且同时保存在单一的状态树里 vuex 解决了什么问题 多个组件依赖同一状态，多层嵌套繁琐，兄弟组件没办法传值通信。 不同组件的行为需要修改同一状态 Vuex 中状态是对象时，使用时要注意什么？因为对象是引用类型，复制后改变属性还是会影响原始数据，这样会改变 state 里面的状态，是不允许，所以先用深度克隆复制对象，再修改。 组件中批量使用 Vuex 的 state 状态import &#123; mapState &#125; from &#x27;vuex&#x27;;export default &#123; computed: &#123; ...mapState([&#x27;price&#x27;, &#x27;number&#x27;]), &#125;,&#125;; Vuex 中要从 state 派生一些状态出来，且多个组件使用它使用 getter 属性，相当 Vue 中的计算属性 computed，只有原状态改变派生状态才会改变。 const store = new Vuex.Store(&#123; state: &#123; price: 10, number: 10, discount: 0.7, &#125;, getters: &#123; total: state =&gt; &#123; return state.price * state.number; &#125;, discountTotal: (state, getters) =&gt; &#123; return state.discount * getters.total; &#125;, getTodoById: state =&gt; id =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id); &#125;, &#125;,&#125;); computed: &#123; total() &#123; return this.$store.getters.total &#125;, discountTotal() &#123; return this.$store.getters.discountTotal &#125;, getTodoById() &#123; return this.$store.getters.getTodoById &#125;, ...mapGetters([&#x27;total&#x27;, &#x27;discountTotal&#x27;]), // 批量使用getter属性 ...mapGetters(&#123; myTotal: &#x27;total&#x27;, myDiscountTotal: &#x27;discountTotal&#x27;, &#125;) // 取别名 &#125;, mounted() &#123; console.log(this.getTodoById(2).done) //false &#125; 在 getter 中可以通过第三个参数 rootState 访问到全局的 state, 可以通过第四个参数 rootGetters 访问到全局的 getter。 在 mutation 中不可以访问全局的 state 和 getter，只能访问到局部的 state。 在 action 中第一个参数 context 中的 context.rootState 访问到全局的 state，context.rootGetters 访问到全局的 getter。 在组件中多次提交同一个 mutation, actionmethods: &#123; ...mapMutations(&#123; setNumber: &#x27;SET_NUMBER&#x27;, &#125;), ...mapActions(&#123; setNumber: &#x27;SET_NUMBER&#x27;, &#125;)&#125; this.setNumber(10)相当调用 this.$store.commit(&#39;SET_NUMBER&#39;, 10) Vuex 中 action 和 mutation 有什么区别？ action 提交的是 mutation，而不是直接变更状态。mutation 可以直接变更状态。 action 可以包含任意异步操作。mutation 只能是同步操作。 提交方式不同，action 是用 this.$store.dispatch(&#39;ACTION_NAME&#39;,data)来提交。mutation是用this.$store.commit(&#39;SET_NUMBER&#39;,10)来提交。 接收参数不同： &#123; state, // 等同于 `store.state`，若在模块中则为局部状态 rootState, // 等同于 `store.state`，只存在于模块中 commit, // 等同于 `store.commit` dispatch, // 等同于 `store.dispatch` getters, // 等同于 `store.getters` rootGetters; // 等同于 `store.getters`，只存在于模块中&#125; 多个 actions，A 结束后再执行其他操作 actions: &#123; async actionA(&#123; commit &#125;) &#123; //... &#125;, async actionB(&#123; dispatch &#125;) &#123; await dispatch(&#x27;actionA&#x27;) //等待actionA完成 // ... &#125;&#125; 命名空间export default &#123; namespaced: true, state, getters, mutations, actions,&#125;; 怎么在带命名空间的模块内提交全局的 mutation 和 action？ this.$store.dispatch(&#x27;actionA&#x27;, null, &#123; root: true,&#125;);this.$store.commit(&#x27;mutationA&#x27;, null, &#123; root: true,&#125;); 在 Vuex 插件中怎么监听组件中提交 mutation 和 action？export default function createPlugin(param) &#123; return store =&gt; &#123; store.subscribe((mutation, state) =&gt; &#123; console.log(mutation.type); //是那个mutation console.log(mutation.payload); console.log(state); &#125;); // store.subscribeAction((action, state) =&gt; &#123; // console.log(action.type)//是那个action // console.log(action.payload)//提交action的参数 // &#125;) store.subscribeAction(&#123; before: (action, state) =&gt; &#123; //提交action之前 console.log(`before action $&#123;action.type&#125;`); &#125;, after: (action, state) =&gt; &#123; //提交action之后 console.log(`after action $&#123;action.type&#125;`); &#125;, &#125;); &#125;;&#125; 在 v-model 上怎么用 Vuex 中 state 的值？&lt; input v - model = &quot;message&quot; &gt; // ... computed: &#123; message: &#123; get() &#123; return this.$store.state.message &#125;, set(value) &#123; this.$store.commit(&#x27;updateMessage&#x27;, value) &#125; &#125; &#125; Vuex 页面刷新数据丢失怎么解决？使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中 vue routervue router 全局导航守卫三个参数 route to：即将要进入的目标 路由对象。 from：当前导航正要离开的路由对象。 next：函数，必须调用，不然路由跳转不过去。 next()：进入下一个路由。next(false)：中断当前的导航。next(&#39;/&#39;)或 next(&#123; path: &#39;/&#39; &#125;) : 跳转到其他路由，当前导航被中断，进行新的一个导航。 router.beforeEach：全局前置守卫。 router.beforeResolve：全局解析守卫。 router.afterEach：全局后置钩子。 路由独享守卫const router = new VueRouter(&#123; routes: [ &#123; path: &#x27;/foo&#x27;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125;, &#125;, ],&#125;); 组件内导航守卫 beforeRouteLeave：在失活的组件里调用离开守卫。 beforeRouteUpdate：在重用的组件里调用, 比如包含&lt;router-view /&gt;的组件。 beforeRouteEnter：在进入对应路由的组件创建前调用。 router-link&lt;router-link&gt; 是 Vue-Router 的内置组件，在具有路由功能的应用中作为声明式的导航使用。类似 react 的 Link 标签 &lt;router-link to=&quot;home&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#x27;home&#x27;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;home&#x27; &#125;&quot;&gt;Home&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt;&lt;router-link :to=&quot;&#123; path: &#x27;user&#x27;, query: &#123; userId: 123 &#125;&#125;&quot;&gt;User&lt;/router-link&gt; 注册在 router-link 上事件无效解决方法:使用@click.native。原因：router-link 会阻止 click 事件，.native 指直接监听一个原生事件 在 ie 和 firefox 无效： 使用 a 标签不用 Button 使用 Button 和 Router.navigate 方法 vue-router mode hash history 跳转 this.$router.push() &lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt; 占位 &lt;router-view&gt;&lt;/router-view&gt; hash模式：通过对#号的修改触发 hashchange 事件，实现路由切换 history 模式：通过 pushState 和 replaceState 切换 url，触发 popState 事件，实现路由切换，需要后端配合 Vue router 跳转和 location.href 有什么区别？router 是 hash 改变location.href 是页面跳转，刷新页面 Vue router 除了 router-link 怎么实现跳转?router.go(1);router.push(&#x27;/&#x27;); params 和 query 的区别query 需要 path 引入，params 需要 name 引入this.$route.query.name、this.$route.params.query 注意点：query 刷新不会丢失 query 数据，params 刷新会丢失数据 组件内监听路由的变化只能用在包含&lt;router-view /&gt;的组件内 1. watch: &#123; &#x27;$route&#x27;(to, from) &#123; //这里监听 &#125;,&#125; 2. beforeRouteUpdate(to, from, next) &#123; //这里监听&#125;, 切换新路由的滚动条处理const router = new Router(&#123; mode: &#x27;history&#x27;, base: process.env.BASE_URL, routes, scrollBehavior(to, from, savedPosition) &#123; if (savedPosition) &#123; return savedPosition; &#125; else &#123; return &#123; x: 0, y: 0, &#125;; &#125; &#125;,&#125;); 路由传参获取方式 meta：路由元信息，写在 routes 配置文件中。 &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: load(&#x27;home&#x27;), meta: &#123; title: &#x27;首页&#x27; &#125;,&#125;, this.$route.meta.title query this.$router.push(&#123; path: &#x27;/home&#x27;, query: &#123; userId: 123, &#125;,&#125;); this.$route.query.userId params &#123; path: &#x27;/home/:userId&#x27;, name: &#x27;home&#x27;, component: load(&#x27;home&#x27;),&#125;,// 注意用params传参，只能用命名的路由（用name访问）const userId = &#x27;123&#x27;this.$router.push(&#123; name: &#x27;home&#x27;, params: &#123; userId &#125;&#125;)// this.$route.params 实现动态加载路由(路由懒加载) 使用 Router 的实例方法 addRoutes 来实现动态加载路由，一般用来实现菜单权限。 使用时要注意，静态路由文件中不能有 404 路由，而要通过 addRoutes 一起动态添加进去。 webpack &lt; 2.4 时 &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, components: resolve =&gt; require([&#x27;@/components/home&#x27;], resolve)&#125;webpack &gt; 2.4 时 &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, components: () =&gt; import(&#x27;@/components/home&#x27;)&#125; 非懒加载路由配置 import Vue from &#x27;vue&#x27;;import Router from &#x27;vue-router&#x27;;import Hello from &#x27;@/components/Hello&#x27;;Vue.use(Router);export default new Router(&#123; routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;Hello&#x27;, component: Hello, &#125;, ],&#125;); 路由之间跳转 声明式通过使用内置组件来跳转 or router-link :to=”{name:’index’}”&gt; 编程式 this.$router.push(&#123; path: &#x27;home&#x27;&#125;)this.$router.replace(&#123; path: &#x27;/home&#x27;&#125;)this.$router.push(&#123; name: &#x27;组件名&#x27;)&#125;; $router和$route 的区别$route为当前router跳转对象，里面可以获取name、path、query、params等$router 为 VueRouter 实例，想要导航到不同 URL，则使用 router.push 方法，返回上一个历史$router.to(-1) 打开新窗口const obj = &#123; path: xxx, //路由地址 query: &#123; mid: data.id, //可以带参数 &#125;,&#125;;const &#123; href &#125; = this.$router.resolve(obj);window.open(href, &#x27;_blank&#x27;); 过滤器(filter)&lt;div&gt;&lt;span&gt; &#123;&#123; money | moneyFilter(0.15) &#125;&#125; &lt;/span&gt;美元&lt;/div&gt;&lt;div&gt;&lt;span&gt; &#123;&#123; money | moneyFilter(0.12) &#125;&#125; &lt;/span&gt;英镑&lt;/div&gt; filters: &#123; moneyFilter: function(val, ratio) &#123; return Number(val * ratio).toFixed(2); &#125; &#125; 除了用在插值上还可以用在 v-bind 表达式上。 强制刷新组件 this.$forceUpdate()。 组件上加上 key，然后变化 key 的值。 访问子组件实例或者子元素 ref先用 ref 特性为子组件赋予一个 ID 引用&lt;/ 比如子组件有个 focus 的方法，可以这样调用 this.$refs.myInput.focus()；比如子组件有个value的数据，可以这样使用this.$refs.myInput.value。 子组件访问父组件this.$parent $event.target和$event.currentTarget 有什么区别$event.currentTarget始终指向事件所绑定的元素，而$event.target 指向事件发生时的元素。 事件修饰符和表单修饰符 事件修饰符 .stop：阻止事件传递； .prevent： 阻止默认事件； .capture ：在捕获的过程监听，没有 capture 修饰符时都是默认冒泡过程监听； .self：当前绑定事件的元素才能触发； .once：事件只会触发一次； .passive：默认事件会立即触发，不要把.passive 和.prevent 一起使用，因为.prevent 将不起作用。 .native 加在自定义组件上，保证事件能执行 .left、.right、.middle这三个修饰符是鼠标的左中右键触发的事件 .camel 确保绑定参数被识别为驼峰写法 .sync父子组件传值，子组件想更新这个值，使用此修饰符可简写 表单修饰符.number .lazy .trim &lt;comp :foo.sync=&quot;bar&quot;&gt;&lt;/comp&gt; 相当于 &lt;comp :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/comp&gt;// this.$emit(&#x27;update:foo&#x27;, newValue) 要注意顺序很重要，用@click.prevent.self 会阻止所有的点击，而@click.self.prevent 只会阻止对元素自身的点击。 说说你对 Vue 的表单修饰符.lazy 的理解。input 标签 v-model 用 lazy 修饰之后，并不会立即监听 input 的 value 的改变，会在 input 失去焦点之后，才会监听 input 的 value 的改变。 监听键盘事件使用按键修饰符 &lt;input @keyup.enter=”submit”&gt;按下回车键时候触发 submit 事件。 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right css 样式当前组件有效&lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt; 原理：vue 通过在 DOM 结构以及 css 样式上加上唯一的标记 data-v-xxxxxx ，保证动态属性唯一，达到样式私有化，不污染全局的作用。 编译后： &lt;template&gt; &lt;span data-v-3e5b2a80 class=&quot;textScoped&quot;&gt;scoped测试&lt;/span&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped&gt; .textScoped[data-v-3e5b2a80] &#123; color: red; &#125;&lt;/style&gt; 如何解决样式隔离 深度选择器 &gt;&gt;&gt; /deep/ ::v-deep 有些像 Sass 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。 需要注意即使把深度选择器加在最前面，对于设置了scoped的style标签，仍然无法影响外部组件的样式，这一点和angular有区别 新增一个style标签 &lt;template&gt; &lt;span data-v-3e5b2a80 class=&quot;textScoped&quot;&gt;scoped测试&lt;/span&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped&gt; .textScoped[data-v-3e5b2a80] &#123; color: red; &#125;&lt;/style&gt;&lt;!-- 新增style标签，不加scoped，就不会发生样式隔离 --&gt;&lt;style&gt; .textScoped &#123; color: red; &#125;&lt;/style&gt; 渲染模板保留注释 在组件中将 comments 选项设置为 true &lt;template comments&gt; ... &lt;template&gt; Vue 组件里的定时器要怎么销毁？ 如果页面上有很多定时器，可以在 data 选项中创建一个对象 timer，给每个定时器取个名字一一映射在对象 timer 中，在 beforeDestroy 构造函数中 for(let k in this.timer){clearInterval(k)}； 如果页面只有单个定时器，可以这么做。 const timer = setInterval(() =&gt; &#123;&#125;, 500);this.$once(&#x27;hook:beforeDestroy&#x27;, () =&gt; &#123; clearInterval(timer);&#125;); 定义全局方法 挂载在 Vue 的 prototype 上 利用全局混入 mixin this.$root.$on(&#x27;demo&#x27;, function() &#123; console.log(&#x27;test&#x27;);&#125;)this.$root.$emit(&#x27;demo&#x27;)；this.$root.$off(&#x27;demo&#x27;)；// Mustache的web模板引擎 捕获组件的错误信息 errorCaptured 是组件内部钩子，当捕获一个来自子孙组件的错误时被调用，接收 error、vm、info 三个参数，return false 后可以阻止错误继续向上抛出。 errorHandler 为全局钩子，使用 Vue.config.errorHandler 配置，接收参数与 errorCaptured 一致，2.6 后可捕捉v-on与 promise 链的错误，可用于统一错误处理与错误兜底。 vue SSRvue 是构建客户端应用程序的框架，默认情况下，可以在浏览器中输出 vue 组件，进行生成 dom 和操作 dom，然而，也可以将同一个组件渲染为服务端的 html 字符串，将他们直接发送到客户端，然后将这些静态标记激活为客户端上可以交互的应用程序。 即 ssr 的意思就是 vue 在服务端完成将标签渲染成整个 html 片段的工作，然后将片段直接返回给客户端使用 ssr 优点： 更好的 seo：因为 spa 页面的内容是通过 ajax 获取，而搜索引擎爬取工具并不会等待 ajax 一步完成后再抓取页面内容，所以在 spa 中是抓取不到页面通过 ajax 获取到的内容；而 ssr 是直接由服务器返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取到渲染好的页面 更快的内容到达时间（首屏加载快）：spa 会等待所有 vue 编译后的 js 文件都下载完成后，才开始进行也免得渲染，文件下载需要一定的时间等，所以首屏加载需要时间，而 ssr 直接由服务器渲染好页面返回显示，无需等待 js 文件再去渲染，所以 ssr 有更快的内容到达时间 ssr 缺点： 更多的开发条件限制：例如服务端渲染只支持 beforeCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 spa 不同，服务端渲染应用程序，需要处于 nodejs server 中才能运行 更多的服务器负载 nextTick在下次 dom 更新循环结束之后执行延迟回调，可用于获取更新后的 dom 状态。 新版本中默认是 microtasks, v-on 中会使用 macrotasks // 修改数据vm.msg = &#x27;Hello&#x27;// DOM 还没有更新Vue.nextTick(function() &#123; // DOM 更新了 ... //DOM操作&#125;)// 作为一个 Promise 使用Vue.nextTick() .then(function() &#123; // DOM 更新了 &#125;) Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。 例如，当你设置 vm.someData = &#39;new value&#39;，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环tick中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。 dom 更新为什么是一个异步操作因为它提升了渲染效率。 数据响应(数据劫持)数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep )，其核心是 defineProperty 这个方法，它可以重写属性的 get 与 set 方法，从而完成监听数据的改变。 对需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化 compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:① 在自身实例化时往属性订阅器(dep)里面添加自己② 自身必须有一个 update()方法③ 待属性变动 dep.notice()通知时，能调用自身的 update()方法，并触发 Compile 中绑定的回调 MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。 let data = &#123; a: 1,&#125;;// 数据响应性observe(data);// 初始化观察者new Watcher(data, &#x27;name&#x27;, updateComponent);data.a = 2;// 简单表示用于数据更新后的操作function updateComponent() &#123; vm._update(); // patchs&#125;// 监视对象function observe(obj) &#123; // 遍历对象，使用 get/set 重新定义对象的每个属性值 Object.keys(obj).map(key =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;);&#125;function defineReactive(obj, k, v) &#123; // 递归子属性 if (type(v) == &#x27;object&#x27;) observe(v); // 新建依赖收集器 let dep = new Dep(); // 定义get/set Object.defineProperty(obj, k, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; // 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中 if (Dep.target) &#123; dep.addSub(Dep.target); &#125; return v; &#125;, // 重新设置值时，触发收集器的通知机制 set: function reactiveSetter(nV) &#123; v = nV; dep.nofify(); &#125;, &#125;);&#125;// 依赖收集器class Dep &#123; constructor() &#123; this.subs = []; &#125; addSub(sub) &#123; this.subs.push(sub); &#125; notify() &#123; this.subs.map(sub =&gt; &#123; sub.update(); &#125;); &#125;&#125;Dep.target = null;// 观察者class Watcher &#123; constructor(obj, key, cb) &#123; Dep.target = this; this.cb = cb; this.obj = obj; this.key = key; this.value = obj[key]; Dep.target = null; &#125; addDep(Dep) &#123; Dep.addSub(this); &#125; update() &#123; this.value = this.obj[this.key]; this.cb(this.value); &#125; before() &#123; callHook(&#x27;beforeUpdate&#x27;); &#125;&#125; 虚拟 dom 原理实现 创建 dom 树 树的 diff，同层对比，输出 patchs(listDiff/diffChildren/diffProps) 没有新的节点，返回 新的节点 tagName 与 key 不变， 对比 props，继续递归遍历子树 对比属性(对比新旧属性列表): 旧属性是否存在与新属性列表中 都存在的是否有变化 是否出现旧列表中没有的新属性 tagName 和 key 值变化了，则直接替换成新节点 渲染差异 遍历 patchs， 把需要更改的节点取出来 局部更新 dom patch 函数 oldvnode vnode 如果两个节点不一样，直接用新节点替换老节点； 如果两个节点一样 新老节点一样，直接返回； 老节点有子节点，新节点没有：删除老节点的子节点； 老节点没有子节点，新节点有子节点：新节点的子节点直接 append 到老节点； 都只有文本节点：直接用新节点的文本节点替换老的文本节点； 都有子节点：updateChildren // diff算法的实现function diff(oldTree, newTree) &#123; // 差异收集 let pathchs = &#123;&#125;; dfs(oldTree, newTree, 0, pathchs); return pathchs;&#125;function dfs(oldNode, newNode, index, pathchs) &#123; let curPathchs = []; if (newNode) &#123; // 当新旧节点的 tagName 和 key 值完全一致时 if (oldNode.tagName === newNode.tagName &amp;&amp; oldNode.key === newNode.key) &#123; // 继续比对属性差异 let props = diffProps(oldNode.props, newNode.props); curPathchs.push(&#123; type: &#x27;changeProps&#x27;, props, &#125;); // 递归进入下一层级的比较 diffChildrens(oldNode.children, newNode.children, index, pathchs); &#125; else &#123; // 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比 curPathchs.push(&#123; type: &#x27;replaceNode&#x27;, node: newNode, &#125;); &#125; &#125; // 构建出整颗差异树 if (curPathchs.length) &#123; if (pathchs[index]) &#123; pathchs[index] = pathchs[index].concat(curPathchs); &#125; else &#123; pathchs[index] = curPathchs; &#125; &#125;&#125;// 属性对比实现function diffProps(oldProps, newProps) &#123; let propsPathchs = []; // 遍历新旧属性列表 // 查找删除项 // 查找修改项 // 查找新增项 forin(olaProps, (k, v) =&gt; &#123; if (!newProps.hasOwnProperty(k)) &#123; propsPathchs.push(&#123; type: &#x27;remove&#x27;, prop: k, &#125;); &#125; else &#123; if (v !== newProps[k]) &#123; propsPathchs.push(&#123; type: &#x27;change&#x27;, prop: k, value: newProps[k], &#125;); &#125; &#125; &#125;); forin(newProps, (k, v) =&gt; &#123; if (!oldProps.hasOwnProperty(k)) &#123; propsPathchs.push(&#123; type: &#x27;add&#x27;, prop: k, value: v, &#125;); &#125; &#125;); return propsPathchs;&#125;// 对比子级差异function diffChildrens(oldChild, newChild, index, pathchs) &#123; // 标记子级的删除/新增/移动 let &#123; change, list &#125; = diffList(oldChild, newChild, index, pathchs); if (change.length) &#123; if (pathchs[index]) &#123; pathchs[index] = pathchs[index].concat(change); &#125; else &#123; pathchs[index] = change; &#125; &#125; // 根据 key 获取原本匹配的节点，进一步递归从头开始对比 oldChild.map((item, i) =&gt; &#123; let keyIndex = list.indexOf(item.key); if (keyIndex) &#123; let node = newChild[keyIndex]; // 进一步递归对比 dfs(item, node, index, pathchs); &#125; &#125;);&#125;// 列表对比，主要也是根据 key 值查找匹配项// 对比出新旧列表的新增/删除/移动function diffList(oldList, newList, index, pathchs) &#123; let change = []; let list = []; const newKeys = getKey(newList); oldList.map(v =&gt; &#123; if (newKeys.indexOf(v.key) &gt; -1) &#123; list.push(v.key); &#125; else &#123; list.push(null); &#125; &#125;); // 标记删除 for (let i = list.length - 1; i &gt;= 0; i--) &#123; if (!list[i]) &#123; list.splice(i, 1); change.push(&#123; type: &#x27;remove&#x27;, index: i, &#125;); &#125; &#125; // 标记新增和移动 newList.map((item, i) =&gt; &#123; const key = item.key; const index = list.indexOf(key); if (index === -1 || key == null) &#123; // 新增 change.push(&#123; type: &#x27;add&#x27;, node: item, index: i, &#125;); list.splice(i, 0, key); &#125; else &#123; // 移动 if (index !== i) &#123; change.push(&#123; type: &#x27;move&#x27;, form: index, to: i, &#125;); move(list, index, i); &#125; &#125; &#125;); return &#123; change, list, &#125;;&#125; Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听(遍历每一个属性) let data = &#123; a: 1,&#125;;let reactiveData = new Proxy(data, &#123; get: function (target, name) &#123; // ... &#125;, // ...&#125;); vue 项目的优化 v-if 和 v-show 区分场景使用 computed 和 watch 区分场景使用 v-for 遍历必须加 key，key 最好是 id 值，如果采用 index 当插入数据时索引会发生变化，且避免同时使用 v-if(用计算属性过滤数据) 图片懒加载 路由懒加载 第三方插件按需引入 长列表(虚拟列表) 无限列表加载到底部请求 api，用 v-for 循环数据这样是欠妥当的。随着数据的加载，dom 会越来越多，造成性能的开销大，对客户端造成压力。虚拟列表保证 dom 数量一定，渲染可视区的 dom，通过替换数据来实现长列表的显示。 释放组件资源(beforeDestroy 移除监听) 首屏优化 mixins 抽离公共代码 vue is 的作用简单来说就是扩展 html 标签的限制&lt;ul&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- ul里面嵌套li是固定的写法 --&gt; 当我们使用自定义的组件时会被当作无效内容 ↓ &lt;ul&gt; &lt;my-li&gt;&lt;/my-li&gt;&lt;/ul&gt; 可以通过 is 来扩展 &lt;ul&gt; &lt;li is=&quot;my-li&quot;&gt;&lt;/li&gt;&lt;/ul&gt; 动态切换组件&lt;div :is=&quot;变量名称&quot;&gt;&lt;/div&gt; assets 和 static 的区别 assets 中的文件在运行 npm run build 的时候会打包，简单来说就是会被压缩体积，代码格式化之类的。打包之后也会放到 static 中。 static 中的文件则不会被打包。 建议：将图片等未处理的文件放在 assets 中，打包减少体积。而对于第三方引入的一些资源文件如 iconfont.css 等可以放在 static 中，因为这些文件已经经过处理了。 封装 vue 组件的过程 建立组件模板、架子写写样式，考虑好组件的基本逻辑 准备好组件的数据输入，定好 props 里面的数据、类型 准备好组价的数据输出，定好暴露出来的方法 常用组件库 文本比对:vue-code-diff JSON 代码编辑器:vue-codemirror 国际化:vue-i18n 富文本编辑器:wangEditor 富文本编辑器:tinymce monaco 编辑器:vue-monaco ace 编辑器:vue2-ace-editor 剪切板:vue-clipboard2 操作 cookie:vue-cookies fragment 元素:vue-fragment 代码高亮:vue-highlightjs command 界面:xterm.js command 界面:hterm 处理 yaml:yaml.js yaml:js-yaml vue 的 echarts 封装:v-charts mock:mockjs 判断是否是黑色:is-dark-color XSS 过滤: DOMPurify 常用 UI 库移动端 mint-ui Vant VUX cube-ui pc 端 [element-ui](https://element.eleme.cn/2.13/#/zh-CN/component/installation） Ant Design of Vue iview/viewui/view-design Avue vuetify 常用配置publicPath cli2 config/index.js build: &#123; assetsPublicPath: &#x27;./&#x27;;&#125; cli3 vue.config.js module.exports = &#123; publicPath: &#x27;./&#x27;,&#125;; 部署应用包时的基本 URL。默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 https://www.my-app.com/ 。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 https://www.my-app.com/my-app/ ，则设置 publicPath为/my-app/ proxy: &#123; &quot;/api&quot;: &#123; //如果ajax请求的地址是http://192.168.0.118:9999/api1那么你就可以在ajax中使用/api/api1路径,其请求路径会解析 // http://192.168.0.118:9999/api1，当然你在浏览器上看到的还是http://localhost:8080/api/api1; target: &quot;http://192.168.0.118:9999&quot;, //是否允许跨域，这里是在开发环境会起作用，但在生产环境下，还是由后台去处理，所以不必太在意 changeOrigin: true, pathRewrite: &#123; //把多余的路径置为&#x27;&#x27; &quot;api&quot;: &quot;&quot; &#125; &#125; vue3 createApp vue2.x import Vue from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;new Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;); vue3 新特性 createApp 会产生一个 app 实例，该实例拥有全局的可配置上下文 import &#123; createApp &#125; from &#x27;vue&#x27;;import App from &#x27;./App.vue&#x27;;createApp(App).mount(&#x27;#app&#x27;); globalProperties app.config.globalProperties.foo = &#x27;bar&#x27;;app.component(&#x27;child-component&#x27;, &#123; mounted() &#123; console.log(this.foo); // &#x27;bar&#x27; &#125;,&#125;); 添加可在程序内的任何组件实例中访问的全局属性。当存在键冲突时，组件属性将优先替代掉 Vue2.x 的 Vue.prototype 属性放到原型上的写法 // Vue2.xVue.prototype.$http = () =&gt; &#123;&#125;;// Vue3const app = Vue.createApp(&#123;&#125;);app.config.globalProperties.$http = () =&gt; &#123;&#125;; 更快 重写虚拟 DOM (Virtual DOM Rewrite) 随着虚拟 DOM 重写，我们可以期待更多的 编译时（compile-time）提示来减少 运行时（runtime）开销。重写将包括更有效的代码来创建虚拟节点。 优化插槽生成(Optimized Slots Generation) 在当前的 Vue 版本中，当父组件重新渲染时，其子组件也必须重新渲染。 使用 Vue 3 ，可以单独重新渲染父组件和子组件。 静态树提升(Static Tree Hoisting) 使用静态树提升，这意味着 Vue 3 的编译器将能够检测到什么是静态组件，然后将其提升，从而降低了渲染成本。它将能够跳过未整个树结构打补丁的过程。 静态属性提升（Static Props Hoisting） 此外，我们可以期待静态属性提升，其中 Vue 3 将跳过不会改变节点的打补丁过程。 基于 Proxy 的观察者机制 更小Vue 已经非常小了，在运行时（runtime）压缩后大约 20kb 。 但我们可以期待它会变得更加小，新的核心运行时压缩后大概 10kb 。 使其更具可维护性不仅会使用 TypeScript（允许在编辑器中进行高级的类型检查和有用的错误和警告） ，而且许多软件包将被解耦，使所有内容更加模块化。 更多的原生支持运行时内核也将与平台无关，使得 Vue 可以更容易地与任何平台（例如 Web，iOS 或 Android）一起使用。 更易于开发使用当我们需要在 Vue 中共享两个组件之间的行为时，我们通常使用 Mixins 。然而，Evan 正在尝试使用 Hooks API 来避免来自 Mixins 的一些问题，并且更适合 使用惯用的 Vue 代码。使用 Time Slicing，将 JS 的执行分解为几个部分，如果有用户交互需要处理，这些部分将提供给浏览器。 element-ui 使用中遇到的坑 不支持 v-model 修饰符导致如果使用.trim 当数据拼接了&#39; &#39;后，第一次点击数据中间编辑，光标会跳到末尾 el-table 当注入的 data 经过过滤，所对应的$index 还是原来的，导致删除 splice 对应的 index 不准确 在 disabled 的 button 上使用 Tooltip 失效， el-tooltip 不显示(disable 属性) input-number 输入精度 precision 既要编辑又要显示超出最小值 页面刷新、局部刷新 转载","updated":"2025-08-02T05:46:04.174Z","tags":[{"name":"+ vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"css共通属性","date":"2020-12-21T09:24:15.000Z","path":"2020/12/21/2020-12-21-css-common-attribute/","text":"css 通用属性 initial inherit unset revert initialinitial 关键字用于设置 CSS 属性为它的默认值，可作用于任何 CSS 样式。（IE 不支持该关键字） inherit每一个 CSS 属性都有一个特性就是，这个属性必然是默认继承的 (inherited: Yes) 或者是默认不继承的 (inherited: no) 其中之一，我们可以在 MDN 上通过这个索引查找，判断一个属性的是否继承特性。 可继承属性最后罗列一下默认为 inherited: Yes 的属性： 所有元素可继承：visibility 和 cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction 块状元素可继承：text-indent 和 text-align 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image 表格元素可继承：border-collapse unset名如其意， unset 关键字我们可以简单理解为不设置。其实，它是关键字 initial 和 inherit 的组合。 什么意思呢？也就是当我们给一个 CSS 属性设置了 unset 的话： 如果该属性是默认继承属性，该值等同于 inherit 如果该属性是非继承属性，该值等同于 initial revertrevert 是更为新的一个关键字。直接意译的意思为 – 恢复。 它与关键字 unset 非常类似，在大部分情况下，他们的作用是一模一样的！唯一的区别是： revert：属性应用了该值后，将还原到具有由浏览器或用户创建的自定义样式表（在浏览器侧设置）设置的值 unset: 属性应用了该值后，样式将完全被还原 unset 和 revert 的不同之处&lt;div class=&quot;father&quot;&gt; &lt;b class=&quot;color unset&quot;&gt;设置了 unset，我的 font-weight 会被完全清除&lt;/b&gt; &lt;br /&gt; &lt;b class=&quot;color revert&quot; &gt;设置了 revert，我的 font-weight 将会被还原到浏览器默认样式的 font-weight: bold;&lt;/b &gt;&lt;/div&gt; .unset &#123; font-weight: unset;&#125;.revert &#123; font-weight: revert;&#125; 参考写了这么多年 CSS，initial 和 inherit 以及 unset 和 revert 还傻傻分不清楚？","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"vue生命周期钩子函数","date":"2020-12-20T09:25:12.000Z","path":"2020/12/20/2020-12-20-vue-life-hook-function/","text":"vue的生命周期简单的说生命周期就是事物从产生到消失的一个时间过程。那么vue的生命周期就是从其被创建到销毁的过程，其中包含了开始创建、初始化数据、编译模板、挂载dom（渲染） ，渲染-&gt;更新-&gt;渲染、销毁（卸载）等一系列过程。 那么其中的钩子函数都担负着自己的职责，较为常用的就是created和mounted函数，可以在函数中编写相关的业务逻辑。 钩子函数beforeCreate在实例初始化之后，数据观测和事件、生命周期初始化配置之前被调用。 created实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测，属性和方法的运算，事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount在挂载开始之前被调用：相关的 render 函数首次被调用，此时有了虚拟DOM。 mountedel 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子，渲染为真实DOM。 beforeUpdate在数据更新之前时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。 updated由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。 值得注意的是：该钩子在服务器端渲染期间不被调用。 beforeDestroy实例销毁之前调用。此时，实例仍然是可用的。 destroyedvue 实例销毁后调用。调用后，vue 实例指示的所有东西都会解绑，所有的事件监听器会被卸载移除，所有的子实例也会被销毁。 值得注意的是：该钩子在服务器端渲染期间不被调用。 参考VueJS生命周期","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"https://luckyship.github.io/tags/vue/"}]},{"title":"js事件运行机制event loop","date":"2020-12-20T03:06:21.000Z","path":"2020/12/20/2020-12-20-js-event-loop/","text":"为什么会有event loopjs是一种单线程运行机制，可以预见的是，由于浏览器运行机制的特殊性，js以后将一直会是一种单线程语言，因为有dom操作的时候，如果可以多线程操作，就会让浏览器渲染变得混乱。单线程运行，意味着在同一时间，只能执行一个进程，对于某些会阻塞的服务，像http请求、I/O设备，js会挂起这些任务，让他们进入计划任务里面，等待所有主进程的任务运行完毕后，再执行被挂起的任务。 执行过程任务队列存在多个，同一个任务队列中，按队列顺序被主线程取走；不同的任务队列中，存在着优先级，优先级高的现获取 step1: 主线程读取JS代码，此时为同步环境，形成相应的堆和执行栈；step2: 主线程遇到异步任务，指给对应的异步进程进行处理（WEB API）；step3: 异步进程处理完毕（Ajax返回，DOM事件处理，Timer定时器等），将对应的异步任务推入异步队列中；step4: 主线程查询任务队列，执行microtask(宏任务) queue，将其按序执行，全部执行完毕；step5: 主线程查询任务队列，执行macrotask(微任务) queue，将其按序执行，全部执行完毕；step6: 重复step4，5； 宏任务浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task-&gt;渲染-&gt;task-&gt;…）鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTMl。 setTimeout 的作用是等待给定的时间后为它的回调产生一个新的宏任务*。这就是为什么打印‘setTimeout’在‘script end’之后。因为打印‘script end’是第一个宏任务里面的事情，而‘setTimeout’是另一个独立的任务里面打印的。 setTimeout、setInterval和setImmediateI/O操作、UI渲染、script脚本执行MessageChannel(Vue的nexttick有使用) 微任务微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。微任务包括了 mutation observe 的回调还有接下来的例子 promise 的回调。 promiseMutationObserverprocess.nextTick (Node) 实例事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务。听起来有点绕，我们用一段代码说明： setTimeout(function() &#123; console.log(&#x27;setTimeout&#x27;);&#125;)new Promise(function(resolve) &#123; console.log(&#x27;promise&#x27;);&#125;).then(function() &#123; console.log(&#x27;then&#x27;);&#125;)console.log(&#x27;console&#x27;); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 好啦，整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 ok，第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 注意promise的异步是指 then 和 catch , 运行在 promise 中的代码会被当作同步任务 参考这一次，彻底弄懂 JavaScript 执行机制 js面试——eventLoop 面试题之Event Loop终极篇","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"nginx安装配置","date":"2020-12-16T09:42:39.000Z","path":"2020/12/16/2020-12-16-nginx-config/","text":"安装编译下载nginx安装包wget http://nginx.org/download/nginx-1.8.0.tar.gz 解压tar -zxvf nginx-1.8.0.tar.gz 安装依赖yum install -y pcre pcre-devel openssl openssl-devel gcc gcc gcc-c++ ncurses-devel perl 编译前准备#将这句注释掉 取消Debug编译模式，在179行 vim auto/cc/gcc#CFLAGS=&quot;$CFLAGS -g&quot; 配置$ cd nginx$ ./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_stub_status_module --with-http_ssl_module 编译、安装$ make$ make install 创建软连接ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/ nginx配置简单配置server &#123; listen 3333; server_name xx.xxx.xxx.xxx; location / &#123; proxy_pass xxx.xxx.xx.xxx; &#125; location ^~ /asd &#123; # 正则字符串 proxy_pass xxx.xxx.xx.xxx; &#125;&#125; 目录解析 conf : 存放配置文件html: 网页文件logs：存放日志sbin：shell启动，停止脚本 conf/nginx.config文件组成main # 全局配置events &#123; # nginx工作模式配置 ....&#125;http &#123; # http设置 .... server &#123; # 服务器主机配置 .... location &#123; # 路由配置 .... &#125; upstream name &#123; # 负载均衡配置 .... &#125;&#125; 如上述配置文件所示，主要由6个部分组成： main：用于进行nginx全局信息的配置events：用于nginx工作模式的配置http：用于进行http协议信息的一些配置server：用于进行服务器访问信息的配置location：用于进行访问路由的配置upstream：用于进行负载均衡的配置 server模块srever模块配置是http模块中的一个子模块，用来定义一个虚拟访问主机，也就是一个虚拟服务器的配置信息 server &#123; listen 80; server_name localhost 192.168.1.100; root /var/www/html; index index.php index.html index.html; charset utf-8; access_log logs/access.log; error_log logs/error.log; ......&#125; 核心配置信息如下： server：一个虚拟主机的配置，一个http中可以配置多个serverserver_name：用力啊指定ip地址或者域名，多个配置之间用空格分隔root：表示整个server虚拟主机内的根目录，所有当前主机中web项目的根目录index：用户访问web网站时的全局首页charset：用于设置www/路径中配置的网页的默认编码格式access_log：用于指定该虚拟主机服务器中的访问记录日志存放路径error_log：用于指定该虚拟主机服务器中访问错误日志的存放路径 location模块location 模块是 nginx 配置中出现最多的一个配置，主要用于配置路由访问信息在路由访问信息配置中关联到反向代理、负载均衡等等各项功能，所以 location 模块也是一个非常重要的配置模块基本配置 location / &#123; root /nginx/www; index index.php index.html index.htm;&#125; nginx启动启动# 默认为nginx.conf$ ./nginx# 以其他的config来执行nginx，$ /usr/local/nginx/sbin/nginx -c conf/nginx.conf 刷新配置$ ./nginx -s reload 重启配置$ /usr/local/nginx/sbin/nginx -s reopen 停止$ ./nginx -s stop$ ./nginx -s quit# 杀死nginx的进程$ kill -s 9 参考Nginx安装及配置详细教程","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"nginx","slug":"nginx","permalink":"https://luckyship.github.io/tags/nginx/"}]},{"title":"hls.js播放hls直播源","date":"2020-12-15T05:15:32.000Z","path":"2020/12/15/2020-12-15-hls-js-video-md/","text":"video.js和hls.js的区别和优缺点video.js：优点：功能比较强大，有很多功能封装好了，而且有自己的一套UI，在不同浏览器下显示比较一致缺点：包比较大，实现hls直播的时候其实是内嵌了hls.js的代码，实际上是运用了hls.js，而且由于封装的ui和功能，使其不够纯净，不够灵活，修改ui的时候要用到其他的插件，有点画蛇添足的感觉 hls.js：优点：包比较小，很纯净，UI可以根据自己的业务自扩展，自己封装功能和UI，比较切合自己开发的直播播放器，而且专业直播HLS缺点：没有封装好的UI，功能上也需要自己去实现 hls.js播放hls直播源 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;hls.js&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/hls.js@latest&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;video id=&quot;video&quot; controls&gt;&lt;/video&gt; &lt;script src=&quot;./index.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js var Hls = window.Hlsvar url = &#x27;http://localhost:8765/hls/movie.m3u8&#x27;var video = document.getElementById(&#x27;video&#x27;)if (Hls.isSupported()) &#123; var hls = new Hls() hls.loadSource(url) hls.attachMedia(video) hls.on(Hls.Events.MANIFEST_PARSED, function() &#123; // video.play() &#125;)&#125; else if (video.canPlayType(&#x27;application/vnd.apple.mpegurl&#x27;)) &#123; video.src = url video.addEventListener(&#x27;canplay&#x27;, function() &#123; // video.play() &#125;)&#125;","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"video","slug":"video","permalink":"https://luckyship.github.io/tags/video/"}]},{"title":"js小技巧","date":"2020-12-14T08:22:02.000Z","path":"2020/12/14/2020-12-14-js-knowledge-md/","text":"查找字符串中某个字符出现的次数let str = &quot;21312312312312&quot;console.log(str.split(&quot;1&quot;).length - 1) js正则匹配快速使用匹配项let tel = &quot;13122223333&quot;;let reg = /^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/;tel = tel.replace(reg, &quot;$1****$2&quot;); 最大公约数const gcd = (x, y) =&gt; !y ? x : gcd(y, x % y); 自适应单位vw：1vw等于视口宽度的1%。 vh：1vh等于视口高度的1%。 vmin：选取vw和vh中最小的那个。 vmax：选取vw和vh中最大的那个 CSS百分比是相对于包含它的最近的父元素的高度和宽度 blur和click冲突场景：平时做表单验证的时候一般都有个input框和删除按钮，然后习惯性在失去焦点的时候&gt; 去验证输入的内容是否正确，做验证，发请求等等。 这个时候，那个点击删除按钮往往也就触发了input的失去焦点事件 给失去焦点的时间加上延迟时间，让blur时间在click事件后执行，这个方法固然能够解决问题，但是本人并不是很推荐，因为影响性能，不到最后不用这个方法；event.relatedTarget.id事件属性返回与事件的目标节点相关的节点。（非IE）mousedown事件替代处理click事件 随机数// [0,1) 左闭右开 min-max Math.floor(min + Math.random() * (max - min + 1))// toString() this is object方法 toString() valueOf// 随机颜色item.style.backgroundColor = &#x27;#&#x27; + Math.random().toString(16).slice(2, 8);// &quot;#&quot; + (&quot;00000&quot; + ((Math.random() * 0x1000000) &lt;&lt; 0).toString(16)).slice(-6) 交换两个数的值// 加减运算 缺点也很明显，整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了。var a = 1, b = 2;a += b;b = a - b;a -= b;// 第三个临时变量var a = 1, b = 2;var temp = a;a = b;b = temp;// 位运算let a = 3, b = 4;a ^= b;b ^= a;a ^= b;// es6let a = 1, b = 2;[a, b] = [b, a]; 使用Boolean过滤数组中的假值const compact = arr =&gt; arr.filter(Boolean)compact([0, 1, false, 2, &#x27;&#x27;, 3, &#x27;a&#x27;, &#x27;e&#x27; * 23, NaN, &#x27;s&#x27;, 34]) // // [ 1, 2, 3, &#x27;a&#x27;, &#x27;s&#x27;, 34 ] base64加密let encodedData = window.btoa(&quot;Hello, world&quot;); // 编码let decodedData = window.atob(encodedData); // 解码 如果字符串是unicode字符串，则需要对其转码，通常使用escape和unescape // ucs-2 string to base64 encoded asciifunction utoa(str) &#123; return window.btoa(unescape(encodeURIComponent(str)));&#125;// base64 encoded ascii to ucs-2 stringfunction atou(str) &#123; return decodeURIComponent(escape(window.atob(str)));&#125;// Usage:utoa(&#x27;✓ à la mode&#x27;); // 4pyTIMOgIGxhIG1vZGU=atou(&#x27;4pyTIMOgIGxhIG1vZGU=&#x27;); // &quot;✓ à la mode&quot;utoa(&#x27;I \\u2661 Unicode!&#x27;); // SSDimaEgVW5pY29kZSE=atou(&#x27;SSDimaEgVW5pY29kZSE=&#x27;); // &quot;I ♡ Unicode!&quot; 数组合并的几种方法// 四种方法。var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];arr1 = arr1.concat(arr2);console.log(arr1);var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];Array.prototype.push.apply(arr1, arr2);console.log(arr1);var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];for (var i = 0; i &lt; arr2.length; i++) &#123; arr1.push(arr2[i]);&#125;console.log(arr1);var arr1 = [1, 2, 3];var arr2 = [4, 5, 6];arr1.push(...arr2) 进制转换parseInt 转换为10进制， toString() 作进制转换 // eg. 8-bit hexadecimal =&gt; Binary FFFFFFFF =&gt; 11111111111111111111111111111111const chars = parseInt(char, 16).toString(2).padStart(32, &#x27;0&#x27;); 驼峰转换const regExp = /_(\\w)/g;&#x27;operation_status_graph_file_download&#x27;.replace(regExp, ($0, $1) =&gt; $1.toUpperCase()); 判断2个对象相等利用 JSON 方法转换为字符串 JSON.stringify(obj) == JSON.stringify(obj2); //trueJSON.stringify(obj) == JSON.stringify(obj3); //false","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"npm安装配置","date":"2020-12-01T08:49:16.000Z","path":"2020/12/01/2020-12-01-npm-install-md/","text":"linux 安装tar -zvxf node-v14.tar.gzln -s /node-v14/bin/npm /usr/bin/npmln -s /node-v14/bin/npm /usr/local/bin/npm 查看 npm 配置npm config list 代理设置npm config set proxy=http://127.0.0.1:8087npm config set https-proxy http://127.0.0.1:8087// 需要用户名和密码npm config set proxy http://username:password@server:portnpm confit set https-proxy http://username:password@server:port// 取消代理npm config delete proxynpm config delete https-proxy npm 安装设置npm config set strict-ssl false // SSL错误npm config get registry // 查看当前源npm config set registry https://registry.npmmirror.com/ // 设置淘宝源(已更新)npm config set registry https://registry.npmjs.org/ // 设置官方源npm config set sass_binary_site https://registry.npmmirror.com/mirrors/node-sass/npm config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedrivernpm config set electron_mirror https://registry.npmmirror.com/mirrors/electron/yarn config set chromedriver_cdnurl https://cdn.npm.taobao.org/dist/chromedriveryarn config set electron_mirror https://registry.npmmirror.com/mirrors/electron/yarn config set registry https://registry.npmmirror.com//yarn config set registry https://registry.yarnpkg.comyarn config set sass_binary_site https://registry.npmmirror.com/mirrors/node-sass/yarn config set phantomjs_cdnurl http://cnpmjs.org/downloadsyarn config set sqlite3_binary_host_mirror https://foxgis.oss-cn-shanghai.aliyuncs.com/yarn config set profiler_binary_host_mirror https://registry.npmmirror.com/mirrors/node-inspector/ 淘宝源已更新成：https://registry.npmmirror.com/ npm i 和 npm install 的小区别 用npm i 安装的模块无法用npm uninstall卸载，需要用npm uninstall i命令 npm i 会帮助检测与当前 node 版本最匹配的 npm 包 版本号，并匹配出来相互依赖的 npm 包应该提升的版本号 部分npm包在当前 node 版本下无法使用，必须使用建议版本 安装报错时 intall 肯定会出现npm-debug.log 文件，npm i不一定 npm install 的执行过程 发出npm install命令 查询 node_modules 目录之中是否已经存在指定模块 若存在，不再重新安装 若不存在npm 向 registry 查询模块压缩包的网址下载压缩包，存放在根目录下的.npm 目录里 解压压缩包到当前项目的 node_modules 目录 如果有 package-lock.json，会优先按照 package-lock.json 中的版本来安装包 npm 中的版本指定方式 指定版本：比如 1.2.2 ，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如 ~1.2.2 ，表示安装 1.2.x 的最新版本（不低于 1.2.2），但是不安装 1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如 ˆ1.2.2，表示安装 1.x.x 的最新版本（不低于 1.2.2），但是不安装 2.x.x，也就是说安装时不改变大版本号。需要注意的- 是，如果大版本号为 0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 package.lock 的作用5.0.x 版本：不管 package.json 中依赖是否有更新，npm install 都会根据 package-lock.json 下载。针对这种安装策略，有人提出了这个 issue[6] ，然后就演变成了 5.1.0 版本后的规则。 5.1.0 版本后：当 package.json 中的依赖项有新版本时，npm install 会无视 package-lock.json 去下载新版本的依赖项并且更新 package-lock.json。针对这种安装策略，又有人提出了一个 issue[7] 参考 npm 贡献者 iarna 的评论，得出 5.4.2 版本后的规则。 5.4.2 版本后：如果只有一个 package.json 文件，运行 npm install 会根据它生成一个 package-lock.json 文件，这个文件相当于本次 install 的一个快照，它不仅记录了 package.json 指明的直接依赖的版本，也记录了间接依赖的版本。 如果 package.json 的 semver-range version 和 package-lock.json 中版本兼容(package-lock.json 版本在 package.json 指定的版本范围内)，即使此时 package.json 中有新的版本，执行 npm install 也还是会根据 package-lock.json 下载。 如果手动修改了 package.json 的 version ranges，且和 package-lock.json 中版本不兼容，那么执行 npm install 时 package-lock.json 将会更新到兼容 package.json 的版本。 yarnyarn 的出现主要目标是解决由于语义版本控制而导致的 npm 安装的不确定性问题。虽然可以使用 npm shrinkwrap 来实现可预测的依赖关系树，但它并不是默认选项，而是取决于所有的开发人员知道并且启用这个选项。yarn 采取了不同的做法。每个 yarn 安装都会生成一个类似于npm-shrinkwrap.json 的 yarn.lock 文件，而且它是默认创建的。除了常规信息之外，yarn.lock 文件还包含要安装的内容的校验和，以确保使用的库的版本相同。 yarn 的主要优化yarn 的出现主要做了如下优化： 并行安装：无论 npm 还是 yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 yarn 是同步执行所有任务，提高了性能。 离线模式：如果之前已经安装过一个软件包，用 yarn 再次安装时之间从缓存中获取，就不用像 npm 那样再从网络下载了。 安装版本统一：为了防止拉取到不同的版本，yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。 更好的语义化：yarn 改变了一些 npm 命令的名称，比如 yarn add/remove，比 npm 原本的 install/uninstall 要更清晰。 参考","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://luckyship.github.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://luckyship.github.io/tags/npm/"}]},{"title":"jquery监听ajax事件","date":"2020-12-01T08:35:05.000Z","path":"2020/12/01/2020-12-01-jquery-subscribe-ajax-event-md/","text":"jQuery.ajaxComplete()回调函数handler有3个参数：其一是表示当前事件的 Event 对象，其二是发送当前AJAX请求的 jqXHR 对象，其三是包含为本次 AJAX 请求设置的所有参数选项(包括无需指定的默认参数选项)的 Object 对象。 从jQuery 1.8开始，ajaxComplete事件的处理函数必须绑定到document对象上才能生效。 如果在jQuery.ajax()或jQuery.ajaxSetup()中将选项参数global设为false，可以禁止该AJAX请求触发全局的AJAX事件。 因此，不论当前jQuery为何版本，如果不是特殊需求，我们都应该将ajaxComplete事件的处理函数绑定到document对象上。 $(document).ajaxComplete(function(event, jqXHR, options) &#123; alert(&quot;处理函数1：请求的url为&quot; + options.url);&#125;);$(document).ajaxComplete(function(event, jqXHR, options) &#123; alert(&quot;处理函数2：请求方式为&quot; + options.type);&#125;);// 执行该AJAX请求，会弹出2次对话框// 因为document对象上绑定了2个事件处理函数$.ajax(&#123; url: &quot;index.html&quot; // , global: false // 可以禁止触发全局的Ajax事件&#125;);// 执行该AJAX请求，会弹出3次对话框// 因为$.ajax()自己通过complete选项绑定了一个局部的ajaxComplete事件处理函数，它也在document对象上，会执行一次// 我们还通过ajaxComplete()额外绑定了两个事件处理函数，会再弹出2次$.ajax(&#123; url: &quot;myurl&quot;, complete: function(jqXHR, textStatus) &#123; // jqXHR 是经过jQuery封装的XMLHttpRequest对象 // textStatus 可能为：null、&#x27;success&#x27;、 &#x27;notmodified&#x27;、 &#x27;error&#x27;、 &#x27;timeout&#x27;、 &#x27;abort&#x27;或&#x27;parsererror&#x27;等 alert(&quot;ajax()&quot;); &#125; // , global: false // 可以禁止触发全局的Ajax事件&#125;); 参考原创 jQuery.ajaxComplete() 函数详解 jQuery.ajaxComplete() 函数详解","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://luckyship.github.io/tags/jquery/"}]},{"title":"使用es6-set数组去重","date":"2020-12-01T01:48:04.000Z","path":"2020/12/01/2020-12-01-es6-uniq/","text":"使用 set 去重Array.from 是 es6 用法，将类数组转换为数组 let a = [1, 1, 2, 3, 3, 4, 4];//undefinedArray.from(new Set(a));// [1, 2, 3, 4] 一般去重方法兼容性好，可不用支持 es6 语法 function unique(arr) &#123; var newArr = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (newArr.indexOf(arr[i]) == -1) &#123; newArr.push(arr[i]); &#125; &#125; return newArr;&#125;var arr = [1, 2, 2, 3, 4, 4, 5, 1, 3];var newArr = unique(arr);console.log(newArr); 使用 filter 方法 function unique(arr) &#123; return arr.filter((item, index, array) =&gt; &#123; return array.indexOf(item) === index; &#125;);&#125;var arr = [1, 2, 2, 3, 4, 4, 5, 1, 3];var newArr = unique(arr);console.log(newArr);","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://luckyship.github.io/tags/es6/"}]},{"title":"js浮点数计算","date":"2020-12-01T01:48:04.000Z","path":"2020/12/01/2020-12-01-js-float-calculate/","text":"因为计算机的特性，浮点数计算很多时候不会等于我们想要的值 &gt; 0.1 + 0.20.30000000000000004 &gt; 0.7 / 100.06999999999999999 原因JavaScript 内部只有一种数字类型 Number ，也就是说， JavaScript 语言的底层根本没有整数，所有数字都是以IEEE-754标准格式64位浮点数形式储存，1与1.0是相同的。因为有些小数以二进制表示位数是无穷的。 JavaScript 会把超出 53 位之后的二进制舍弃，所以涉及小数的比较和运算要特别小心。 浮点数的运算过程首先，十进制的0.1和0.2会转换成二进制的，但是由于浮点数用二进制表示是无穷的 0.1——&gt;0.0001 1001 1001 1001 ...(1001循环)0.2——&gt;0.0011 0011 0011 0011 ...(0011循环) IEEE754 标准的 64 位双精度浮点数的小数部分最多支持 53 位二进制，多余的二进制数字被截断，所以两者相加之后的二进制之和是 0.0100110011001100110011001100110011001100110011001101 将截断之后的二进制数字再转换为十进制，就成了 0.30000000000000004 ，所以在计算时产生了误差 解决方法转换为整数运算在知道小数的位数情况下，我们将它转为整数，结果在除以对应的倍数 &gt; 0.1 + 0.20.30000000000000004 &gt; (0.1 * 10 + 0.2 * 10) / 100.3 位数舍入法小数部分最多支持53位， 对应的小数位支持17位，我们取15位，然后在用 Number 转换 &gt; Number((0.1 + 0.2).toPrecision(15))0.3 适用于不知道位数的情况下，但是小数位不会超过15位 小数转整数运算适用所有情况：把小数部分和整数部分都转换为整数运算，在通过字符串拼接回来 function add(a, b) &#123; var c, d, e; try &#123; c = a.toString().split(&quot;.&quot;)[1].length; &#125; catch (f) &#123; c = 0; &#125; try &#123; d = b.toString().split(&quot;.&quot;)[1].length; &#125; catch (f) &#123; d = 0; &#125; return e = Math.pow(10, Math.max(c, d)), (mul(a, e) + mul(b, e)) / e;&#125;function sub(a, b) &#123; var c, d, e; try &#123; c = a.toString().split(&quot;.&quot;)[1].length; &#125; catch (f) &#123; c = 0; &#125; try &#123; d = b.toString().split(&quot;.&quot;)[1].length; &#125; catch (f) &#123; d = 0; &#125; return e = Math.pow(10, Math.max(c, d)), (mul(a, e) - mul(b, e)) / e;&#125;function mul(a, b) &#123; var c = 0, d = a.toString(), e = b.toString(); try &#123; c += d.split(&quot;.&quot;)[1].length; &#125; catch (f) &#123;&#125; try &#123; c += e.split(&quot;.&quot;)[1].length; &#125; catch (f) &#123;&#125; return Number(d.replace(&quot;.&quot;, &quot;&quot;)) * Number(e.replace(&quot;.&quot;, &quot;&quot;)) / Math.pow(10, c);&#125;function div(a, b) &#123; var c, d, e = 0, f = 0; try &#123; e = a.toString().split(&quot;.&quot;)[1].length; &#125; catch (g) &#123;&#125; try &#123; f = b.toString().split(&quot;.&quot;)[1].length; &#125; catch (g) &#123;&#125; return c = Number(a.toString().replace(&quot;.&quot;, &quot;&quot;)), d = Number(b.toString().replace(&quot;.&quot;, &quot;&quot;)), mul(c / d, Math.pow(10, f - e));&#125; 参考Javascript优化后的加减乘除（解决js浮点数计算bug） 解决JS浮点数运算结果不精确的Bug","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"dataTable介绍","date":"2020-11-21T01:48:04.000Z","path":"2020/11/21/2020-11-21-dataTable/","text":"使用npm 引入dataTable引入datatables.net-dt首先导入 npm 包 npm install datatables.net-dt 在需要引用的地方，导入 dataTable import $ from ‘jquery’require(&#x27;datatables.net&#x27;)require(&#x27;datatables.net-dt/css/jquery.dataTables.css&#x27;) 参考dataTable 获取api的三种方法 $(selector). DataTable();$(selector).dataTable().api();$.fn.dataTable. Api( selector ); 第三种方法比较特殊，我使用过一次，使用场景为：无法引入 jquery ， dataTable 不能初始化，这主要是因为使用 npm 进行模块加载的时候，主代码已经有 jquery ，再引入 jquery 回覆盖之前 jquery 的插件，所以使用 window.dt = require(&#x27;datatables.net&#x27;);// 在使用到的模块里引入dtwindow.$.fn.dataTable = window.dt; 这里使用 $(selector). DataTable(); 、 $(selector).dataTable().api(); 都无法返回Api; 所以使用如下方式 $(selector).dataTable();$.fn.dataTable.Api(selector); 参考dataTable api 搜索匹配正则的问题DataTable 中的 search 搜索框功能非常强大，可以匹配表格中的任意数据。不仅如此 DataTable 还提供了 regex 选项可以使用正则表达式。 $(&#x27;#example&#x27;).dataTable(&#123; &quot;search&quot;: &#123; &quot;regex&quot;: true &#125;&#125;); 但是，如果你有更多的要求，比如：对一行的多个列进行匹配，那么你就需要了解dataTable的匹配规则DataTable搜索结果以行显示，那么每一行是怎么匹配正则的？ 每一行代表的字符串是以2个空格将没一列连成一个字符串 例如：|example1|example2|example3||:-:|:-:|:-:||a|c|d||e|f|g||h|i|j| 如果我们在输入框中输入: ^a c d 即可匹配到第一行 如果想要更多的验证DataTable的正则匹配规则，可以点击连接验证 多列使用搜索很多人想到用 .columns() ，但是 .columns() 表示的是与 &amp;&amp; , 例如 .columns([1, 2]).search(&#39;&#39;) 表示的是第2，3列都有匹配的项 有一种替代方法，如下： $(&#x27;table&#x27;).dataTable().api().column(1).search(&#x27;李&#x27;).column(0).search(&#x27;1&#x27;).draw(); 添加外部html可以在 dom 选项中添加类名为 toolbar 的 div ，再往其中加入代码即可 $(document).ready(function() &#123; $(&#x27;#example&#x27;).DataTable(&#123; &quot;dom&quot;: &#x27;&lt;&quot;toolbar&quot;&gt;frtip&#x27; &#125;); $(&quot;div.toolbar&quot;).html(&#x27;&lt;b&gt;Custom tool bar! Text/images etc.&lt;/b&gt;&#x27;);&#125;); 参考dom_toolbar","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"dataTable","slug":"dataTable","permalink":"https://luckyship.github.io/tags/dataTable/"},{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"daterangepicker默认显示为空","date":"2020-11-02T08:14:11.000Z","path":"2020/11/02/2020-11-02-daterangepicker-default-null/","text":"daterangepicker 默认显示为空目前官网提供属性 autoUpdateInput: false ，输入框就可以显示为空，但是再次选择日期的时候不会发生变化我们对组件进行一些修改，让它可以显示为空值。 $(&#x27;.date&#x27;).daterangepicker(&#123; singleDatePicker: true, autoUpdateInput: false, showDropdowns: true, locale: &#123; format: &quot;YYYY-MM-DD&quot;, &#125;,&#125;, function(start, end, label) &#123; $(el).val(start.format(&#x27;YYYY-MM-DD&#x27;));&#125;); 利用回调函数，为输入框赋值我们选择的日期","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://luckyship.github.io/tags/es6/"}]},{"title":"js循环","date":"2020-10-23T08:14:11.000Z","path":"2020/10/23/2021-07-10-js-loop/","text":"forEachforEach 无法使用 break 或者 continue 跳出循环 优点：使用回调函数，形成特定的作用域，不会污染外部变量 forEach 是不能阻塞的，默认是请求并行发起来看一个例子 const list = [1, 2, 3];const square = num =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(num * num); &#125;, 1000); &#125;);&#125;;function test() &#123; list.forEach(async x =&gt; &#123; const res = await square(x); console.log(res); &#125;);&#125;test(); 上面函数执行，虽然加了异步函数，但是执行结果是同时输出 1、4、9 如果想要能够异步执行，需要使用 for 循环 async function test() &#123; for (let i = 0; i &lt; list.length; i++) &#123; let x = list[i]; const res = await square(x); console.log(res); &#125;&#125; 或者 for..of async function test() &#123; for (let x of list) &#123; const res = await square(x); console.log(res); &#125;&#125; for…ofes6 新增，用于迭代器，无法用于对象 var arr = [1, 2, 3, 4, 5];for (var i in arr) &#123; console.log(i);&#125; for…in一般为对象使用，不过 for...in 会把对象原型链的属性也遍历出来 Object.prototype.bar = 10; // 修改Object.prototypevar obj = &#123; name: &#x27;wjy&#x27;, age: 26, sex: &#x27;female&#x27;,&#125;; //定义一个object对象var keys = []; //定义一个数组用来接受keyvar values = []; //定义一个数组用来接受valuefor (var key in obj) &#123; console.log(key + &#x27;: &#x27; + obj[key]); //取得value&#125; 如果不想遍历原型链的对象，可以使用 Object.hasOwnProperty() 来判断是否为自身属性 对象遍历我们一般使用， Object.keys 和 Object.values() 不用于数组的原因 for..in的 key 值是字符串，而数组的 index 是数字，会造成误解 如果数组中或原型链中有可枚举的属性，遍历结果中会出现 数组是有序的，而对象的key是无序的 for 循环最基础的循环 for循环和forEach的性能区别在性能对比方面我们加入一个 map 迭代器，它与 filter 一样都是生成新数组。我们对比 for forEach map 的性能在浏览器环境中都是什么样的： 性能比较：for &gt; forEach &gt; map 在 chrome 62 和 Node.js v9.1.0 环境下：for 循环比 forEach 快 1 倍，forEach 比 map 快 20%左右。 原因分析for：for 循环没有额外的函数调用栈和上下文，所以它的实现最为简单。forEach：对于 forEach 来说，它的函数签名中包含了参数和上下文，所以性能会低于 for 循环。map：map 最慢的原因是因为 map 会返回一个新的数组，数组的创建和赋值会导致分配内存空间，因此会带来较大的性能开销。 如果将map嵌套在一个循环中，便会带来更多不必要的内存消耗。当大家使用迭代器遍历一个数组时，如果不需要返回一个新数组却使用 map 是违背设计初衷的。在我前端合作开发时见过很多人只是为了遍历数组而用 map 的：","updated":"2025-08-02T05:46:04.176Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://luckyship.github.io/tags/es6/"}]},{"title":"es6异步的写法","date":"2020-10-22T07:21:00.000Z","path":"2020/10/22/2020-10-22-es6-async-methods/","text":"Promise新界 promise 对象，在其中写入需要异步的代码 var p1 = new Promise(function(resolve, reject) &#123; //做一些异步操作 setTimeout(function() &#123; console.log(&#x27;执行完成Promise&#x27;); resolve(&#x27;要返回的数据可以任何数据例如接口返回数据&#x27;); &#125;, 2000);&#125;);p1.then(function(data) &#123; console.log(data)&#125;);执行完成Promise要返回的数据可以任何数据例如接口返回数据 注意new Promise((resolve, reject) =&gt; &#123; resolve(1); console.log(2);&#125;).then(r =&gt; &#123; console.log(r);&#125;);// 2// 1 上面代码中，调用 resolve(1) 以后，后面的 console.log(2) 还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。一般来说，调用 resolve 或 reject 以后， Promise 的使命就完成了，后继操作应该放到 then 方法里面，而不应该直接写在 resolve 或 reject 的后面。所以，最好在它们前面加上 return 语句，这样就不会有意外。 new Promise((resolve, reject) =&gt; &#123; return resolve(1); // 后面的语句不会执行 console.log(2);&#125;) Generator函数Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同 function* helloWorldGenerator() &#123; yield &#x27;hello&#x27;; yield &#x27;world&#x27;; return &#x27;ending&#x27;;&#125; 上面代码定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world），即该函数有三个状态：hello，world 和 return 语句（结束执行）。 然后，Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。 hw.next()// &#123; value: &#x27;hello&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;world&#x27;, done: false &#125;hw.next()// &#123; value: &#x27;ending&#x27;, done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 上面代码一共调用了四次next方法。 第一次调用， Generator 函数开始执行，直到遇到第一个 yield 表达式为止。 next 方法返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello ， done 属性的值 false ，表示遍历还没有结束。 第二次调用， Generator 函数从上次 yield 表达式停下的地方，一直执行到下一个 yield 表达式。 next 方法返回的对象的 value 属性就是当前 yield 表达式的值 world ， done 属性的值 false ，表示遍历还没有结束。 第三次调用， Generator 函数从上次 yield 表达式停下的地方，一直执行到 return 语句（如果没有 return 语句，就执行到函数结束）。 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值（如果没有 return 语句，则 value 属性的值为 undefined ）， done 属性的值 true ，表示遍历已经结束。 第四次调用，此时 Generator 函数已经运行完毕， next 方法返回对象的 value 属性为 undefined ， done 属性为 true 。以后再调用 next 方法，返回的都是这个值。 总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。 value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值； done 属性是一个布尔值，表示是否遍历结束。 async函数async 函数是什么？一句话，它就是 Generator 函数的语法糖。 const fs = require(&#x27;fs&#x27;);const readFile = function(fileName) &#123; return new Promise(function(resolve, reject) &#123; fs.readFile(fileName, function(error, data) &#123; if (error) return reject(error); resolve(data); &#125;); &#125;);&#125;;const gen = function*() &#123; const f1 = yield readFile(&#x27;/etc/fstab&#x27;); const f2 = yield readFile(&#x27;/etc/shells&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; 上面代码的函数 gen 可以写成 async 函数，就是下面这样。 const asyncReadFile = async function() &#123; const f1 = await readFile(&#x27;/etc/fstab&#x27;); const f2 = await readFile(&#x27;/etc/shells&#x27;); console.log(f1.toString()); console.log(f2.toString());&#125;; 一比较就会发现， async 函数就是将 Generator 函数的星号 （*） 替换成 async ，将 yield 替换成 await ，仅此而已。async 函数对 Generator 函数的改进，体现在以下四点。 （1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 asyncReadFile(); 上面的代码调用了 asyncReadFile 函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用 next 方法，或者用 co 模块，才能真正执行，得到最后结果。 （2）更好的语义。async 和 await ，比起星号和 yield ，语义更清楚了。 async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。co 模块约定， yield 命令后面只能是 Thunk 函数或 Promise 对象，而 async 函数的 await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。 （4）返回值是 Promise。async 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 then 方法指定下一步的操作。 进一步说， async 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 await 命令就是内部then命令的语法糖。 下面是一个例子。 async function getStockPriceByName(name) &#123; const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;&#125;getStockPriceByName(&#x27;goog&#x27;).then(function(result) &#123; console.log(result);&#125;); Promise对象的状态变化async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。 下面是一个例子。 async function getTitle(url) &#123; let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&#x27;https://tc39.github.io/ecma262/&#x27;).then(console.log)// &quot;ECMAScript 2017 Language Specification&quot; 上面代码中，函数 getTitle 内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行 then 方法里面的 console.log 。 await 命令正常情况下， await 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。 async function f() &#123; // 等同于 // return 123; return await 123;&#125;f().then(v =&gt; console.log(v))// 123 上面代码中， await 命令的参数是数值 123 ，这时等同于 return 123 。 另一种情况是， await 命令后面是一个 thenable 对象（即定义了 then 方法的对象），那么 await 会将其等同于 Promise 对象。 class Sleep &#123; constructor(timeout) &#123; this.timeout = timeout; &#125; then(resolve, reject) &#123; const startTime = Date.now(); setTimeout( () =&gt; resolve(Date.now() - startTime), this.timeout ); &#125;&#125;(async () =&gt; &#123; const sleepTime = await new Sleep(1000); console.log(sleepTime);&#125;)();// 1000 上面代码中， await 命令后面是一个 Sleep 对象的实例。这个实例不是 Promise 对象，但是因为定义了 then 方法， await 会将其视为 Promise 处理。 参考Promise 对象Generator 函数的语法async函数","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://luckyship.github.io/tags/es6/"}]},{"title":"各种js、jquery浏览器高度、宽度","date":"2020-10-21T09:29:48.000Z","path":"2020/10/21/2020-10-21-browser-window-size/","text":"JavascriptIE中：document.body.clientWidth == &gt; BODY对象宽度document.body.clientHeight == &gt; BODY对象高度document.documentElement.clientWidth == &gt; 可见区域宽度document.documentElement.clientHeight == &gt; 可见区域高度FireFox中：document.body.clientWidth == &gt; BODY对象宽度document.body.clientHeight == &gt; BODY对象高度document.documentElement.clientWidth == &gt; 可见区域宽度document.documentElement.clientHeight == &gt; 可见区域高度Opera中：document.body.clientWidth == &gt; 可见区域宽度document.body.clientHeight == &gt; 可见区域高度document.documentElement.clientWidth == &gt; 页面对象宽度（ 即BODY对象宽度加上Margin宽）document.documentElement.clientHeight == &gt; 页面对象高度（ 即BODY对象高度加上Margin高）alert(document.body.clientWidth); //网页可见区域宽(body)alert(document.body.clientHeight); //网页可见区域高(body)alert(document.body.offsetWidth); //网页可见区域宽(body)，包括border、margin等alert(document.body.offsetHeight); //网页可见区域宽(body)，包括border、margin等alert(document.body.scrollWidth); //网页正文全文宽，包括有滚动条时的未见区域alert(document.body.scrollHeight); //网页正文全文高，包括有滚动条时的未见区域alert(document.body.scrollTop); //网页被卷去的Top(滚动条)alert(document.body.scrollLeft); //网页被卷去的Left(滚动条)alert(window.screenTop); //浏览器距离Topalert(window.screenLeft); //浏览器距离Leftalert(window.screen.height); //屏幕分辨率的高alert(window.screen.width); //屏幕分辨率的宽alert(window.screen.availHeight); //屏幕可用工作区的高alert(window.screen.availWidth); //屏幕可用工作区的宽 scrollTop 是一个非整数，而 scrollHeight 和 clientHeight 是四舍五入的，因此确定滚动区域是否滚动到底的唯一方法是查看滚动量是否足够接近某个阈值 (在本例中为 1)： Math.abs(element.scrollHeight - element.clientHeight - element.scrollTop) &lt; 1 参考 jqueryalert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height()); //浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true)); //浏览器当前窗口文档body的总高度 包括border padding marginalert($(window).width()); //浏览器当前窗口可视区域宽度alert($(document).width()); //浏览器当前窗口文档对象宽度alert($(document.body).width()); //浏览器当前窗口文档body的宽度alert($(document.body).outerWidth(true)); //浏览器当前窗口文档body的总宽度 包括border padding margin","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://luckyship.github.io/tags/jquery/"}]},{"title":"hexo新建页面","date":"2020-10-11T13:06:47.000Z","path":"2020/10/11/2020-10-11-hexo-new-page/","text":"使用 hexo new page 命令 $ hexo new page comment 在 source 文件夹下就有了一个新的文件夹 $ ls sourcecomment _post 当使用 hexo g 时，会在 public 文件夹下生成新的文件夹 comment ，这样我们在网页上就可以通过 url + comment/ 的方式访问该页面","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"hexo","slug":"hexo","permalink":"https://luckyship.github.io/tags/hexo/"}]},{"title":"gitee pages 自动更新","date":"2020-10-10T16:00:00.000Z","path":"2020/10/11/2020-10-11-gitee-update-pages-auto/","text":"环境准备 node &gt;= 14.13.1 npm &gt;= 6.14.8安装 puppeteer npm install puppeteer --save puppeteer 是谷歌提供的一个无界面的浏览器程序，相当于用代码实现浏览器的功能 自动化脚本新建文件updatePages.js需要填入 gitee 账号、密码和 pages 的地址 // npm &gt;= 10.18const puppeteer = require(&quot;puppeteer&quot;);const username = &quot;&quot;; // gitee用户名const password = &quot;&quot;; // gitee密码const giteePageUrl = &quot;https://gitee.com/luckyship/luckyship/pages&quot;; // gitee page地址async function giteeUpdate(username, giteePageUrl, passwd) &#123; const browser = await puppeteer.launch(&#123; // 此处可以使用 false 有头模式进行调试, 调试完注释即可 headless: false, &#125;); const page = await browser.newPage(); await page.goto(&quot;https://gitee.com/login&quot;); // 1. 选中账号控件 let accountElements = await page.$x(&#x27;//*[@id=&quot;user_login&quot;]&#x27;); // 此处使用 xpath 寻找控件，下同 // 2. 填入账号 await accountElements[0].type(username); // 3. 选中密码控件 let pwdElements = await page.$x(&#x27;//*[@id=&quot;user_password&quot;]&#x27;); // 4. 填入密码 await pwdElements[0].type(passwd); // 5. 点击登录 let loginButtons = await page.$x( // &#x27;//*[@id=&quot;new_user&quot;]/div[2]/div/div/div[4]/input&#x27; &#x27;//*[@id=&quot;new_user&quot;]/div/div/div/div[4]/input&#x27; ); console.log(loginButtons); await loginButtons[0].click(); // 6. 等待登录成功 await page.waitFor(1000); await page.goto(giteePageUrl); // 比如： https://gitee.com/yang0033/hexo-blog/pages // 7.1. 监听步骤 7 中触发的确认弹框，并点击确认 await page.on(&quot;dialog&quot;, async (dialog) =&gt; &#123; console.log(&quot;确认更新&quot;); dialog.accept(); &#125;); // 7. 点击更新按钮，并弹出确认弹窗 let updateButtons = await page.$x(&#x27;//*[@id=&quot;pages-branch&quot;]/div[6]&#x27;); await updateButtons[0].click(); // 8. 轮询并确认是否更新完毕 while (true) &#123; await page.waitFor(2000); try &#123; // 8.1 获取更新状态标签 deploying = await page.$x(&#x27;//*[@id=&quot;pages_deploying&quot;]&#x27;); if (deploying.length &gt; 0) &#123; console.log(&quot;更新中...&quot;); &#125; else &#123; console.log(&quot;更新完毕&quot;); break; &#125; &#125; catch (error) &#123; break; &#125; &#125; await page.waitFor(500); // 10.更新完毕，关闭浏览器 browser.close();&#125;giteeUpdate(username, giteePageUrl, password); $ node updatePages.js","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"hexo","slug":"hexo","permalink":"https://luckyship.github.io/tags/hexo/"}]},{"title":"使用hexo在github上搭建博客","date":"2020-10-06T16:00:00.000Z","path":"2020/10/07/2020-10-07-deploy-hexo/","text":"环境准备 npm &gt;= 6.14.8 hexo &gt;= 4.2.0 hexo主题yilia 部署应用创建目录 hexo ，进入目录，执行命令 $ hexo init$ ls_config.yml node_modules/ package-lock.json scaffolds/ themes/db.json package.json public/ source/ 修改 _config.yml ，将其中的 theme 字段修改为 lucky $ cat _config.ymltheme: lucky 进入 themes 目录，克隆hexo主题仓库（注意名字为theme字段的修改值） git clone https://github.com/luckyship/myblog.git ./lucky 退回hexo主目录，执行 hexo generatehexo sever 即可看到web服务已经启动，端口默认为4000，访问 localhost:4000 即可 开发应用修改主题代码例如 css, js, html 等，需要重新打包主题代码 $ npm run dev 再清除hexo缓存，重新打包到hexo上 $ hexo c // 清除所有缓存$ hexo g // 打包格式化md文件$ hexo s // 本地环境 添加md文件添加的文件可以实时显现到web上 $ hexo s -g --debug 上传至github安装包 npm install hexo-deployer-git --save 在 _config.yml 中添加 deploy: type: git repo: git@github.com:luckyship/luckyship.github.io.git branch: main message: &#x27;collect new post&#x27; 执行命令， deploy 上传的每次 generate 过后的文件，所以上传之前需要 generate $ hexo g$ hexo deploy 修改代码高亮配置Highlight.js# _config.ymlhighlight: enable: true auto_detect: false line_number: true tab_replace: &#x27; &#x27; wrap: true hljs: falseprismjs: enable: false highlight.js 默认开启，用作 Hexo 的服务端高亮组件。如果你需要在浏览器端运行 highlight.js，请把它关闭。 「服务端高亮」指语法高亮在 hexo generate 或 hexo server 时完成。 auto_detectauto_detect 是 highlight.js 的特性，能够自动检测代码块的语言。 提示：如果你想使用「子语言高亮」功能（例如在高亮 HTML 时同时高亮内部嵌入的 JavaScript 代码），请开启 auto_detect，并且在文章中插入代码块时不要标注语言。警告！auto_detect 十分耗费资源。 如果你不需要使用「子语言高亮」功能，或者不介意在书写代码块时标记语言，请不要启用此功能。 line_numberhighlight.js 不支持行号显示。Hexo 通过用 &lt;figure&gt; 和 &lt;table&gt; 包裹其代码块为其添加了行号显示支持: &lt;figure class=&quot;highlight yaml&quot;&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td class=&quot;gutter&quot;&gt; &lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;td class=&quot;code&quot;&gt; &lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;hello:&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;hexo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/figure&gt; 这不是 highlight.js 的行为，因此需要为 &lt;figure&gt; 和 &lt;table&gt; 添加自定义 CSS 代码。部分主题对此提供内建支持。你大概也注意到了，所有代码块的 class 都没有 hljs- 前缀 tab_replace用代码内的 tab (\\t) 替换为给定值，默认值是两个空格。 wrap为了支持行号显示，Hexo 将输出包裹在了 &lt;figure&gt; 和 &lt;table&gt; 内部。如果要保持 highlight.js 原来的行为，你需要将 line_number 和 wrap 全部关闭。 &lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# _config.yml&lt;/span&gt;&lt;span class=&quot;attr&quot;&gt;hexo:&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;hexo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 警告！因为 line_number 功能依赖 wrap，你无法在配置中关闭 wrap 而又开启 line_number。如果你将 line_number 设置为 true 的话，wrap 将被自动开启。 hljs当 hljs 设置为 true 时，所有代码块的 HTML 输出均会给 class 添加 hljs- 前缀（无论 wrap 是否开启）： &lt;pre&gt;&lt;code class=&quot;yaml hljs&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# _config.yml&lt;/span&gt;&lt;span class=&quot;hljs-attr&quot;&gt;hexo:&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;hexo&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt; 去 highlight 官网去使用官方的主题，复制其中的css到自己的代码中hightlight 提示：当 line_number 和 wrap 为 false，hljs 为 true 的时候，你可以在站点上直接应用 highlight.js 的主题_blank。 PrismJS# _config.ymlhighlight: enable: falseprismjs: enable: true preprocess: true line_number: true tab_replace: &#x27;&#x27; PrismJS 默认禁用。启用 PrimeJS 前应设置 highlight.enable 为 false。 preprocessHexo 内建的 PrismJS 支持浏览器端高亮（preprocess 设置为 false）和服务器端高亮（preprocess 设置为 true）两种方式。 使用服务器端高亮时（preprocess 设置为 true），只需要在站点引入 Prismjs 的主题（CSS 样式表）即可；而使用浏览器端高亮时（preprocess 设置为 false），需要将 JavaScript 文件也引入。 PrismJS 主要是面向浏览器的。因此，在服务器端高亮模式下只有部分插件可用： 行号显示：需要引入prism-line-numbers.css，无需引入prism-line-numbers.js。Hexo 将生成其所需的 HTML 代码片段。 语言显示：当代码块有标注语言时，Hexo 总会添加 data-language 属性。 Hexo 也支持其它不需要特殊 HTML 代码格式的 PrismJS 插件，不过你需要引入它们的 JavaScript 文件 preprocess 设置为 false 时所有 primejs 插件均可用，只需额外注意以下几点： 行号显示：当 preprocess 设置为 false 时，Hexo 不会生成插件所需的 HTML 代码格式。prism-line-numbers.css 和 prism-line-numbers.js均需被引入。 语言显示：当代码块有标注语言时，Hexo 总会添加 data-language 属性。 高亮特定行: Hexo 的代码块标签插件和反引号代码块标签插件都支持高亮特定行的语法（即 mark 选项）。当 mark 项被设置时，Hexo 将生成其所需的 HTML 代码格式。 line_number当 preprocess 与 line_number 均设置为 true 时，只需要引入 prism-line-numbers.css 即可启用行号显示。如果 preprocess 和 line_number 均被关闭，则需要将 prism-line-numbers.css 和 prism-line-numbers.js 都引入才能启用行号显示。 tab_replace用代码内的 tab (\\t) 替换为给定值，默认值是两个空格。 参考Hexo 代码高亮 其他参考Highlight.jsPrismJSHexo 语法高亮部分的源码可参见：Highlight.js 工具函数PrismJS 工具函数代码块标签插件反引号代码块标签插件 实现搜索功能hexo在deploy生成文章的时候，会生成一个content.json的文件，里面保存着所有的文章信息，我们可以在网页加载完毕后，利用ajax请求获得该文件的信息，实现搜索功能 配置生成 content.json 文件在 _config.yaml 中加入 jsonContent jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: true slug: false updated: true comments: false link: false permalink: false excerpt: true categories: false tags: true 参数意义可以参考 meta: &#123; title: hexo.config.title, subtitle: hexo.config.subtitle, description: hexo.config.description, author: hexo.config.author, url: hexo.config.url&#125;,pages: [&#123; //-&gt; all pages title: page.title, slug: page.slug, date: page.date, updated: page.updated, comments: page.comments, permalink: page.permalink, path: page.path, excerpt: page.excerpt, //-&gt; only text ;) keywords: null, //-&gt; it needs settings text: page.content, //-&gt; only text minified ;) raw: page.raw, //-&gt; original MD content content: page.content, //-&gt; final HTML content author: page.author, categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;],posts: [&#123; //-&gt; only published posts title: post.title, slug: post.slug, date: post.date, updated: post.updated, comments: post.comments, permalink: post.permalink, path: post.path, excerpt: post.excerpt, //-&gt; only text minified ;) description: post.description, //-&gt; only text minified ;) keywords: null, //-&gt; it needs settings text: post.content, //-&gt; only text minified ;) raw: post.raw, //-&gt; original MD content content: post.content, //-&gt; final HTML content author: post.author, categories: [&#123; name: category.name, slug: category.slug, permalink: category.permalink &#125;], tags: [&#123; name: tag.name, slug: tag.slug, permalink: tag.permalink &#125;]&#125;],categories: [&#123; //-&gt; Posts categories index ;) name: category.name, slug: category.slug, permalink: category.permalink&#125;],tags: [&#123; //-&gt; Posts tags index ;) name: tag.name, slug: tag.slug, permalink: tag.permalink&#125;]","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"hexo","slug":"hexo","permalink":"https://luckyship.github.io/tags/hexo/"}]},{"title":"hexo 添加文章导航","date":"2020-09-29T16:00:00.000Z","path":"2020/09/30/2020-09-30-hexo-add-article-nav/","text":"在Hexo官网 文档&gt;自定义&gt;辅助函数&gt;最下面，可以找到toc这个函数，看其介绍能知道它就是来实现文章目录的。 使用toc函数，不显示标题前数字，item为页面中传过去的参数post toc.ejs&lt;% if (item) &#123; %&gt;&lt;div id=&quot;toc&quot; class=&quot;toc-article&quot;&gt; &lt;%- toc(item.content, &#123;list_number: false&#125;) %&gt;&lt;/div&gt;&lt;% &#125; %&gt; 在左侧栏插入代码 left-col.ejs&lt;nav&gt; &lt;%- partial(&#x27;_partial/post/toc&#x27;, &#123;item: page&#125;) %&gt;&lt;/nav&gt; 修改layout代码 &lt;%- partial(&#x27;_partial/left-col&#x27;, null, &#123;cache: !config.relative_link, post: page&#125;) %&gt;&lt;%- partial(&#x27;_partial/left-col&#x27;, &#123;cache: !config.relative_link, post: page&#125;) %&gt;","updated":"2025-08-02T05:46:04.173Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"hexo","slug":"hexo","permalink":"https://luckyship.github.io/tags/hexo/"}]},{"title":"apt命令的一些使用方法","date":"2020-09-26T16:00:00.000Z","path":"2020/09/27/2020-09-27-debian-install-command/","text":"apt-cache madison xxx // 查看软件包可以安装的版本apt download xxx // 只下载deb包，不安装 apt-cache madison$ apt-cache madison kubelet | head -n 5 kubelet | 1.18.8-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages kubelet | 1.18.6-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages kubelet | 1.18.5-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages kubelet | 1.18.4-01 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages kubelet | 1.18.4-00 | http://apt.kubernetes.io kubernetes-xenial/main amd64 Packages$ apt install kubelet=1.18.8-00 apt download$ apt-get download libssl1.1获取:1 http://mirrors.163.com/debian stretch/main amd64 libssl1.1 amd64 1.1.0l-1~deb9u1 [1,358 kB]已下载 1,358 kB，耗时 0秒 (2,830 kB/s)","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"debian","slug":"debian","permalink":"https://luckyship.github.io/tags/debian/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://luckyship.github.io/tags/ubuntu/"}]},{"title":"使用node快速起一个http服务器","date":"2020-09-26T16:00:00.000Z","path":"2020/09/27/2020-09-27-node-http-server/","text":"需要node环境 $ npm install http-server -g//默认为8080$ http-server -p 3000","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"nodejs","slug":"nodejs","permalink":"https://luckyship.github.io/tags/nodejs/"}]},{"title":"在debian上离线使用kubeadm搭建 v1.16.3版本Kubernetes集群","date":"2020-09-26T16:00:00.000Z","path":"2020/09/27/2020-09-27-debian-install-k8s-offline/","text":"环境准备debian 9 机器一台，作为master节点和node节点 首先安装docker离线安装dockerdocker 安装包 关闭swap、selinux、防火墙swapoff -asystemctl stop firewalld 添加k8s官方源需要科学上网 sudo curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key addsudo cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb http://apt.kubernetes.io/ kubernetes-xenial mainEOFsudo apt-get updatesudo apt-get install -y kubelet kubeadm kubectl kubernetes-cni 配置离线包$ apt-get download kubeadm=1.16.3-00 $ apt-get download kubelet=1.16.3-00 kubectl=1.16.3-00 kubernetes-cni$ apt-get download socat ebtables conntrack$ apt-get download cri-tools$ apt-get download libnetfilter-conntrack3$ apt-get download libssl1.1$ dpkg -i xxxx.deb 导出docker 离线包列出所有镜像 $ kubeadm config images list --image-repository registry.aliyuncs.com/google_containers --kubernetes-version v1.16.3registry.aliyuncs.com/google_containers/kube-apiserver:v1.16.3registry.aliyuncs.com/google_containers/kube-controller-manager:v1.16.3registry.aliyuncs.com/google_containers/kube-scheduler:v1.16.3registry.aliyuncs.com/google_containers/kube-proxy:v1.16.3registry.aliyuncs.com/google_containers/pause:3.1registry.aliyuncs.com/google_containers/etcd:3.3.15-0registry.aliyuncs.com/google_containers/coredns:1.6.2$ docker save xxx xxx xxx &gt; k8s.tar$ docker load &lt; k8s.tar 使用kubeadm部署k8s初始化环境$ kubeadm init \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.16.3 \\ --pod-network-cidr=10.244.0.0/16...Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 \\ --control-plane Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 根据提示设置 kubeconfig ，或者添加子节点 设置k8s的网络插件$ kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#x27;\\n&#x27;)&quot; $ docker save weaveworks/weave-npc:2.7.0 weaveworks/weave-kube:2.7.0 &gt; weave.tar$ docker load &lt; weave.tar 安装helm去除节点污点只有一个master节点的情况下，master节点不允许运行资源，需要去掉污点 $ kubectl get nodesNAME STATUS ROLES AGE VERSIONlinx-dev Ready master 138m v1.16.3$ kubectl describe node linx-dev | grep TaintTaints: node-role.kubernetes.io/master:NoSchedule// 如果Taints是none，则不需要去除污点kubectl taint nodes linx-dev node-role.kubernetes.io/master:NoSchedule- 下载客户端wget https://get.helm.sh/helm-v2.16.3-linux-amd64.tar.gz 解压缩并拷贝helm二进制文件tar xf helm-v2.16.3-linux-amd64.tar.gzcp linux-amd64/helm /usr/local/bin 导出tiller镜像docker save registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.16.3 &gt; helm.tardocker load &lt; helm.tar 初始化helm，部署tiller$ kubectl -n kube-system create serviceaccount tiller$ kubectl create clusterrolebinding tiller --clusterrole cluster-admin –serviceaccount=kube-system:tiller --stable-repo-url http://10.16.48.44/ 需要起一个http 服务，apache或者node都可以，这儿下面放了一个文件index.yaml文件，可以从这儿下载到https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts/index.yaml $ helm init --service-account tiller --tiller-image=registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.16.3 --upgrade --stable-repo-url http://193.160.57.100Creating /root/.helm/repository/repositories.yaml Adding stable repo with URL: http://193.160.57.100 Adding local repo with URL: http://127.0.0.1:8879/charts $HELM_HOME has been configured at /root/.helm.Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.Please note: by default, Tiller is deployed with an insecure &#x27;allow unauthenticated users&#x27; policy.To prevent this, run `helm init` with the --tiller-tls-verify flag.For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation 安装openebs存储服务yaml文件将其中的 imagePullPolicy 改为 IfNotPresent ，这样可以优先选择本地镜像，而不会去请求网络 https://openebs.github.io/charts/openebs-operator-1.5.0.yaml 导出所有openebs镜像$ docker save quay.io/openebs/m-apiserver:1.5.0 quay.io/openebs/openebs-k8s-provisioner:1.5.0 quay.io/openebs/snapshot-controller:1.5.0 quay.io/openebs/snapshot-provisioner:1.5.0 quay.io/openebs/node-disk-manager-amd64:v0.4.5 quay.io/openebs/node-disk-operator-amd64:v0.4.5 quay.io/openebs/admission-server:1.5.0 quay.io/openebs/provisioner-localpv:1.5.0 quay.io/openebs/linux-utils:1.5.0 &gt; openebs.tar$ docker load &lt; openebs.tar kubectl apply -f openebs-operator-1.5.0.yaml 设置默认存储$ kubectl patch storageclass openebs-hostpath -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;storageclass.storage.k8s.io/openebs-hostpath patched 安装kubesphere导入最小化镜像docker load &lt; ks_minimal_images.tar 安装kubespherekubectl apply -f kubesphere-minimal.yaml 参考Helm离线安装","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://luckyship.github.io/tags/kubernetes/"},{"name":"debian","slug":"debian","permalink":"https://luckyship.github.io/tags/debian/"}]},{"title":"kubernetes集群中访问外部域名","date":"2020-09-16T16:00:00.000Z","path":"2020/09/17/2020-09-17-k8s-add-new-domain-name/","text":"一般来说有三种方法可以实现添加外部域名 通过hostalias在deployment里面修改hosts文件 通过coredns修改hosts文件 通过kube-dns添加域名服务器 通过hostalias添加域名和ip创建nginx pod kubectl run nginx --image nginxpod/nginx created 查看pod $ kubectl get pods --output=wideNAME READY STATUS RESTARTS AGE IP NODEnginx 1/1 Running 0 13s 10.200.0.4 worker0$ kubectl exec nginx -- cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetfe00::0 ip6-mcastprefixfe00::1 ip6-allnodesfe00::2 ip6-allrouters10.200.0.4 nginx 添加额外的域名和ip apiVersion: v1kind: Podmetadata: name: hostaliases-podspec: restartPolicy: Never hostAliases: - ip: &quot;127.0.0.1&quot; hostnames: - &quot;foo.local&quot; - &quot;bar.local&quot; - ip: &quot;10.1.2.3&quot; hostnames: - &quot;foo.remote&quot; - &quot;bar.remote&quot; containers: - name: cat-hosts image: busybox command: - cat args: - &quot;/etc/hosts&quot; 运行这个pod kubectl apply -f https://k8s.io/examples/service/networking/hostaliases-pod.yamlpod/hostaliases-pod created 它的hostfile $ kubectl exec hostaliases-pod -- cat /etc/hosts127.0.0.1 localhost::1 localhost ip6-localhost ip6-loopbackfe00::0 ip6-localnetfe00::0 ip6-mcastprefixfe00::1 ip6-allnodesfe00::2 ip6-allrouters10.200.0.5 hostaliases-pod# Entries added by HostAliases.127.0.0.1 foo.local bar.local10.1.2.3 foo.remote bar.remote 通过coredns修改hosts文件使用edit命令修改coredns configmap资源, 添加域名 193.160.57.121 harbor.com kubectl edit configmap coredns -n kube-system [root@node-2 test]# kubectl get configmap coredns -n kube-system -o yamlapiVersion: v1data: Corefile: | .:53 &#123; errors health ready kubernetes cluster.local. in-addr.arpa ip6.arpa &#123; pods insecure fallthrough in-addr.arpa ip6.arpa ttl 30 &#125; hosts &#123; 193.160.57.121 harbor.com //添加域名 fallthrough &#125; prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance &#125;kind: ConfigMapmetadata: creationTimestamp: &quot;2020-08-20T10:18:50Z&quot; labels: addonmanager.kubernetes.io/mode: EnsureExists name: coredns namespace: kube-system resourceVersion: &quot;13875493&quot; selfLink: /api/v1/namespaces/kube-system/configmaps/coredns uid: 10a8e6df-d3d6-49a6-98b9-57640fdb6011 通过coredns添加域名服务器apiVersion: v1data: Corefile: | .:53 &#123; errors health ready kubernetes cluster.local. in-addr.arpa ip6.arpa &#123; pods insecure fallthrough in-addr.arpa ip6.arpa ttl 30 &#125; proxy . 10.167.129.6 //添加域名服务器 prometheus :9153 forward . /etc/resolv.conf cache 30 loop reload loadbalance &#125;kind: ConfigMapmetadata: creationTimestamp: &quot;2020-08-20T10:18:50Z&quot; labels: addonmanager.kubernetes.io/mode: EnsureExists name: coredns namespace: kube-system resourceVersion: &quot;13875493&quot; selfLink: /api/v1/namespaces/kube-system/configmaps/coredns uid: 10a8e6df-d3d6-49a6-98b9-57640fdb6011 通过kube-dns添加域名服务器修改kube-dns的使用的ConfigMap。 apiVersion: v1kind: ConfigMapmetadata: name: kube-dns namespace: kube-systemdata: stubDomains: | &#123;&quot;k8s.com&quot;: [&quot;192.168.10.10&quot;]&#125; upstreamNameservers: | [&quot;8.8.8.8&quot;, &quot;8.8.4.4&quot;] upstreamNameservers 即使用的外部DNS。 参考add-entries-to-pod-etc-hosts-with-host-aliaseskubernetes 集群DNS配置及容器内CoreDNS解析外部域名配置问题配置Pod使用外部DNS[]","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://luckyship.github.io/tags/kubernetes/"}]},{"title":"ruby的小技巧","date":"2020-09-13T16:00:00.000Z","path":"2020/09/14/2020-09-14-ruby-rare-knowledge/","text":"&amp;: 的用法&amp;: 重要用于数组的方法，它可以让数组中的每一个元素都执行&amp;: 后的方法，相当于 item.fun() ，比如 irb(main):001:0&gt; a = [1, 2, 3]=&gt; [1, 2, 3]irb(main):002:0&gt; a.map(&amp;:to_s)=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 等与 irb(main):004:0&gt; a.map &#123; |i| i.to_s &#125;=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] ruby中%的用法%Q %q%Q用于替代双引号的字符串. 当你需要在字符串里放入很多引号时候, 可以直接用下面方法而不需要在引号前逐个添加反斜杠 (“)%q用于代替单引号的字符串 2.3.0 :015 &gt; %Q(rudy said, &quot;i&#x27;m not ruby&quot;) =&gt; &quot;rudy said, \\&quot;i&#x27;m not ruby\\&quot;&quot; 2.3.0 :031 &gt; what_ruby = &#x27;this is ruby&#x27; =&gt; &quot;this is ruby&quot;2.3.0 :032 &gt; %Q!rudy said, &quot;#&#123;what_ruby&#125;&quot;! =&gt; &quot;rudy said, \\&quot;this is ruby\\&quot;&quot;2.3.0 :033 &gt; %q!rudy said, &quot;#&#123;what_ruby&#125;&quot;! =&gt; &quot;rudy said, \\&quot;\\#&#123;what_ruby&#125;\\&quot;&quot; (…)也可用其他非数字字母的符号或成对的符号代替, 诸如#…#, !…!, +…+, {…}, […], &lt;…&gt;, /…/等. 2.3.0 :016 &gt; %Q/rudy said, &quot;i&#x27;m not ruby&quot;/ =&gt; &quot;rudy said, \\&quot;i&#x27;m not ruby\\&quot;&quot;2.3.0 :017 &gt; %Q#rudy said, &quot;i&#x27;m not ruby&quot;# =&gt; &quot;rudy said, \\&quot;i&#x27;m not ruby\\&quot;&quot;2.3.0 :018 &gt; %Q!rudy said, &quot;i&#x27;m not ruby&quot;! =&gt; &quot;rudy said, \\&quot;i&#x27;m not ruby\\&quot;&quot; %W，%w%W语法近似于%Q, 用于表示其中元素被双引号括起的数组.%w语法近似于%q, 用于表示其中元素被单引号括起的数组. 2.3.0 :031 &gt; what_ruby = &#x27;this is ruby&#x27; =&gt; &quot;this is ruby&quot;2.3.0 :034 &gt; %W(hello,kitty,cat,dog,what_ruby) =&gt; [&quot;hello,kitty,cat,dog,what_ruby&quot;] ###不能用逗号隔开，只能用空格2.3.0 :035 &gt; %W(hello kitty cat dog what_ruby) =&gt; [&quot;hello&quot;, &quot;kitty&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;what_ruby&quot;]2.3.0 :036 &gt; %W(hello kitty cat dog #&#123;what_ruby&#125;) =&gt; [&quot;hello&quot;, &quot;kitty&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;this is ruby&quot;]###双引号中可以被解析2.3.0 :037 &gt; %w(hello kitty cat dog #&#123;what_ruby&#125;) =&gt; [&quot;hello&quot;, &quot;kitty&quot;, &quot;cat&quot;, &quot;dog&quot;, &quot;\\#&#123;what_ruby&#125;&quot;]###单引号中不能被解析，被转义了。 %x用于执行一段shell脚本，并返回输出内容。 2.3.0 :038 &gt; %x(route -n) =&gt; &quot;Kernel IP routing table\\nDestination Gateway Genmask Flags Metric Ref Use Iface\\n0.0.0.0 10.6.0.1 0.0.0.0 UG 100 0 0 eth0\\n10.6.0.0 0.0.0.0 255.255.252.0 U 0 0 0 eth0\\n&quot;2.3.0 :039 &gt; %x(echo &quot;hello world&quot;) =&gt; &quot;hello world\\n&quot; %r语法近似于%Q, 用于正则表达式. 2.3.0 :031 &gt; what_ruby = &#x27;this is ruby&#x27; =&gt; &quot;this is ruby&quot;2.3.0 :041 &gt; %r(/home/#&#123;what_ruby&#125;) =&gt; /\\/home\\/this is ruby/ %s用于表示symbol, 但是不会对其中表达式等内容进行转化 2.3.0 :031 &gt; what_ruby = &#x27;this is ruby&#x27; =&gt; &quot;this is ruby&quot;2.3.0 :042 &gt; %s(a b c) =&gt; :&quot;a b c&quot;2.3.0 :043 &gt; %s(abc) =&gt; :abc2.3.0 :044 &gt; %s(what_ruby) =&gt; :what_ruby2.3.0 :045 &gt; %s(#&#123;what_ruby&#125;) =&gt; :&quot;\\#&#123;what_ruby&#125;&quot; %iRuby 2.0 之后引入的语法, 用于生成一个symbol数组 2.3.0 :031 &gt; what_ruby = &#x27;this is ruby&#x27; =&gt; &quot;this is ruby&quot;2.3.0 :046 &gt; %i(a b c) =&gt; [:a, :b, :c]2.3.0 :047 &gt; %i(a b c #&#123;what_ruby&#125;) =&gt; [:a, :b, :c, :&quot;\\#&#123;what_ruby&#125;&quot;] *的用法*可以代表数组, 比如可以用于剩余数组的赋值 irb(main):001:0&gt; a = [1,2,3]=&gt; [1, 2, 3]irb(main):002:0&gt; b,*c = a=&gt; [1, 2, 3]irb(main):003:0&gt; c=&gt; [2, 3]irb(main):004:0&gt; b=&gt; 1 可以用来代替多参数的函数 irb(main):001:0&gt; def test(a, b)irb(main):002:1&gt; puts airb(main):003:1&gt; puts birb(main):004:1&gt; end=&gt; :testirb(main):005:0&gt; c = [1,2]=&gt; [1, 2]irb(main):006:0&gt; test(*c)12=&gt; nil 数组可以运算ruby中数组可以进行 + 和 - 的操作，主要说一下 - 的作用：减去2个数组共有的元素 irb(main):001:0&gt; a = [1,2,3]=&gt; [1, 2, 3]irb(main):002:0&gt; b = [2,3,4]=&gt; [2, 3, 4]irb(main):003:0&gt; a - b=&gt; [1]irb(main):004:0&gt; a + b=&gt; [1, 2, 3, 2, 3, 4] json数据格式化为symbol类型irb(main):005:0&gt; require &#x27;json&#x27;=&gt; trueirb(main):006:0&gt; a = &#123;b:1, c:2&#125;=&gt; &#123;:b=&gt;1, :c=&gt;2&#125;irb(main):007:0&gt; JSON.generate(a) # symbol类型的key被转为字符串=&gt; &quot;&#123;\\&quot;b\\&quot;:1,\\&quot;c\\&quot;:2&#125;&quot;irb(main):008:0&gt; JSON.parse(JSON.generate(a))=&gt; &#123;&quot;b&quot;=&gt;1, &quot;c&quot;=&gt;2&#125;irb(main):009:0&gt; JSON.parse(JSON.generate(a), symbolize_names: true)=&gt; &#123;:b=&gt;1, :c=&gt;2&#125; send的用法send用来调用不确定的函数名 irb(main):001:0&gt; def test(a)irb(main):002:1&gt; puts airb(main):003:1&gt; end=&gt; :testirb(main):004:0&gt; send(&#x27;test&#x27;, &#x27;2&#x27;)2=&gt; nil 函数的返回值可以不写 return ，默认返回最后一行的值 查看类有哪些方法可以用 .methods 方法 irb(main):010:0&gt; class Airb(main):011:1&gt; class &lt;&lt; selfirb(main):012:2&gt; def birb(main):013:3&gt; puts &#x27;test&#x27;irb(main):014:3&gt; endirb(main):015:2&gt; endirb(main):016:1&gt; end irb(main):021:0&gt; A.methods.include?(:b)=&gt; true $1的用法表示正则匹配中 () 中匹配的内容，数字表示第几个括号 irb(main):004:0&gt; a = &#x27;asdf123asd&#x27;=&gt; &quot;asdf123asd&quot;irb(main):008:0&gt; a =~ /asdf(123)/=&gt; 0irb(main):009:0&gt; $1=&gt; &quot;123&quot;","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"}]},{"title":"在debian上使用kubeadm搭建 v1.16.3版本Kubernetes集群","date":"2020-09-09T16:00:00.000Z","path":"2020/09/10/2020-09-10-debian-install-k8s/","text":"环境准备debian 9 机器一台，作为master节点和node节点 首先安装docker离线安装dockerdocker 安装包下载地址 解压tar -xvf docker-18.06.1-ce.tgz 将解压出来的docker文件内容移动到 /usr/bin/ 目录下cp docker/* /usr/bin/ 将docker注册为servicevim /etc/systemd/system/docker.service 将下列配置复制到docker.service中并保存 [Unit]Description=Docker Application Container EngineDocumentation=https://docs.docker.comAfter=network-online.target firewalld.serviceWants=network-online.target[Service]Type=notify# the default is not to use systemd for cgroups because the delegate issues still# exists and systemd currently does not support the cgroup feature set required# for containers run by dockerExecStart=/usr/bin/dockerdExecReload=/bin/kill -s HUP $MAINPID# Having non-zero Limit*s causes performance problems due to accounting overhead# in the kernel. We recommend using cgroups to do container-local accounting.LimitNOFILE=infinityLimitNPROC=infinityLimitCORE=infinity# Uncomment TasksMax if your systemd version supports it.# Only systemd 226 and above support this version.#TasksMax=infinityTimeoutStartSec=0# set delegate yes so that systemd does not reset the cgroups of docker containersDelegate=yes# kill only the docker process, not all processes in the cgroupKillMode=process# restart the docker process if it exits prematurelyRestart=on-failureStartLimitBurst=3StartLimitInterval=60s [Install]WantedBy=multi-user.target 启动chmod +x /etc/systemd/system/docker.service #添加文件权限并启动dockersystemctl daemon-reload #重载unit配置文件systemctl start docker #启动Dockersystemctl enable docker.service #设置开机自启 验证systemctl status docker #查看Docker状态docker -v #查看Docker版本 关闭swap、selinux、防火墙swapoff -asystemctl stop firewalld 添加k8s官方源需要科学上网 sudo curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key addsudo cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb http://apt.kubernetes.io/ kubernetes-xenial mainEOFsudo apt-get updatesudo apt-get install kubelet=1.16.3-00 kubeadm=1.16.3-00 kubectl=1.16.3-00 kubernetes-cni 使用kubeadm部署k8s初始化环境因为官方镜像比较慢，所以使用阿里镜像 $ kubeadm init \\ --image-repository registry.aliyuncs.com/google_containers \\ --kubernetes-version v1.16.3 \\ --pod-network-cidr=10.244.0.0/16...Your Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 \\ --control-plane Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 根据提示设置 kubeconfig ，或者添加子节点 设置k8s的网络插件使用 kubectl get pods -A 发现 coredns 状态不是 running ，需要配置网络插件 $ kubectl apply -f &quot;https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d &#x27;\\n&#x27;)&quot; 安装helm去除节点污点只有一个master节点的情况下，master节点不允许运行资源，需要去掉污点 $ kubectl get nodesNAME STATUS ROLES AGE VERSIONlinx-dev Ready master 138m v1.16.3$ kubectl describe node linx-dev | grep TaintTaints: node-role.kubernetes.io/master:NoSchedule// 如果Taints是none，则不需要去除污点kubectl taint nodes linx-dev node-role.kubernetes.io/master:NoSchedule- 下载客户端wget https://get.helm.sh/helm-v2.16.3-linux-amd64.tar.gz 解压缩并拷贝helm二进制文件tar xf helm-v2.16.3-linux-amd64.tar.gzcp linux-amd64/helm /usr/local/bin 添加阿里云的仓库helm init --client-only --stable-repo-url https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts/helm repo add incubator https://aliacs-app-catalog.oss-cn-hangzhou.aliyuncs.com/charts-incubator/helm repo update 创建 Kubernetes 的服务帐号和绑定角色// 创建serviceaccountkubectl create serviceaccount --namespace kube-system tiller// 创建角色绑定kubectl create clusterrolebinding tiller-cluster-rule --clusterrole=cluster-admin --serviceaccount=kube-system:tiller 创建服务端 使用-i指定阿里云仓库helm init --service-account tiller --upgrade -i registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.16.3 --stable-repo-url https://kubernetes.oss-cn-hangzhou.aliyuncs.com/charts 安装openebs存储服务部署openebskubectl apply -f https://openebs.github.io/charts/openebs-operator-1.5.0.yaml 设置默认存储$ kubectl patch storageclass openebs-hostpath -p &#x27;&#123;&quot;metadata&quot;: &#123;&quot;annotations&quot;:&#123;&quot;storageclass.kubernetes.io/is-default-class&quot;:&quot;true&quot;&#125;&#125;&#125;&#x27;storageclass.storage.k8s.io/openebs-hostpath patched 安装kubespherekubectl apply -f https://raw.githubusercontent.com/kubesphere/ks-installer/master/kubesphere-minimal.yaml 参考Helm离线安装","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://luckyship.github.io/tags/kubernetes/"},{"name":"debian","slug":"debian","permalink":"https://luckyship.github.io/tags/debian/"}]},{"title":"整理面试相关","date":"2020-09-05T16:00:00.000Z","path":"2020/09/06/2020-09-06-interview-css/","text":"简单记录一下面试的一些要点 javascript 事件机制先捕获，后冒泡，捕获从上到下，冒泡从下到上 冒泡机制IE 提出的事件流叫做事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点，看一下以下示例 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body onclick=&quot;bodyClick()&quot;&gt; &lt;div onclick=&quot;divClick()&quot;&gt; &lt;button onclick=&quot;btn()&quot;&gt; &lt;p onclick=&quot;p()&quot;&gt;点击冒泡&lt;/p&gt; &lt;/button&gt; &lt;/div&gt; &lt;script&gt; function p() &#123; console.log(&quot;p标签被点击&quot;); &#125; function btn() &#123; console.log(&quot;button被点击&quot;); &#125; function divClick(event) &#123; console.log(&quot;div被点击&quot;); &#125; function bodyClick() &#123; console.log(&quot;body被点击&quot;); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 结果显而易见 p标签被点击button被点击div被点击body被点击 捕获机制事件捕获流的思想是不太具体的 DOM 节点应该更早接收到事件，而最具体的节点应该最后接收到事件，针对上面同样的例子，点击按钮，那么此时 click 事件会按照这样传播：（下面我们就借用 addEventListener 的第三个参数来模拟事件捕获流） &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button&gt; &lt;p&gt;点击捕获&lt;/p&gt; &lt;/button&gt; &lt;/div&gt; &lt;script&gt; var oP = document.querySelector(&quot;p&quot;); var oB = document.querySelector(&quot;button&quot;); var oD = document.querySelector(&quot;div&quot;); var oBody = document.querySelector(&quot;body&quot;); oP.addEventListener( &quot;click&quot;, function () &#123; console.log(&quot;p标签被点击&quot;); &#125;, true ); oB.addEventListener( &quot;click&quot;, function () &#123; console.log(&quot;button被点击&quot;); &#125;, true ); oD.addEventListener( &quot;click&quot;, function () &#123; console.log(&quot;div被点击&quot;); &#125;, true ); oBody.addEventListener( &quot;click&quot;, function () &#123; console.log(&quot;body被点击&quot;); &#125;, true ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 与冒泡相反的结果 body被点击div被点击button被点击p标签被点击 DOM 2 级事件处理程序DOM 2 级事件定义了两方法：用于处理添加事件和删除事件的操作： 添加事件 addEventListener()删除事件 removeEventListener() 所有 DOM 节点中都包含这两个方法，并且他们都包含 3 个参数： （1） 要处理的事件方式（例如： click，mouseover, dbclick..... ） （2）事件处理的函数，可以为匿名函数，也可以为命名函数（但如果需要删除事件，必须是命名函数） （3）一个布尔值，代表是处于事件冒泡阶段处理还是事件捕获阶段（true：表示在捕获阶段调用事件处理程序；false: 表示在冒泡阶段调用事件处理程序） 使用 DOM 2 级事件处理程序的主要好处是可以添加多个事件处理程序，事件处理会按照他们的顺序触发，通过 addEventListener 添加的事件只能用 removeEventListener 来移除，移除时传入的参数与添加时使用的参数必须相同，这也意味着添加的匿名函数将无法移除， （注意：我们默认的第三个参数都是默认 false , 是指在冒泡阶段添加，大多数情况下，都是将事件处理程序添加到事件的冒泡阶段，这样可以最大限度的兼容各个浏览器） css 省略文字的实现 &#123; overflow: hidden; white-space: nowrap; text-overflow: allipsis;&#125; settimeout, setinterval，eval 在赋值时有什么问题？vue 解决跨域问题什么是跨域跨域：由于浏览器同源策略，凡是发送请求 url 的协议、域名、端口三者之间任意一个与当前页面地址不同即为跨域。存在跨域的情况： 网络协议不同，如 http 协议访问 https 协议。 端口不同，如 80 端口访问 8080 端口。 域名不同，如 qianduanblog.com 访问 baidu.com。 子域名不同，如 abc.qianduanblog.com 访问 def.qianduanblog.com。 域名和域名对应 ip, 如www.a.com访问20.205.28.90. 下面是项目使用 vue-cli 脚手架搭建使用 http-proxy-middleware 代理解决跨域问题例如请求的 url:“http://f.apiplus.cn/bj11x5.json”1、打开 config/index.js, 在 proxyTable 中添写如下代码： proxyTable: &#123; &#x27;/api&#x27;: &#123; //使用&quot;/api&quot;来代替&quot;http://f.apiplus.c&quot; target: &#x27;http://f.apiplus.cn&#x27;, //源地址 changeOrigin: true, //是否跨域 pathRewrite: &#123; &#x27;^/api&#x27;: &#x27;http://f.apiplus.cn&#x27; //路径重写 &#125; &#125;&#125; 2、使用 axios 请求数据时直接使用“/api”： getData() &#123; axios.get(&#x27;/api/bj11x5.json&#x27;, function(res) &#123; console.log(res) &#125;) 通过这中方法去解决跨域，打包部署时还按这种方法会出问题。解决方法如下： let serverUrl = &quot;/api/&quot;; //本地调试时// let serverUrl = &#x27;http://f.apiplus.cn/&#x27; //打包部署上线时 vue 解决 xss 注入问题 在终端引入 xss, 命令： npm install xss --save 在 vue 的页面进行引入 import xss from &quot;xss&quot;; 定义一个变量进行测试首先测试一个没有进行防止 xss 攻击的测试 &lt; p v - html = &quot;test&quot; &gt; &lt; /p&gt;export default &#123; data() &#123; return &#123; test: `&lt;a onclick=&#x27;alert(&quot;xss攻击&quot;)&#x27;&gt;链接&lt;/a&gt;` &#125; 结果，js 事件直接被翻译了 xss攻击 因此应该杜绝这些情况，解决方法如下 &lt; p v - html = &quot;$xss(test)&quot; &gt; &lt; /p&gt;import xss from &#x27;xss&#x27;export default &#123; data() &#123; return &#123; test: `&lt;a onclick=&#x27;alert(&quot;xss攻击&quot;)&#x27;&gt;链接&lt;/a&gt;` &#125; &#125;Vue.prototype.$xss = xss; 此时 a 标签会保留，但是 onclick 事件被拦截了 vue axios 的几种请求方式axios 的请求方法：get、post、put、patch、delete get：获取数据 post：提交数据（表单提交+文件上传） put：更新数据（所有数据推送到后端） patch：更新数据（只将更改的数据推送到后端） delete：删除数据 //axios的get请求第一种写法不带参数axios.get(&quot;/data.json&quot;).then(res =&gt; &#123; console.log(res);&#125;);//axios的get请求第一种写法带参数axios .get(&quot;/data.json&quot;, &#123; params: &#123; id: 12, &#125;, &#125;) .then(res =&gt; &#123; console.log(res); &#125;);//axios的get请求第二种写法不带参数axios(&#123; method: &quot;get&quot;, url: &quot;/data.json&quot;,&#125;).then(res =&gt; &#123; console.log(res);&#125;);//axios的get请求第二种写法带参数axios(&#123; method: &quot;get&quot;, url: &quot;/data.json&quot;, params: &#123; id: 12, &#125;,&#125;).then(res =&gt; &#123; console.log(res);&#125;);//axios的post请求第一种写法let data = &#123; id: 12,&#125;;axios.post(&quot;/post&quot;, data).then(res =&gt; &#123; console.log(res);&#125;);//axios的post请求第二种写法axios(&#123; method: &quot;post&quot;, url: &quot;/post&quot;, data: data,&#125;).then(res =&gt; &#123; console.log(res);&#125;);//form-data请求,图片上传、文件上传，文件格式为：multipart/form-data，其他请求为application/jsonlet formData = new formData();for (let key in data) &#123; formData.append(key, data[key]);&#125;axios.post(&quot;/post&quot;, formData).then(res =&gt; &#123; console.log(res);&#125;);//axios之put请求axios.put(&quot;/put&quot;, data).then(res =&gt; &#123; console.log(res);&#125;);//axios之patch请求axios.patch(&quot;/patch&quot;, data).then(res =&gt; &#123; console.log(res);&#125;);//axios之delete请求的第一种写法axios .delete(&quot;/delete&quot;, &#123; params: &#123; id: 12, &#125;, &#125;) .then(res =&gt; &#123; console.log(res); &#125;);//说明:当使用第一种写法参数为params时，请求接口时参数是放在URL里面的。// 例：http://localhost:8080/delete?id=12,而写成第二种方法data就不会，根据实际情况使用//axios之delete请求的第二种写法axios .delete(&quot;/delete&quot;, &#123; data: &#123; id: 12, &#125;, &#125;) .then(res =&gt; &#123; console.log(res); &#125;); js 如何比较浮点数浮点数的定义，非整数的 Number 类型无法用 = 来比较，这就是为什么在 JavaScript 中，0.1+0.2 不能=0.3： console.log(0.1 + 0.2 == 0.3);false; 这里输出的结果是 false ，说明两边不相等的，这是浮点运算的特点，浮点数运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。 所以实际上，这里错误的不是结论，而是比较的方法，正确的比较方法是使用 JavaScript 提供的最小精度值： console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;= Number.EPSILON); 项目做过哪些优化 减少 HTTP 请求数 减少DNS查询 使用 CDN 避免重定向 图片懒加载 减少 DOM 元素数量 减少 DOM 操作 使用外部 JavaScript 和 CSS 压缩 JavaScript 、 CSS 、字体、图片等 优化 CSS Sprite 使用 iconfont 字体裁剪 多域名分发划分内容到不同域名 尽量减少 iframe 使用 避免图片 src 为空 把样式表放在 中 把脚本放在页面底部 重排和重绘 部分渲染树（或者整个渲染树）需要重新分析并且节点尺寸需要重新计算。这被称为重排。注意这里至少会有一次重排-初始化页面布局。 由于节点的几何属性发生改变或者由于样式发生改变，例如改变元素背景色时，屏幕上的部分内容需要更新。这样的更新被称为重绘。 什么情况会触发重排和重绘？ 添加、删除、更新 DOM 节点 通过 display: none 隐藏一个 DOM 节点-触发重排和重绘 通过 visibility: hidden 隐藏一个 DOM 节点-只触发重绘，因为没有几何变化 移动或者给页面中的 DOM 节点添加动画 添加一个样式表，调整样式属性 用户行为，例如调整窗口大小，改变字号，或者滚动。 浏览器缓存 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下： 先根据这个资源的一些 http header 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不* 会发请求到服务器； 当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些 request header 验证这个资源是否命* 中协商缓存，称为 http 再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存* 中获取，客户端收到返回后就会从缓存中获取资源； 强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。 当协商缓存也没命中时，服务器就会将资源发送回客户端。 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存； 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存； 强缓存 Expires（该字段是 http1.0 时的规范，值为一个绝对时间的 GMT 格式的时间字符串，代表缓存资源的过* 期时间） Cache-Control:max-age（该字段是 http1.1 的规范，强缓存利用其 max-age 值来判断缓存资源的最大生命周期，它的值单位为秒） 协商缓存 Last-Modified（值为资源最后更新时间，随服务器 response 返回） If-Modified-Since（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中* 协商缓存） ETag（表示资源内容的唯一标识，随服务器 response 返回） If-None-Match（服务器通过比较请求头部的 If-None-Match 与当前资源的 ETag 是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存） new 操作符具体干了什么 创建空对象，并且 this 变量引用该对象同时继承该函数的原型 属性和方法加入到 this 引用的对象中 新创建的对象用 this 引用，并且隐式地返回 this 创建一个新对象(__proto__ 指向构造函数的 prototype) 把作用域（this）指给这个对象 执行构造函数的代码 如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象 function Base() &#123; this.id = &quot;base&quot;;&#125;var obj = new Base(); new 干了什么？ var obj = {}; obj.__proto__ = Base.protptype; Base.call(obj); es5 使用 Object.create()来创建对象 new Object() 字面量写法{}使用 Object.create()是将对象继承到proto属性上，Object.create(null)没有继承任何原型方法，也就是说它的原型链没有上一层。 es6 使用 class 关键字 构造器就是普通的函数, new 来作用称为构造方法(构造函数) 访问原型链会损耗性能, 不存在的属性会遍历原型链直到最后一层 hasOwnProperty 是 JavaScript 中唯一处理属性并且不会遍历原型链的方法。通常在 for in 循环中使用。 实现 new 函数function _new(func) &#123; // 第一步 创建新对象 let obj = &#123;&#125;; // 第二步 空对象的_proto_指向了构造函数的prototype成员对象 obj.__proto__ = func.prototype; // // 一二步合并就相当于 let obj=Object.create(func.prototype) // 第三步 使用apply调用构造器函数，属性和方法被添加到 this 引用的对象中 let result = func.apply(obj); if (result &amp;&amp; (typeof result == &quot;object&quot; || typeof result == &quot;function&quot;)) &#123; // 如果构造函数执行的结果返回的是一个对象，那么返回这个对象 return result; &#125; // 如果构造函数返回的不是一个对象，返回创建的新对象 return obj;&#125;","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"},{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://luckyship.github.io/tags/html/"}]},{"title":"在centos7上使用kubeadm搭建 v1.16.9版本Kubernetes集群","date":"2020-09-03T16:00:00.000Z","path":"2020/09/04/2020-09-04-centos-install-k8s/","text":"环境准备实验环境 角色 IP地址 主机名 docker版本 硬件配置 系统 内核 master 192.168.9.10 k8s-master 18.09.9 2c4g CentOS7.7 3.10.0-1062.el7.x86_64 node1 192.168.9.13 k8s-node1 18.09.9 2c6g CentOS7.7 3.10.0-1062.el7.x86_64 node2 192.168.9.14 k8s-node2 18.09.9 2c6g CentOS7.7 3.10.0-1062.el7.x86_64 每个节点配置host信息cat &gt;&gt; /etc/hosts &lt;&lt;EOF192.168.9.10 k8s-master192.168.9.13 k8s-node1192.168.9.14 k8s-node2EOF 禁用防火墙和selinux//禁用防火墙systemctl stop firewalld &amp;&amp; systemctl disable firewalld//禁用selinux#临时修改setenforce 0#永久修改，重启服务器后生效sed -i &#x27;7s/enforcing/disabled/&#x27; /etc/selinux/config 创建 /etc/sysctl.d/k8s.conf 文件，添加如下内容//向文件中写入以下内容cat &gt;/etc/sysctl.d/k8s.conf &lt;&lt;EOFnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1EOF//执行以下命令生效modprobe br_netfilter &amp;&amp; sysctl -p /etc/sysctl.d/k8s.conf 安装ipvs脚本创建了的 /etc/sysconfig/modules/ipvs.modules 文件，保证在节点重启后能自动加载所需模块。使用 lsmod | grep -e ip_vs -e nf_conntrack_ipv4 命令查看是否已经正确加载所需的内核模块 //向文件中写入以下内容cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;EOF#!/bin/bashmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4EOF//修改权限以及查看是否已经正确加载所需的内核模块chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4nf_conntrack_ipv4 15053 0 nf_defrag_ipv4 12729 1 nf_conntrack_ipv4ip_vs_sh 12688 0 ip_vs_wrr 12697 0 ip_vs_rr 12600 0 ip_vs 145497 6 ip_vs_rr,ip_vs_sh,ip_vs_wrrnf_conntrack 133095 2 ip_vs,nf_conntrack_ipv4libcrc32c 12644 3 xfs,ip_vs,nf_conntrack 安装ipset和ipvsadm(便于查看 ipvs 的代理规则) yum -y install ipset ipvsadm 关闭swap分区修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用 free -m 确认 swap 已经关闭 //手动关闭swapswapoff -a//修改fstab文件，注释swap自动挂载sed -i &#x27;/^\\/dev\\/mapper\\/centos-swap/c#/dev/mapper/centos-swap swap swap defaults 0 0&#x27; /etc/fstab//查看swap是否关闭free -mtotal used free shared buff/cache availableMem: 1994 682 612 9 699 1086Swap: 0 0 0 swappiness 参数调整，修改 /etc/sysctl.d/k8s.conf 添加下面一行 cat &gt;&gt;/etc/sysctl.d/k8s.conf &lt;&lt;EOFvm.swappiness=0EOF//使配置生效sysctl -p /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1vm.swappiness = 0 安装docker18.09.9 添加阿里云yum源 yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 查看可用版本 yum list docker-ce --showduplicates | sort -r已加载插件：fastestmirror, langpacks可安装的软件包 * updates: mirrors.aliyun.comLoading mirror speeds from cached hostfile * extras: mirrors.aliyun.comdocker-ce.x86_64 3:19.03.5-3.el7 docker-ce-stabledocker-ce.x86_64 3:19.03.4-3.el7 docker-ce-stable。。。。。。docker-ce.x86_64 3:18.09.9-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.8-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.7-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.6-3.el7 docker-ce-stable。。。。。。 安装docker18.09.9 yum -y install docker-ce-18.09.9-3.el7 docker-ce-cli-18.09.9 启动docker并设置开机自启 systemctl enable docker &amp;&amp; systemctl start docker 配置阿里云docker镜像加速 cat &gt; /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123; &quot;registry-mirrors&quot;: [&quot;https://gqk8w9va.mirror.aliyuncs.com&quot;]&#125;EOF 配置完后重启docker systemctl restart docker 查看加速 docker info找到Registry Mirrors一行Registry Mirrors: https://gqk8w9va.mirror.aliyuncs.com/ 查看docker版本docker version Client: Version: 18.09.9 API version: 1.39 Go version: go1.11.13 Git commit: 039a7df9ba Built: Wed Sep 4 16:51:21 2019 OS/Arch: linux/amd64 Experimental: falseServer: Docker Engine - Community Engine: Version: 18.09.9 API version: 1.39 (minimum version 1.12) Go version: go1.11.13 Git commit: 039a7df Built: Wed Sep 4 16:22:32 2019 OS/Arch: linux/amd64 Experimental: false 若有需要网络代理的，请在docker中配置网络代理，否则docker无法下载镜像 修改docker Cgroup Driver为systemd#修改docker Cgroup Driver为systemd将/usr/lib/systemd/system/docker.service文件中的这一行 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock修改为 ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd如果不修改，在添加 worker 节点时可能会碰到如下错误[WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri///使用如下命令修改 sed -i.bak &quot;s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g&quot; /usr/lib/systemd/system/docker.service//重启dockersystemctl daemon-reload &amp;&amp; systemctl restart docker 安装Kubeadm需要科学上网 cat &gt;/etc/yum.repos.d/kubernetes.repo&lt;&lt;EOF[kubernetes]name=Kubernetesbaseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=1repo_gpgcheck=1gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpgEOF 使用阿里云yum源 cat &gt;/etc/yum.repos.d/kubernetes.repo &lt;&lt;EOF[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpgEOF 安装 kubeadm、kubelet、kubectl(阿里云yum源会随官方更新最新版，因此指定版本) //安装1.16.9版本yum -y install kubelet-1.16.9 kubeadm-1.16.9 kubectl-1.16.9//查看版本kubeadm versionkubeadm version: &amp;version.Info&#123;Major:&quot;1&quot;, Minor:&quot;16&quot;, GitVersion:&quot;v1.16.9&quot;, GitCommit:&quot;a17149e1a189050796ced469dbd78d380f2ed5ef&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2020-04-16T11:42:30Z&quot;, GoVersion:&quot;go1.13.9&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125; 设置kubelet开机自启 systemctl enable kubelet 设置k8s命令自动补全 yum -y install bash-completionsource /usr/share/bash-completion/bash_completionsource &lt;(kubectl completion bash)echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc 初始化集群master节点操作，配置 kubeadm 初始化文件cat &lt;&lt;EOF &gt; ./kubeadm-config.yamlapiVersion: kubeadm.k8s.io/v1beta2kind: ClusterConfigurationkubernetesVersion: v1.16.9 imageRepository: registry.cn-hangzhou.aliyuncs.com/google_containers#master地址controlPlaneEndpoint: &quot;192.168.9.10:6443&quot; networking: serviceSubnet: &quot;10.96.0.0/16&quot; #k8s容器组所在的网段 podSubnet: &quot;10.20.0.1/16&quot; dnsDomain: &quot;cluster.local&quot;EOF 初始化master #kubeadm init --config=kubeadm-config.yaml --upload-certs完整输出结果kubeadm init --config=kubeadm-config.yaml[init] Using Kubernetes version: v1.16.9[preflight] Running pre-flight checks[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;[certs] Generating &quot;ca&quot; certificate and key[certs] Generating &quot;apiserver&quot; certificate and key[certs] apiserver serving cert is signed for DNS names [k8s-master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 192.168.9.10 192.168.9.10][certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key[certs] Generating &quot;front-proxy-ca&quot; certificate and key[certs] Generating &quot;front-proxy-client&quot; certificate and key[certs] Generating &quot;etcd/ca&quot; certificate and key[certs] Generating &quot;etcd/server&quot; certificate and key[certs] etcd/server serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.9.10 127.0.0.1 ::1][certs] Generating &quot;etcd/peer&quot; certificate and key[certs] etcd/peer serving cert is signed for DNS names [k8s-master localhost] and IPs [192.168.9.10 127.0.0.1 ::1][certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key[certs] Generating &quot;sa&quot; key and public key[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s[apiclient] All control plane components are healthy after 16.501777 seconds[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace[kubelet] Creating a ConfigMap &quot;kubelet-config-1.16&quot; in namespace kube-system with the configuration for the kubelets in the cluster[upload-certs] Skipping phase. Please see --upload-certs[mark-control-plane] Marking the node k8s-master as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;[mark-control-plane] Marking the node k8s-master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: px979r.mphk9ee5ya8fgy44[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/You can now join any number of control-plane nodes by copying certificate authorities and service account keys on each node and then running the following as root: kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 \\ --control-plane Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 \\ --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 拷贝 kubeconfig 文件 //这里的路径为/rootmkdir -p $HOME/.kubecp -i /etc/kubernetes/admin.conf $HOME/.kube/configchown $(id -u):$(id -g) $HOME/.kube/config master添加节点node1和node2相同操作将master节点上的$HOME/.kube/config 文件拷贝到node节点对应的文件中 1.创建目录，这里的路径为/rootmkdir -p $HOME/.kube 2.把master节点上的config文件拷贝到node1和node2的$HOME/.kubescp k8s-master1:~/.kube/config $HOME/.kube3.修改权限chown $(id -u):$(id -g) $HOME/.kube/config 将node1和node2加入到集群中这里需要用到2.2中初始化master最后生成的token和sha256值 #kubeadm join 192.168.9.10:6443 --token px979r.mphk9ee5ya8fgy44 --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 输出结果 [preflight] Running pre-flight checks [WARNING IsDockerSystemdCheck]: detected &quot;cgroupfs&quot; as the Docker cgroup driver. The recommended driver is &quot;systemd&quot;. Please follow the guide at https://kubernetes.io/docs/setup/cri/[preflight] Reading configuration from the cluster...[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -oyaml&#x27;[kubelet-start] Downloading configuration for the kubelet from the &quot;kubelet-config-1.16&quot; ConfigMap in the kube-system namespace[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Activating the kubelet service[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...This node has joined the cluster:* Certificate signing request was sent to apiserver and a response was received.* The Kubelet was informed of the new secure connection details.Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster. 如果忘记了token和sha256值，可以在master节点使用如下命令查看 //查看token#kubeadm token listTOKEN TTL EXPIRES USAGES DESCRIPTION EXTRA GROUPSpx979r.mphk9ee5ya8fgy44 20h 2020-03-18T13:49:48+08:00 authentication,signing &lt;none&gt; system:bootstrappers:kubeadm:default-node-token //查看sha256#openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | openssl dgst -sha256 -hex | sed &#x27;s/^.* //&#x27;5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51//同时查看token和sha256#kubeadm token create --print-join-commandkubeadm join 192.168.9.10:6443 --token 9b28zg.oyt0kvvpmtrem4bg --discovery-token-ca-cert-hash sha256:5e7c7cd1cc1f86c0761e54b9380de22968b6b221cb98939c14ab2942223f6f51 master节点查看node，发现状态都是NotReady，因为还没有安装网络插件，这里我们安装calio官方插件文档 kubectl get nodesNAME STATUS ROLES AGE VERSIONk8s-master NotReady master 19m v1.16.9k8s-node1 NotReady &lt;none&gt; 4m10s v1.16.9k8s-node2 NotReady &lt;none&gt; 4m3s v1.16.9 master节点安装网络插件calio//下载文件wget https://docs.projectcalico.org/v3.8/manifests/calico.yaml 将文件中的620行改为如下，因为在上边kubeadm-config.yaml配置文件中指定了容器组IP 620行value: &quot;10.20.0.1/16&quot; //修改完成后安装calico网络插件kubectl apply -f calico.yaml//安装完成后稍等一会查看pods状态kubectl get pods -n kube-systemNAME READY STATUS RESTARTS AGEcalico-kube-controllers-dc6cb64cb-8sh59 1/1 Running 0 6m22scalico-node-89s9k 1/1 Running 0 6m22scalico-node-dkt7w 1/1 Running 0 6m22scalico-node-tgg2h 1/1 Running 0 6m22scoredns-667f964f9b-7hrj9 1/1 Running 0 33mcoredns-667f964f9b-8q7sh 1/1 Running 0 33metcd-k8s-master 1/1 Running 0 33mkube-apiserver-k8s-master 1/1 Running 0 32mkube-controller-manager-k8s-master 1/1 Running 0 33mkube-proxy-b2r5d 1/1 Running 0 12mkube-proxy-nd982 1/1 Running 0 11mkube-proxy-zh6cz 1/1 Running 0 33mkube-scheduler-k8s-master 1/1 Running 0 32m//查看node状态[root@k8s-master ~]# kubectl get nodes NAME STATUS ROLES AGE VERSIONk8s-master Ready master 31m v1.16.9k8s-node1 Ready &lt;none&gt; 9m46s v1.16.9k8s-node2 Ready &lt;none&gt; 9m22s v1.16.9 安装Dashboard(可选)下载文件及修改内容 这里查看dashboard对应的k8s版本 //下载文件 v2.0.0-rc3是中文版本，beta8是英文版本wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yamlwget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc3/aio/deploy/recommended.yaml //修改Service为NodePort类型42行下增加一行nodePort: 30001 44行下增加一行type: NodePort //原先内容spec: ports: - port: 443 targetPort: 8443 selector: k8s-app: kubernetes-dashboard//修改后内容spec: ports: - port: 443 targetPort: 8443 nodePort: 30001 #增加，指定nodeport端口 selector: k8s-app: kubernetes-dashboard type: NodePort #增加，修改类型为nodeport 部署dashboard kubectl apply -f recommended.yaml 查看dashboard的运行状态及外网访问端口 //查看dashboard运行状态#kubectl get pods -n kubernetes-dashboard -l k8s-app=kubernetes-dashboardNAME READY STATUS RESTARTS AGEkubernetes-dashboard-5996555fd8-2ppc5 1/1 Running 0 8m16s//查看dashboard外网访问端口，命名空间为kubernetes-dashboard#kubectl get svc -n kubernetes-dashboard -l k8s-app=kubernetes-dashboardkubectl get svc -n kubernetes-dashboard -l k8s-app=kubernetes-dashboardNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes-dashboard NodePort 10.96.142.172 &lt;none&gt; 443:30001/TCP 8m37s 通过上边的30001端口访问dashboard，注意是https k8s1.16.9这个版本中，使用的dashboard版本是2.0.0-beta8，只有火狐浏览器可以访问，其余浏览器都不能访问，会报错 您的连接不是私密连接 使用火狐浏览器访问，由于 dashboard 默认是自建的 https 证书，该证书是不受浏览器信任的，所以我们需要强制跳转就可以了 然后创建一个具有全局所有权限的用户来登录Dashboard //编辑admin.yaml文件cat &gt; admin.yaml &lt;&lt;EOFkind: ClusterRoleBindingapiVersion: rbac.authorization.k8s.io/v1beta1metadata: name: admin annotations: rbac.authorization.kubernetes.io/autoupdate: &quot;true&quot;roleRef: kind: ClusterRole name: cluster-admin apiGroup: rbac.authorization.k8s.iosubjects:- kind: ServiceAccount name: admin namespace: kube-system---apiVersion: v1kind: ServiceAccountmetadata: name: admin namespace: kube-system labels: kubernetes.io/cluster-service: &quot;true&quot; addonmanager.kubernetes.io/mode: ReconcileEOF//直接创建kubectl apply -f admin.yaml//查看tokenkubectl get secret -n kube-system|grep admin-tokenadmin-token-j7sfh kubernetes.io/service-account-token 3 23s//获取base64解码后的字符串，注意需要用到上边命令查看到的token，会生成很长的一串字符串kubectl get secret admin-token-j7sfh -o jsonpath=&#123;.data.token&#125; -n kube-system |base64 -d#直接用这条命令搞定kubectl get secret `kubectl get secret -n kube-system|grep admin-token|awk &#x27;&#123;print $1&#125;&#x27;` -o jsonpath=&#123;.data.token&#125; -n kube-system |base64 -d &amp;&amp; echo 到此，使用kubeadm安装k8s 1.16.9完成！！！ 参考在 Kubernetes集群中 安装 KubeSphere2.1","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"kubernetes","slug":"kubernetes","permalink":"https://luckyship.github.io/tags/kubernetes/"},{"name":"centos","slug":"centos","permalink":"https://luckyship.github.io/tags/centos/"}]},{"title":"linux连接蓝牙的方法","date":"2020-05-10T16:00:00.000Z","path":"2020/05/11/2020-05-11-linux-connect-blueteeth/","text":"连接蓝牙首先确定有蓝牙设备，没有去网上购买蓝牙发射器 $ lsusbBus 002 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 001 Device 004: ID 17ef:608d LenovoBus 001 Device 003: ID 0a12:0001 Cambridge Silicon Radio, Ltd Bluetooth Dongle (HCI mode)Bus 001 Device 002: ID 17ef:6099 LenovoBus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub 然后运行激活蓝牙设备 $ hciconfighci0: Type: Primary Bus: USB BD Address: 00:1A:7D:DA:71:11 ACL MTU: 310:10 SCO MTU: 64:8 UP RUNNING PSCAN RX bytes:1009522 acl:55943 sco:0 events:201 errors:0 TX bytes:4712 acl:49 sco:0 commands:90 errors:0$ sudo hciconfig hci0 up 使用bluetoothctl去连接蓝牙 $ bluetoothctl[bluetooth]# scan on 开始扫描[bluetooth]# pair 01:02:03:04:05:06 后面的mac地址是你的键盘mac地址[bluetooth]# trust 01:02:03:04:05:06 把键盘设置为可信设备[bluetooth]# connect 01:02:03:04:05:06 进行对接 参考Linux下的蓝牙键盘对接在Linux系统中使用蓝牙功能的基本方法","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"}]},{"title":"docker的http代理","date":"2019-10-28T16:00:00.000Z","path":"2019/10/29/2019-10-29-proxy-of-docker/","text":"步骤解决代理的方法，参考官网教程https://docs.docker.com/config/daemon/systemd/#httphttps-proxy 创建文件夹sudo mkdir -p /etc/systemd/system/docker.service.d 创建配置文件cd /etc/systemd/system/docker.service.dtouch http-proxy.conf 在http-proxy.conf中添加http代理[Service] Environment=&quot;HTTP_PROXY=http://proxy.example.com:80/&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot; 更新，使配置文件生效sudo systemctl daemon-reload 重启docker服务sudo systemctl restart docker 检查配置是否生效$ systemctl show --property=Environment docker docker换源、设置私有镜像仓库[root@k8s-master ~]# cat /etc/docker/daemon.json&#123; &quot;registry-mirrors&quot;: [&quot;https://gqk8w9va.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;:[&quot;193.160.60.94&quot;]&#125; 转载配置Docker的HTTP代理","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"docker","slug":"docker","permalink":"https://luckyship.github.io/tags/docker/"}]},{"title":"css中的百分比","date":"2019-10-21T16:00:00.000Z","path":"2019/10/22/2019-10-22-percentage-of-css/","text":"css中的百分比CSS支持多种单位形式，如百分比、px、pt、rem等，百分比和px是常用的单位，随着移动端和响应式的流行，rem、vh、vw也开始普遍使用。那么元素的百分比到底是怎样计算出来的？ margin, padding&lt;div style=&quot;width: 20px&quot;&gt; &lt;div id=&quot;temp1&quot; style=&quot;margin-top: 50%&quot;&gt;Test top&lt;/div&gt; &lt;div id=&quot;temp2&quot; style=&quot;margin-right: 25%&quot;&gt;Test right&lt;/div&gt; &lt;div id=&quot;temp3&quot; style=&quot;margin-bottom: 75%&quot;&gt;Test bottom&lt;/div&gt; &lt;div id=&quot;temp4&quot; style=&quot;margin-left: 100%&quot;&gt;Test left&lt;/div&gt;&lt;/div&gt; 得到的offset如下： temp1.marginTop = 20px * 50% = 10px;temp2.marginRight = 20px * 25% = 5px;temp3.marginBottom = 20px * 75% = 15px;temp4.marginLeft = 20px * 100% = 20px; 当按百分比设定一个元素的宽度时，它是相对于父容器的宽度计算的， 元素竖向的百分比设定也是相对于容器的宽度，而不是高度 定位元素 top&lt;div style=&quot;height: 100px; width: 50px&quot;&gt; &lt;div id=&quot;temp1&quot; style=&quot;position: relative; top: 50%&quot;&gt;Test top&lt;/div&gt; &lt;div id=&quot;temp2&quot; style=&quot;position: relative; right: 25%&quot;&gt;Test right&lt;/div&gt; &lt;div id=&quot;temp3&quot; style=&quot;position: relative; bottom: 75%&quot;&gt;Test bottom&lt;/div&gt; &lt;div id=&quot;temp4&quot; style=&quot;position: relative; left: 100%&quot;&gt;Test left&lt;/div&gt;&lt;/div&gt; 得到的offset如下： temp1.top = 100px * 50% = 50px;temp2.right = 50px * 25% = 12.5px;temp3.bottom = 100px * 75% = 75px;temp4.left = 50px * 100% = 50px; 所以，可以看到，当为定位元素时，top、bottom、right、left是按父元素对应的宽度和高度计算的。 补充当我们改变书写模式为垂直的时候，margin等的参照就变为高度了 #demo &#123; -webkit-writing-mode: vertical-rl; /* for browsers of webkit engine */ writing-mode: tb-rl; /* for ie */&#125; 你是否觉得这不符合常规的感性认知？感性认知更多感觉应该横向参照包含块宽度，纵向参照包含块高度。其实这是为了要横向和纵向2个方向都创建相同的 margin，如果它们的参照物不一致，那就无法得到两个方向相同的留白。 你可能会问那为什么要选择宽度做参照而不是高度呢？这其实更多的要从 CSS 设计意图上去想，因为CSS的基础需求是排版，而通常我们所见的横排文字，其水平宽度一定（仔细回想一下，如果没有显式的定义宽度或者强制一行显示，都会遇到边界换行，而不是水平延展），垂直方向可以无限延展。但当书写模式为纵向时，其参照就变成了高度而不再是宽度了。 参考css中的百分比计算方法","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"mongo","slug":"mongo","permalink":"https://luckyship.github.io/tags/mongo/"},{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"}]},{"title":"flex布局","date":"2019-05-26T16:00:00.000Z","path":"2019/05/27/2019-05-27-flex布局/","text":"flex布局是什么Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为Flex布局。 //块元素.box &#123; display: flex;&#125;//行内元素.box &#123; display: inline-flex;&#125;//webkit内核浏览器(chrome, safari).box &#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1、flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。row-reverse：主轴为水平方向，起点在右端。column：主轴为垂直方向，起点在上沿。column-reverse：主轴为垂直方向，起点在下沿。 2、flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 3、flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; 4、justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5、align-items属性align-items属性定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 6、align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 1、order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 2、flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3、flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。 4、flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5、flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item &#123; flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt;]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6、align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 flex中的margin实现一个元素在左侧，另外2个元素在右侧 &lt;style type=&#x27;text/css&#x27;&gt; .wrap &#123; text-align: center; display: flex; justify-content: space-between; &#125; .div &#123; border: 1px solid red; width: 200px; &#125; .right &#123; margin-left: auto; &#125;&lt;/style&gt;&lt;div class=&#x27;wrap&#x27;&gt; &lt;div class=&#x27;div&#x27;&gt;test&lt;/div&gt; &lt;div class=&#x27;div right&#x27;&gt;test&lt;/div&gt; &lt;div class=&#x27;div&#x27;&gt;test&lt;/div&gt;&lt;/div&gt; 参考阮一峰教程","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"css 居中","date":"2019-05-21T16:00:00.000Z","path":"2019/05/22/2019-05-22-css居中详解/","text":"css中有很多不同的居中方法，适应不同的情况，下面简单介绍几种常见的： 1. 文字居中, 边距居中这种居中方法一般使用较多。 text-align: center 规定文字居中， margin: 0 auto 规定水平居中。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap &#123; text-align: center; &#125; .div &#123; margin: 0 auto; border: 1px solid red; width: 200px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 绝对定位居中用于没有父元素包裹，需要居中的元素是绝对定位。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap .div &#123; width: 10%; height: 60%; border: 1px solid red; margin: auto; position: absolute; top: 0; left: 0; bottom: 0; right: 0; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 总结上述都需要 margin:auto ，这是利用了 margin 把元素在页面上的剩余位置用边距填满，为边距赋统一值 auto ，这样就可以使元素2边相等。如果元素的 width:100% ，那么这个元素就相当于居中，如果 width 不等于100%，就可以用 margin 把剩下的位置填满, 因为 margin 也是盒子模型中的成员，所以它在盒子中占据空间和 width:100% 一样。 3. table-cell利用表格中 vertical-align: middle 可以垂直居中的特性，使用方便。不过这种方法的水平居中有局限性，内部元素不可以设置宽度 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap &#123; display: table-cell; vertical-align: middle; text-align: center; width: 100px; height: 100px; border: 1px solid red; &#125; .div &#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4. 绝对定位和负边距这种方法本质上是使用计算解决偏离的问题，但只能用于居中元素确定宽度和高度。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div &#123; position: absolute; width: 100px; height: 50px; top: 50%; left: 50%; margin-left: -50px; margin-top: -25px; text-align: center; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 5. css3 translate原理和上一种方法一样，但是没有宽度的限制。不过与其他css3技术一样，可能需要解决兼容问题。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .div &#123; position: absolute; top:50%; left:50%; width:100px; transform:translate(-50%,-50%); text-align: center; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6. display:flex代码量最少的方法，不过父元素宽、高需要确定。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap &#123; height: 100px; width: 100px; border: 1px solid red; display: flex; justify-content:center; align-items:center; &#125; .div &#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 下面是一些不常见的方法，用于拓展 7. 通过伪元素:after占位&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap &#123; text-align:center; font-size:0; &#125; .wrap:after &#123; content:&#x27;&#x27;; width:0; height:100%; display:inline-block; vertical-align:middle; &#125; .div &#123; vertical-align:middle; display:inline-block; font-size:16px; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 8. display:-webkit-box利用了css3的属性 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;center&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .wrap &#123; display: -webkit-box; -webkit-box-pack:center; -webkit-box-align:center; -webkit-box-orient: vertical; text-align: center; &#125; .div &#123; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;div&quot;&gt;test&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"css","slug":"css","permalink":"https://luckyship.github.io/tags/css/"}]},{"title":"js 事件委托机制","date":"2019-05-07T16:00:00.000Z","path":"2019/05/08/2019-05-08-js事件委托机制/","text":"概述那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。举个列子：有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 应用场景 提高性能比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件。这是我们通常的做法，这不仅很low，而且会严重影响页面的性能，事件的数量直接影响页面渲染时需要的时间，所以我们可以利用事件委托来解决这个问题。 为不存在元素创建事件当需要为动态创建的元素添加事件时，初学者都会再元素上添加 onclick() 事件，在指向对应的函数。这种方法不够简洁明了。 实例这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题） window.onload = function() &#123; var oUl = document.getElementById(&quot;ul1&quot;); oUl.onclick = function(ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (target.nodeName.toLowerCase() == &#x27;li&#x27;) &#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 在jquery中on的事件绑定也用到了委托机制 $(&#x27;ele&#x27;).on(&#x27;click&#x27;, &#x27;div&#x27;, callback) 第二个参数是指为选中元素下的div子元素绑定事件，这里的功能和我们的事件委托机制很像 参考js中的事件委托或是事件代理详解","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"Git 环境配置","date":"2019-04-02T16:00:00.000Z","path":"2019/04/03/2019-04-03-git环境配置/","text":"配置name, email等$ cat ~/.gitconfig[user] email = chaox.a.xu@intel.com name = Xu Chao[core] editor = vim -U none # git commit -sv 可以用vim 使用ssh clone代码git clone ssh://user@host/path","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"git","slug":"git","permalink":"https://luckyship.github.io/tags/git/"}]},{"title":"Ruby open3 死锁","date":"2019-03-28T16:00:00.000Z","path":"2019/03/29/2019-03-29-ruby-open3死锁/","text":"open3死锁根据open3的死锁条件，当需要构建大量输出在stderr中，open3就会死锁。 stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts]) 我遇到的情况是stdout的输出内容较多，所以推测如果有错的话，stderr也会有大量输出，这样就会造成open3死锁。 解决根据官方文档提示，需要同时读取stderr和stdout，我们使用 IO.select 实现 inp,out,err = open3(&quot;process&quot;,&quot;args&quot;)inp.close # we pass everything via command-line, so close child&#x27;s stdin at oncestill_open = [out,err] # Array that only contains the opened streamswhile not still_open.empty? fhs = select(still_open,nil,nil,nil) # wait for data available in the pipes # fhs[0] is an array that contains filehandlers we can read from if fhs[0].include? out begin printf(&quot;%s&quot;,out.readline()) rescue EOFError # If we have read everything from the pipe # Remove out from the list of open pipes still_open.delete_if &#123;|s| s==out&#125; end end if fhs[0].include? err begin printf(&quot;ERROR: %s&quot;,err.readline()) rescue EOFError # If we have read everything from the pipe # Remove err from the list of open pipes still_open.delete_if &#123;|s| s==err&#125; end endend 参考open3定义避免open3死锁的方法","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"}]},{"title":"Ruby Rails 学习资料","date":"2019-03-19T16:00:00.000Z","path":"2019/03/20/2019-03-20-Ruby-Rails学习资料/","text":"Ruby入门教程Ruby 教程 Ruby Rails Api 检索Ruby开发文档 Ruby On RailsRuby On Rails指南（中文）","updated":"2025-08-02T05:46:04.172Z","tags":[{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"},{"name":"base","slug":"base","permalink":"https://luckyship.github.io/tags/base/"},{"name":"rails","slug":"rails","permalink":"https://luckyship.github.io/tags/rails/"}]},{"title":"ruby 基本知识","date":"2019-03-18T16:00:00.000Z","path":"2019/03/19/2019-03-19-ruby基本知识/","text":"slice clear collect map compact concat delete(delete_if) each empty? eql? flatten include? insert join pop push reject replace reverse select shift sort uniq unshift 补充 first last sub gsub group_by round inject partition strip start_with? to_a, to_i, to_s merge flat_map rjust negative?, positive?, zero? max, min all，any，every 参考ruby api查找","updated":"2025-08-02T05:46:04.171Z","tags":[{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"},{"name":"base","slug":"base","permalink":"https://luckyship.github.io/tags/base/"}]},{"title":"使用privoxy搭建代理服务器","date":"2019-03-14T16:00:00.000Z","path":"2019/03/15/2019-03-12-代理服务器的搭建/","text":"安装privoxyyum install -y epel-releaseyum install -y privoxy 修改配置文件vim /etc/privoxy/config 修改ip(此处为你想作为代理的服务器的ip) listen-address 127.0.0.1:8118 启动# 启动systemctl start privoxy# 开机启动systemctl enable privoxy 参考https://www.cnblogs.com/straycats/p/8452354.html","updated":"2025-08-02T05:46:04.171Z","tags":[{"name":"linux","slug":"linux","permalink":"https://luckyship.github.io/tags/linux/"},{"name":"network","slug":"network","permalink":"https://luckyship.github.io/tags/network/"}]},{"title":"DataTable搜索框，正则匹配规则","date":"2019-03-11T16:00:00.000Z","path":"2019/03/12/2019-03-12-DataTable使用正则/","text":"DataTable 中的 search 搜索框功能非常强大，可以匹配表格中的任意数据。不仅如此 DataTable 还提供了 regex 选项可以使用正则表达式。 $(&#x27;#example&#x27;).dataTable( &#123; &quot;search&quot;: &#123; &quot;regex&quot;: true &#125;&#125; ); 值的一提的是，DataTable搜索结果以行显示，那么每一行是怎么匹配正则的？ 每一行代表的字符串是以2个空格将没一列连成一个字符串 例如： example1 example2 example3 a c d e f g h i j 如果我们在输入框中输入: ^a c d 即可匹配到第一行 如果想要更多的验证DataTable的正则匹配规则，可以点击连接验证","updated":"2025-08-02T05:46:04.171Z","tags":[{"name":"dataTable","slug":"dataTable","permalink":"https://luckyship.github.io/tags/dataTable/"},{"name":"web","slug":"web","permalink":"https://luckyship.github.io/tags/web/"},{"name":"javascript","slug":"javascript","permalink":"https://luckyship.github.io/tags/javascript/"}]},{"title":"mongodb索引","date":"2019-03-04T16:00:00.000Z","path":"2019/03/05/2019-03-05-数据库/","text":"索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构 实例&gt;db.col.createIndex(&#123;&quot;title&quot;:1&#125;)&gt; api方法1、查看集合索引 db.col.getIndexes() 2、查看集合索引大小 db.col.totalIndexSize() 3、删除集合所有索引 db.col.dropIndexes() 4、删除集合指定索引 db.col.dropIndex(“索引名称”) 参考http://www.runoob.com/mongodb/mongodb-indexing.html","updated":"2025-08-02T05:46:04.171Z","tags":[{"name":"mongo","slug":"mongo","permalink":"https://luckyship.github.io/tags/mongo/"},{"name":"ruby","slug":"ruby","permalink":"https://luckyship.github.io/tags/ruby/"}]}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <script src="/js/av-min.js"></script>

  <script>
    AV.init({
      appId: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      appKey: 'fstd3ABXC89jc5VDSe6ANGV6',
      serverURLs: {
        push: "https://leancloud.cn",
        stats: "https://leancloud.cn",
        engine: "https://leancloud.cn",
        api: "https://leancloud.cn",
      },
    });
  </script>
  <script async src="/main/js/slider.66b399.js"></script><script async src="/main/js/main.a76a5f.js"></script><script async src="/main/js/mobile.57dfe3.js"></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-GWM1JLMFWH"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-GWM1JLMFWH")</script>

  <link rel="dns-prefetch" href="https://luckyship.github.io">
  <title>Vue原理 | luckyship</title>
  <meta name="generator" content="hexo-theme-luckyship">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="description" content="vue 双向绑定原理 【原理题】  核心实现类:Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新 Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。 Watcher : 观察者">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue原理">
<meta property="og:url" content="https://luckyship.github.io/2022/07/16/2022-07-16-vue-theory/index.html">
<meta property="og:site_name" content="luckyship">
<meta property="og:description" content="vue 双向绑定原理 【原理题】  核心实现类:Observer : 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新 Dep : 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。 Watcher : 观察者">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/002.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/003.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/004.png">
<meta property="og:image" content="https://luckyship.github.io/img/vue-interview/005.png">
<meta property="article:published_time" content="2022-07-16T06:55:26.000Z">
<meta property="article:modified_time" content="2025-08-02T05:46:04.180Z">
<meta property="article:author" content="luckyship">
<meta property="article:tag" content="javascript">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://luckyship.github.io/img/vue-interview/002.png">
  
    <link rel="alternative" href="/atom.xml" title="luckyship" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  
    <link rel="apple-touch-icon" href="/apple-touch-icon-180x180.png">
  
  <link rel="stylesheet" type="text/css" href="/main/css/index.a76a5f.css">
  <style type="text/css">
    
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

  
    
 	  <script async src="/lib/clickLove.js"></script>
  
  

<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();

</script>



  

</head>


<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      


<div class="overlay" style="background: #4d4d4d;"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/head.jpg" class="js-avatar">
		</a>
		<hgroup>
			<h1 class="header-author"><a href="/">luckyship</a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/" >主页</a></li>
			
				<li><a href="/archives" >归档</a></li>
			
				<li><a href="/comment/" >留言板</a></li>
			
				<li><a href="/website/" >知识库</a></li>
			
			</ul>
		</nav>
		<nav class="header-smart-menu">
			
				
					<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">搜索</a>
				
			
				
					<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
				
			
            </nav>

		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" rel="noopener" href="https://github.com/luckyship" title="GitHub" ><i class="icon-github"></i></a>
				
					<a class="gitee" target="_blank" rel="noopener" href="https://gitee.com/luckyship" title="gitee" ><i class="icon-gitee"></i></a>
				
					<a class="blog" target="_blank" rel="noopener" href="https://juejin.cn/user/730534951787662/posts" title="blog" ><i class="icon-blog"></i></a>
				
					<a class="csdn" target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_38319625" title="CSDN" ><i class="icon-csdn"></i></a>
				
			</div>
		
		</nav>

		
		  <nav>
			
  <div id="toc" class="toc-article">
    <div class="toc-title">目录</div>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">1.</span> <span class="toc-text">vue 双向绑定原理 【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">2.</span> <span class="toc-text">computed 的实现原理【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-%E5%92%8C-watch-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%8F%8A%E8%BF%90%E7%94%A8%E5%9C%BA%E6%99%AF-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">3.</span> <span class="toc-text">computed 和 watch 有什么区别及运用场景?【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-Vue3-0-%E9%87%87%E7%94%A8%E4%BA%86-Proxy-%E6%8A%9B%E5%BC%83%E4%BA%86-Object-defineProperty%EF%BC%9F%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">4.</span> <span class="toc-text">为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E4%B8%AD%E7%9A%84-key-%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">5.</span> <span class="toc-text">Vue 中的 key 到底有什么用？【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E8%B0%88-nextTick-%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">6.</span> <span class="toc-text">谈一谈 nextTick 的原理【原理题】</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-dom-%E6%9B%B4%E6%96%B0%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E5%86%8D%E6%89%A7%E8%A1%8C-nextTick-%E5%90%8E%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">如何判断 dom 更新完成后，再执行 nextTick 后的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AF%B9%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E5%8F%98%E5%BC%82%E7%9A%84-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">7.</span> <span class="toc-text">vue 是如何对数组方法进行变异的 ?【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%BB%84%E4%BB%B6-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%87%BD%E6%95%B0-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">8.</span> <span class="toc-text">Vue 组件 data 为什么必须是函数 ?【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88-Vue-%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6-%E6%89%8B%E5%86%99-on-off-emit-once-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">9.</span> <span class="toc-text">谈谈 Vue 事件机制,手写$on,$off,$emit,$once 【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-Vue-%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">10.</span> <span class="toc-text">说说 Vue 的渲染过程 【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%8A%E8%81%8A-keep-alive-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">11.</span> <span class="toc-text">聊聊 keep-alive 的实现原理和缓存策略 【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vm-set-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88-%E3%80%90%E5%8E%9F%E7%90%86%E9%A2%98%E3%80%91"><span class="toc-number">12.</span> <span class="toc-text">vm.$set()实现原理是什么? 【原理题】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-use-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">Vue.use 方法的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">Vuex 的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8-mutation-%E4%B8%AD%E4%BF%AE%E6%94%B9-state"><span class="toc-number">14.1.</span> <span class="toc-text">为什么一定要用 mutation 中修改 state</span></a></li></ol></li></ol>
  </div>


		  </nav>
		
	</header>
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
      
      <a class="forkMe" style="position:absolute;z-index:999;top:0;right:0.5em;"
        href="https://github.com/luckyship/myblog" target="_blank">
        <img src="/img/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
      
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<a href="/">
					<img src="/img/head.jpg" class="js-avatar">
				</a>
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">luckyship</h1>
			</hgroup>
			
			
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/luckyship" title="GitHub"><i class="icon-github"></i></a>
			        
						<a class="gitee" target="_blank" href="https://gitee.com/luckyship" title="gitee"><i class="icon-gitee"></i></a>
			        
						<a class="blog" target="_blank" href="https://juejin.cn/user/730534951787662/posts" title="blog"><i class="icon-blog"></i></a>
			        
						<a class="csdn" target="_blank" href="https://blog.csdn.net/sinat_38319625" title="CSDN"><i class="icon-csdn"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 25%"><a href="/">主页</a></li>
		        
					<li style="width: 25%"><a href="/archives">归档</a></li>
		        
					<li style="width: 25%"><a href="/comment/">留言板</a></li>
		        
					<li style="width: 25%"><a href="/website/">知识库</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1"
              class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            <article id="post-2022-07-16-vue-theory" class="article article-type-post " itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
  
  
    <h1 class="article-title" itemprop="name">
      Vue原理
    </h1>
  


  
   
<span id="busuanzi_container_page_pv" style="display: none" class="archive-article-date">
  <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
</span>


<a href="/2022/07/16/2022-07-16-vue-theory/" class="archive-article-date">
  <!-- <time datetime="2022-07-16T06:55:26.000Z" title="发布时间" itemprop="datePublished"><i class="icon-calendar icon"></i>2022-07-16</time>
        <time datetime="2025-08-02T05:46:04.180Z" title="最后更新" itemprop="datePublished">
                <svg t="1614416122145" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="535" width="16" height="16"><path d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z" p-id="536" fill="#999999"></path><path d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z" p-id="537" fill="#999999"></path></svg>
                2025-08-02</time> -->

  
  <time datetime="2025-08-02T05:46:04.180Z" title="最后更新" itemprop="datePublished">
    <svg
      t="1614416122145"
      viewBox="0 0 1024 1024"
      version="1.1"
      xmlns="http://www.w3.org/2000/svg"
      p-id="535"
      width="16"
      height="16"
    >
      <path
        d="M887.786 1021.4h-757.804c-69.761 0-126.276-56.637-126.276-126.397v-758.23c0-69.822 57.419-132.402 127.121-132.402h508.511v63.547h-508.511c-34.85 0-63.968 33.886-63.968 68.854v758.262c0 34.91 28.273 63.212 63.094 63.212h757.835c34.82 0 69.341-29.058 69.341-63.968v-508.512h63.605v508.486c0 69.853-63.242 127.153-132.946 127.153z"
        p-id="536"
        fill="#999999"
      ></path>
      <path
        d="M969.708 166.041l-111.61-111.673c-24.682-24.68-64.635-24.68-89.315 0l-491.163 491.497c-9.234 9.23-13.849 20.849-16.143 32.768l-136.716 276.63c-11.434 31.109 13.516 59.050 44.597 44.659l276.51-136.776c11.919-2.355 23.505-6.942 32.676-16.172l491.163-491.558c24.653-24.68 24.653-64.691 0-89.374zM207.56 839.423c-15.541 7.148-29.57-7.755-22.297-22.33l103.345-170.842 89.676 89.706-170.722 103.465zM433.89 702.284c-41.852-41.88-99.755-99.843-111.612-111.73l356.441-356.649 112.426 110.946-357.254 357.434zM902.756 233.086l-66.984 67.046-110.013-113.303 65.388-65.445c12.279-12.312 32.347-12.312 44.626 0l66.986 67.015c12.311 12.402 12.311 32.375 0 44.687z"
        p-id="537"
        fill="#999999"
      ></path>
    </svg>
    <span >
      2022-07-16
      <span style="font-size: 10px"> (更新于2025-08-02)
    </span>
  </time>
  
</a>

  
  
    
<div style="margin-top:10px;">
  <span class="post-time">
    <span class="post-meta-item-icon">
      <!-- fonts.scss -->
      <!-- 百度字体平台:http://fontstore.baidu.com/static/editor/index.html -->
      <i class="icon-statistics"></i>
      <span class="post-meta-item-text"> 字数统计:</span>
      <span class="post-count">5.2k字</span>
    </span>
  </span>

  <span class="post-time">
    &nbsp; | &nbsp;
    <span class="post-meta-item-icon">
      <i class="icon-book icon"></i>
      <span class="post-meta-item-text"> 阅读时长≈</span>
      <span class="post-count">21分</span>
    </span>
  </span>
</div>


  
  </header>
  
  <div class="article-entry" itemprop="articleBody">
    
    <h3 id="vue-双向绑定原理-【原理题】"><a href="#vue-双向绑定原理-【原理题】" class="headerlink" title="vue 双向绑定原理 【原理题】"></a>vue 双向绑定原理 【原理题】</h3><img src="/img/vue-interview/002.png" style="zoom:50%;" />

<p>核心实现类:<br><strong>Observer :</strong> 它的作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新</p>
<p><strong>Dep :</strong> 用于收集当前响应式对象的依赖关系,每个响应式对象包括子对象都拥有一个 Dep 实例（里面 subs 是 Watcher 实例数组）,当数据有变更时,会通过 dep.notify()通知各个 watcher。</p>
<p><strong>Watcher :</strong> 观察者对象 , 实例分为渲染 watcher (render watcher),计算属性 watcher (computed watcher),侦听器 watcher（user watcher）三种</p>
<span id="more"></span>

<p><strong>Watcher 和 Dep 的关系</strong><br>watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。</p>
<p><strong>依赖收集</strong><br>initState 时,对 computed 属性初始化时,触发 computed watcher 依赖收集<br>initState 时,对侦听属性初始化时,触发 user watcher 依赖收集<br>render()的过程,触发 render watcher 依赖收集<br>re-render 时,vm.render()再次执行,会移除所有 subs 中的 watcer 的订阅,重新赋值。<br><strong>派发更新</strong><br>组件中对响应的数据进行了修改,触发 setter 的逻辑<br>调用 dep.notify()<br>遍历所有的 subs（Watcher 实例）,调用每一个 watcher 的 update 方法。<br><strong>原理</strong><br><u>当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。</u></p>
<p><u>每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。</u></p>
<p>一句话总结:</p>
<p><strong>vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调</strong></p>
<p><a href="/2021/08/19/2021-08-19-min-vue/">自己实现一个 Vue 的双向绑定</a></p>
<h3 id="computed-的实现原理【原理题】"><a href="#computed-的实现原理【原理题】" class="headerlink" title="computed 的实现原理【原理题】"></a>computed 的实现原理【原理题】</h3><p>computed 本质是一个惰性求值的观察者。</p>
<p>computed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。</p>
<p>其内部通过 this.dirty 属性标记计算属性是否需要重新求值。</p>
<p>当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,</p>
<p>computed watcher 通过 this.dep.subs.length 判断有没有订阅者,</p>
<p>有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)</p>
<p>没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)</p>
<h3 id="computed-和-watch-有什么区别及运用场景-【原理题】"><a href="#computed-和-watch-有什么区别及运用场景-【原理题】" class="headerlink" title="computed 和 watch 有什么区别及运用场景?【原理题】"></a>computed 和 watch 有什么区别及运用场景?【原理题】</h3><ul>
<li><p>区别</p>
<ul>
<li><p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。 【简单表达： 依赖缓存，依赖的值变化了才会自动变化】</p>
</li>
<li><p>watch 侦听器 : 更多的是「观察」的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。 【简单表达：watch 监听数变化，无缓存依赖，监听的值变化了他就变化】</p>
</li>
</ul>
</li>
<li><p>运用场景</p>
<ul>
<li><code>当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,</code>因为可以利用 computed 的缓存特性,避免每次获取值时,都要重新计算。 【不能放异步】</li>
<li><code>当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,</code>使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。 【可以放异步处理】</li>
</ul>
</li>
</ul>
<h3 id="为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？【原理题】"><a href="#为什么在-Vue3-0-采用了-Proxy-抛弃了-Object-defineProperty？【原理题】" class="headerlink" title="为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？【原理题】"></a>为什么在 Vue3.0 采用了 Proxy,抛弃了 Object.defineProperty？【原理题】</h3><p>Object.defineProperty 本身有一定的监控到数组下标变化的能力,但是在 Vue 中,从性能/体验的性价比考虑,尤大大就弃用了这个特性(Vue 为什么不能检测数组变动 )。为了解决这个问题,经过 vue 内部处理后可以使用以下几种方法来监听数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">push</span>();<br><span class="hljs-title function_">pop</span>();<br><span class="hljs-title function_">shift</span>();<br><span class="hljs-title function_">unshift</span>();<br><span class="hljs-title function_">splice</span>();<br><span class="hljs-title function_">sort</span>();<br><span class="hljs-title function_">reverse</span>();<br></code></pre></td></tr></table></figure>

<p>由于只针对了以上 7 种方法进行了 hack 处理,所以其他数组的属性也是检测不到的,还是具有一定的局限性。</p>
<p>**Object.defineProperty 只能劫持对象的属性,**因此我们需要对每个对象的每个属性进行遍历。<u>Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。</u><br>Proxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。</p>
<h3 id="Vue-中的-key-到底有什么用？【原理题】"><a href="#Vue-中的-key-到底有什么用？【原理题】" class="headerlink" title="Vue 中的 key 到底有什么用？【原理题】"></a>Vue 中的 key 到底有什么用？【原理题】</h3><p>回答： 【简单表达：<strong>为了防止就地复用！</strong>】</p>
<p>key 是给每一个 vnode 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (<u>对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。</u>)</p>
<p><strong>diff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点.</strong></p>
<p>更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。</p>
<p>更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1),源码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createKeyToOldIdx</span>(<span class="hljs-params">children, beginIdx, endIdx</span>) &#123;<br>  <span class="hljs-keyword">let</span> i, key;<br>  <span class="hljs-keyword">const</span> map = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;<br>    key = children[i].<span class="hljs-property">key</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_">isDef</span>(key)) map[key] = i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="谈一谈-nextTick-的原理【原理题】"><a href="#谈一谈-nextTick-的原理【原理题】" class="headerlink" title="谈一谈 nextTick 的原理【原理题】"></a>谈一谈 nextTick 的原理【原理题】</h3><p><strong>JS 运行机制</strong></p>
<p>JS 执行是单线程的，它是基于事件循环的。事件循环大致分为以下几个步骤:</p>
<p>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。<br>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。<br>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。<br>主线程不断重复上面的第三步。</p>
<img src="/img/vue-interview/003.png" style="zoom:40%;" />
主线程的执行过程就是一个 tick，而所有的异步结果都是通过 “任务队列” 来调度。 消息队列中存放的是一个个的任务（task）。 规范中规定 task 分为两大类，分别是 macro task 和 micro task，并且每个 macro task 结束后，都要清空所有的 micro task。

<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (macroTask <span class="hljs-keyword">of</span> macroTaskQueue) &#123;<br>  <span class="hljs-comment">// 1. Handle current MACRO-TASK</span><br>  <span class="hljs-title function_">handleMacroTask</span>();<br>  <span class="hljs-comment">// 2. Handle all MICRO-TASK</span><br>  <span class="hljs-keyword">for</span> (microTask <span class="hljs-keyword">of</span> microTaskQueue) &#123;<br>    <span class="hljs-title function_">handleMicroTask</span>(microTask);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在浏览器环境中 :</p>
<p>常见的 macro task 有 setTimeout、MessageChannel、postMessage、setImmediate</p>
<p>常见的 micro task 有 MutationObsever 和 Promise.then</p>
<p><strong>异步更新队列</strong></p>
<p>可能你还没有注意到，Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。</p>
<p>然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。</p>
<p>Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p>
<p><strong>在 vue2.5 的源码中，macrotask 降级的方案依次是：setImmediate、MessageChannel、setTimeout</strong></p>
<p><strong><u>vue 的 nextTick 方法的实现原理:</u></strong></p>
<p>vue 用异步队列的方式来控制 DOM 更新和 nextTick 回调先后执行 microtask 因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕考虑兼容问题,vue 做了 microtask 向 macrotask 的降级方案</p>
<h4 id="如何判断-dom-更新完成后，再执行-nextTick-后的函数"><a href="#如何判断-dom-更新完成后，再执行-nextTick-后的函数" class="headerlink" title="如何判断 dom 更新完成后，再执行 nextTick 后的函数"></a>如何判断 dom 更新完成后，再执行 nextTick 后的函数</h4><p>实际上 dom 更新是实时的，所以不会阻塞，使用微任务后，可以保证所执行的方法在 dom 更新后</p>
<h3 id="vue-是如何对数组方法进行变异的-【原理题】"><a href="#vue-是如何对数组方法进行变异的-【原理题】" class="headerlink" title="vue 是如何对数组方法进行变异的 ?【原理题】"></a>vue 是如何对数组方法进行变异的 ?【原理题】</h3><p>我们先来看看源码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arrayProto = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> arrayMethods = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(arrayProto);<br><span class="hljs-keyword">const</span> methodsToPatch = [<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>, <span class="hljs-string">&#x27;sort&#x27;</span>, <span class="hljs-string">&#x27;reverse&#x27;</span>];<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br><br>methodsToPatch.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) &#123;<br>  <span class="hljs-comment">// cache original method</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method];<br>  <span class="hljs-title function_">def</span>(arrayMethods, method, <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutator</span>(<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__ob__</span>;<br>    <span class="hljs-keyword">let</span> inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;push&#x27;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;unshift&#x27;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;splice&#x27;</span>:<br>        inserted = args.<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inserted) ob.<span class="hljs-title function_">observeArray</span>(inserted);<br>    <span class="hljs-comment">// notify change</span><br>    ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Observe a list of Array items.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title class_">Observer</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">observeArray</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">observeArray</span>(<span class="hljs-params">items</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = items.<span class="hljs-property">length</span>; i &lt; l; i++) &#123;<br>    <span class="hljs-title function_">observe</span>(items[i]);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>简单来说,Vue 通过原型拦截的方式重写了数组的 7 个方法,首先获取到这个数组的 ob,也就是它的 Observer 对象,如果有新的值,就调用 observeArray 对新的值进行监听,然后手动调用 notify,通知 render watcher,执行 update</p>
<h3 id="Vue-组件-data-为什么必须是函数-【原理题】"><a href="#Vue-组件-data-为什么必须是函数-【原理题】" class="headerlink" title="Vue 组件 data 为什么必须是函数 ?【原理题】"></a>Vue 组件 data 为什么必须是函数 ?【原理题】</h3><p>new Vue()实例中,data 可以直接是一个对象,为什么在 vue 组件中,data 必须是一个函数呢?<br>因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。</p>
<p>所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。</p>
<h3 id="谈谈-Vue-事件机制-手写-on-off-emit-once-【原理题】"><a href="#谈谈-Vue-事件机制-手写-on-off-emit-once-【原理题】" class="headerlink" title="谈谈 Vue 事件机制,手写$on,$off,$emit,$once 【原理题】"></a>谈谈 Vue 事件机制,手写$on,$off,$emit,$once 【原理题】</h3><p>Vue 事件机制 本质上就是 一个 发布-订阅 模式的实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vue</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//  事件通道调度中心</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>  &#125;<br>  $on(event, fn) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;<br>      event.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.$on(item, fn);<br>      &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span>[event] || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span>[event] = [])).<span class="hljs-title function_">push</span>(fn);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>  $once(event, fn) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">on</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.$off(event, on);<br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>    on.<span class="hljs-property">fn</span> = fn;<br>    <span class="hljs-variable language_">this</span>.$on(event, on);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br><br>  $off(event, fn) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(event)) &#123;<br>      event.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">this</span>.$off(item, fn);<br>      &#125;);<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">const</span> cbs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span>[event];<br>    <span class="hljs-keyword">if</span> (!cbs) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!fn) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span>[event] = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> cb;<br>    <span class="hljs-keyword">let</span> i = cbs.<span class="hljs-property">length</span>;<br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>      cb = cbs[i];<br>      <span class="hljs-keyword">if</span> (cb === fn || cb.<span class="hljs-property">fn</span> === fn) &#123;<br>        cbs.<span class="hljs-title function_">splice</span>(i, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>  $emit(event) &#123;<br>    <span class="hljs-keyword">let</span> cbs = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_events</span>[event];<br>    <span class="hljs-keyword">if</span> (cbs) &#123;<br>      <span class="hljs-keyword">const</span> args = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>      cbs.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        args ? item.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args) : item.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="说说-Vue-的渲染过程-【原理题】"><a href="#说说-Vue-的渲染过程-【原理题】" class="headerlink" title="说说 Vue 的渲染过程 【原理题】"></a>说说 Vue 的渲染过程 【原理题】</h3><p>调用 compile 函数,生成 render 函数字符串 ,编译过程如下:</p>
<ul>
<li><p>parse 函数解析 template,生成 ast(抽象语法树)</p>
</li>
<li><p>optimize 函数优化静态节点 (标记不需要每次都更新的内容,diff 算法会直接跳过静态节点,从而减少比较的过程,优化了 patch 的性能)<br>generate 函数生成 render 函数字符串</p>
</li>
</ul>
<p>调用 new Watcher 函数,监听数据的变化,当数据发生变化时，Render 函数执行生成 vnode 对象<br>调用 patch 方法,对比新旧 vnode 对象,通过 DOM diff 算法,添加、修改、删除真正的 DOM 元素</p>
<img src="/img/vue-interview/004.png" style="zoom:60%;" />

<h3 id="聊聊-keep-alive-的实现原理和缓存策略-【原理题】"><a href="#聊聊-keep-alive-的实现原理和缓存策略-【原理题】" class="headerlink" title="聊聊 keep-alive 的实现原理和缓存策略 【原理题】"></a>聊聊 keep-alive 的实现原理和缓存策略 【原理题】</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 抽象组件属性 ,它在组件实例建立父子关系的时候会被忽略,发生在 initLifecycle 的过程中</span><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 被缓存组件</span><br>    <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 不被缓存组件</span><br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>], <span class="hljs-comment">// 指定缓存大小</span><br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 缓存</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []; <span class="hljs-comment">// 缓存的VNode的键</span><br>  &#125;,<br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<br>      <span class="hljs-comment">// 删除所有缓存</span><br>      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>);<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 监听缓存/不缓存组件</span><br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">matches</span>(val, name));<br>    &#125;);<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name));<br>    &#125;);<br>  &#125;,<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获取第一个子元素的 vnode</span><br>    <span class="hljs-keyword">const</span> slot = <span class="hljs-variable language_">this</span>.<span class="hljs-property">$slots</span>.<span class="hljs-property">default</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">vnode</span>: <span class="hljs-title class_">VNode</span> = <span class="hljs-title function_">getFirstComponentChild</span>(slot);<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">componentOptions</span>: ?<span class="hljs-title class_">VNodeComponentOptions</span> = vnode &amp;&amp; vnode.<span class="hljs-property">componentOptions</span>;<br>    <span class="hljs-keyword">if</span> (componentOptions) &#123;<br>      <span class="hljs-comment">// name不在inlcude中或者在exlude中 直接返回vnode</span><br>      <span class="hljs-comment">// check pattern</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: ?string = <span class="hljs-title function_">getComponentName</span>(componentOptions);<br>      <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-keyword">if</span> (<br>        <span class="hljs-comment">// not included</span><br>        (include &amp;&amp; (!name || !<span class="hljs-title function_">matches</span>(include, name))) ||<br>        <span class="hljs-comment">// excluded</span><br>        (exclude &amp;&amp; name &amp;&amp; <span class="hljs-title function_">matches</span>(exclude, name))<br>      ) &#123;<br>        <span class="hljs-keyword">return</span> vnode;<br>      &#125;<br>      <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-variable language_">this</span>;<br>      <span class="hljs-comment">// 获取键，优先获取组件的name字段，否则是组件的tag</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">key</span>: ?string =<br>        vnode.<span class="hljs-property">key</span> == <span class="hljs-literal">null</span><br>          ? <span class="hljs-comment">// same constructor may get registered as different local components</span><br>            <span class="hljs-comment">// so cid alone is not enough (#3269)</span><br>            componentOptions.<span class="hljs-property">Ctor</span>.<span class="hljs-property">cid</span> + (componentOptions.<span class="hljs-property">tag</span> ? <span class="hljs-string">`::<span class="hljs-subst">$&#123;componentOptions.tag&#125;</span>`</span> : <span class="hljs-string">&#x27;&#x27;</span>)<br>          : vnode.<span class="hljs-property">key</span>;<br>      <span class="hljs-comment">// 命中缓存,直接从缓存拿vnode 的组件实例,并且重新调整了 key 的顺序放在了最后一个</span><br>      <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>        vnode.<span class="hljs-property">componentInstance</span> = cache[key].<span class="hljs-property">componentInstance</span>;<br>        <span class="hljs-comment">// make current key freshest</span><br>        <span class="hljs-title function_">remove</span>(keys, key);<br>        keys.<span class="hljs-title function_">push</span>(key);<br>      &#125;<br>      <span class="hljs-comment">// 不命中缓存,把 vnode 设置进缓存</span><br>      <span class="hljs-keyword">else</span> &#123;<br>        cache[key] = vnode;<br>        keys.<span class="hljs-title function_">push</span>(key);<br>        <span class="hljs-comment">// prune oldest entry</span><br>        <span class="hljs-comment">// 如果配置了 max 并且缓存的长度超过了 this.max，还要从缓存中删除第一个</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span> &amp;&amp; keys.<span class="hljs-property">length</span> &gt; <span class="hljs-built_in">parseInt</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">max</span>)) &#123;<br>          <span class="hljs-title function_">pruneCacheEntry</span>(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_vnode</span>);<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// keepAlive标记位</span><br>      vnode.<span class="hljs-property">data</span>.<span class="hljs-property">keepAlive</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>]);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<p>获取 keep-alive 包裹着的第一个子组件对象及其组件名<br><u>根据设定的 include/exclude（如果有）进行条件匹配,决定是否缓存。不匹配,直接返回组件实例</u><br>根据组件 ID 和 tag 生成缓存 Key,并在缓存对象中查找是否已缓存过该组件实例。如果存在,直接取出缓存值并更新该 key 在 this.keys 中的位置(更新 key 的位置是实现 LRU 置换策略的关键)<br>在 this.cache 对象中存储该组件实例并保存 key 值,之后检查缓存的实例数量是否超过 max 的设置值,超过则根据 LRU 置换策略删除最近最久未使用的实例（即是下标为 0 的那个 key）<br>最后组件实例的 keepAlive 属性设置为 true,这个在渲染和执行被包裹组件的钩子函数会用到,这里不细说</p>
<p><strong>LRU 缓存淘汰算法</strong></p>
<p>LRU（Least recently used）算法根据数据的历史访问记录来进行淘汰数据,其核心思想是“如果数据最近被访问过,那么将来被访问的几率也更高”。</p>
<img src="/img/vue-interview/005.png" style="zoom:50%;" />

<p><strong>keep-alive 的实现正是用到了 LRU 策略,将最近访问的组件 push 到 this.keys 最后面,this.keys[0]也就是最久没被访问的组件,当缓存实例超过 max 设置值,删除 this.keys[0]</strong></p>
<h3 id="vm-set-实现原理是什么-【原理题】"><a href="#vm-set-实现原理是什么-【原理题】" class="headerlink" title="vm.$set()实现原理是什么? 【原理题】"></a><code>vm.$set()</code>实现原理是什么? 【原理题】</h3><p>受现代 JavaScript 的限制 (而且 Object.observe 也已经被废弃)，Vue 无法检测到对象属性的添加或删除。</p>
<p>由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。</p>
<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性。</p>
<p>那么 Vue 内部是如何解决对象新增属性不能响应的问题的呢?</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">target: <span class="hljs-built_in">Array</span> | <span class="hljs-built_in">Object</span>, key: any, val: any</span>): any &#123;<br>  <span class="hljs-comment">// target 为数组</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; <span class="hljs-title function_">isValidArrayIndex</span>(key)) &#123;<br>    <span class="hljs-comment">// 修改数组的长度, 避免索引&gt;数组长度导致splice()执行有误</span><br>    target.<span class="hljs-property">length</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(target.<span class="hljs-property">length</span>, key);<br>    <span class="hljs-comment">// 利用数组的splice变异方法触发响应式</span><br>    target.<span class="hljs-title function_">splice</span>(key, <span class="hljs-number">1</span>, val);<br>    <span class="hljs-keyword">return</span> val;<br>  &#125;<br>  <span class="hljs-comment">// target为对象, key在target或者target.prototype上 且必须不能在 Object.prototype 上,直接赋值</span><br>  <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> target &amp;&amp; !(key <span class="hljs-keyword">in</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)) &#123;<br>    target[key] = val;<br>    <span class="hljs-keyword">return</span> val;<br>  &#125;<br>  <span class="hljs-comment">// 以上都不成立, 即开始给target创建一个全新的属性</span><br>  <span class="hljs-comment">// 获取Observer实例</span><br>  <span class="hljs-keyword">const</span> ob = (<span class="hljs-attr">target</span>: any).<span class="hljs-property">__ob__</span>;<br>  <span class="hljs-comment">// target 本身就不是响应式数据, 直接赋值</span><br>  <span class="hljs-keyword">if</span> (!ob) &#123;<br>    target[key] = val;<br>    <span class="hljs-keyword">return</span> val;<br>  &#125;<br>  <span class="hljs-comment">// 进行响应式处理</span><br>  <span class="hljs-title function_">defineReactive</span>(ob.<span class="hljs-property">value</span>, key, val);<br>  ob.<span class="hljs-property">dep</span>.<span class="hljs-title function_">notify</span>();<br>  <span class="hljs-keyword">return</span> val;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果目标是数组,使用 vue 实现的变异方法 splice 实现响应式<br>如果目标是对象,判断属性存在,即为响应式,直接赋值<br>如果 target 本身就不是响应式,直接赋值<br>如果属性不是响应式,则调用 defineReactive 方法进行响应式处理</p>
<h3 id="Vue-use-方法的实现原理"><a href="#Vue-use-方法的实现原理" class="headerlink" title="Vue.use 方法的实现原理"></a>Vue.use 方法的实现原理</h3><p>Vue.use(plugin);</p>
<p>（1）参数</p>
<p><code>plugin</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-title class_">Object</span> | <span class="hljs-title class_">Function</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）用法</p>
<p>安装 <code>Vue.js</code> 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 <code>install</code> 方法。调用 <code>install</code> 方法时，会将 <code>Vue</code> 作为参数传入。<code>install</code> 方法被同一个插件多次调用时，插件也只会被安装一次。</p>
<p>关于如何上开发 Vue 插件，请看这篇文章，非常简单，不用两分钟就看完：<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s?__biz=MzU5NDM5MDg1Mw==&mid=2247483874&idx=1&sn=ac6c9cf2629068dec3e5da8aa3e29364&chksm=fe00bbc8c97732dea7be43e903a794229876d8ab6c9381f2388ba22886fba7776b7b34b7af86&token=1885963052&lang=zh_CN%23rd" title="https://mp.weixin.qq.com/s?__biz=MzU5NDM5MDg1Mw==&amp;mid=2247483874&amp;idx=1&amp;sn=ac6c9cf2629068dec3e5da8aa3e29364&amp;chksm=fe00bbc8c97732dea7be43e903a794229876d8ab6c9381f2388ba22886fba7776b7b34b7af86&amp;token=1885963052&amp;lang=zh_CN#rd">如何开发 Vue 插件？</a></p>
<p>（3）作用</p>
<p>注册插件，此时只需要调用 <code>install</code> 方法并将 <code>Vue</code> 作为参数传入即可。但在细节上有两部分逻辑要处理：</p>
<p>1、插件的类型，可以是 <code>install</code> 方法，也可以是一个包含 <code>install</code> 方法的对象。</p>
<p>2、插件只能被安装一次，保证插件列表中不能有重复的插件。</p>
<p>（4）实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Vue</span>.<span class="hljs-property">use</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">plugin</span>) &#123;<br>  <span class="hljs-keyword">const</span> installedPlugins = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> || (<span class="hljs-variable language_">this</span>.<span class="hljs-property">_installedPlugins</span> = []);<br>  <span class="hljs-keyword">if</span> (installedPlugins.<span class="hljs-title function_">indexOf</span>(plugin) &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>  &#125;<br>  <span class="hljs-comment">// 其他参数</span><br>  <span class="hljs-keyword">const</span> args = <span class="hljs-title function_">toArray</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span>);<br>  args.<span class="hljs-title function_">unshift</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin.<span class="hljs-property">install</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    plugin.<span class="hljs-property">install</span>.<span class="hljs-title function_">apply</span>(plugin, args);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> plugin === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    plugin.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, plugin, args);<br>  &#125;<br>  installedPlugins.<span class="hljs-title function_">push</span>(plugin);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>1、在 <code>Vue</code> 对象 上新增了 use 方法，并接收一个参数 plugin。</p>
<p>2、首先判断插件是不是已经别注册过，如果被注册过，则直接终止方法执行，此时只需要使用 indexOf 方法即可。</p>
<p>3、toArray 方法我们在就是将类数组转成真正的数组。使用 toArray 方法得到 arguments。除了第一个参数之外，剩余的所有参数将得到的列表赋值给 args，然后将 Vue 添加到 args 列表的最前面。这样做的目的是保证 install 方法被执行时第一个参数是 Vue，其余参数是注册插件时传入的参数。</p>
<p>4、由于 plugin 参数支持对象和函数类型，所以通过判断 plugin.install 和 plugin 哪个是函数，即可知用户使用哪种方式祖册的插件，然后执行用户编写的插件并将 args 作为参数传入。</p>
<p>5、最后，将插件添加到 installedPlugins 中，保证相同的插件不会反复被注册。</p>
<h3 id="Vuex-的原理"><a href="#Vuex-的原理" class="headerlink" title="Vuex 的原理"></a>Vuex 的原理</h3><p>vuex 本质是挂载一个名为 store 的 vm 组件在 Vue 的上下文环境</p>
<p>1.所以 this.$store 都是执行绑定的同一个 sotre</p>
<p>2.同时 state 因为在 vm 组件里面的 data, data 是使用<code>new Vue()</code>去创建一个 Vue 组件–所以具备响应式</p>
<h4 id="为什么一定要用-mutation-中修改-state"><a href="#为什么一定要用-mutation-中修改-state" class="headerlink" title="为什么一定要用 mutation 中修改 state"></a>为什么一定要用 mutation 中修改 state</h4><p>state 修改的源码–<code>mutation</code>操作是调用<code>_withCommit</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">_withCommit</span> (fn) &#123;<br>  <span class="hljs-comment">// 保存之前的提交状态</span><br>  <span class="hljs-keyword">const</span> committing = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_committing</span><br>  <span class="hljs-comment">// 进行本次提交，若不设置为true，直接修改state，strict模式下，Vuex将会产生非法修改state的警告</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_committing</span> = <span class="hljs-literal">true</span><br>  <span class="hljs-comment">// 执行state的修改操作</span><br>  <span class="hljs-title function_">fn</span>()<br>  <span class="hljs-comment">// 修改完成，还原本次修改之前的状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_committing</span> = committing<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="/2022/07/16/2022-07-16-vuex-theory">Vuex 核心原理</a></p>

    

    

    
    <div class="declare"> 
      <ul class="post-copyright">
        <li>
          <strong>本文作者：</strong>
          luckyship
        </li>
        <li>
          <strong>本文链接：</strong>
          <a href="https://luckyship.github.io/2022/07/16/2022-07-16-vue-theory/" title="Vue原理" target="_blank">https://luckyship.github.io/2022/07/16/2022-07-16-vue-theory/</a>
        </li>
        
        <li>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，均采用 <a href="https://github.com/JoeyBling/hexo-theme-yilia-plus/blob/master/LICENSE" rel="external nofollow" target="_blank">MIT</a> 许可协议。转载请注明出处！
        </li>
        
      </ul>
    </div>
    

  </div>
  <div class="article-info article-info-index">
    
    
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">javascript</a>
        		</li>
      		 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color4">vue</a>
        		</li>
      		
		</ul>
	</div>

    

    

    
    
<div class="share-btn share-icons tooltip-left">
  <div class="tooltip tooltip-east">
    <span class="tooltip-item">
      <a href="javascript:;" class="share-sns share-outer">
        <i class="icon icon-share"></i>
      </a>
    </span>
    <span class="tooltip-content">
      <div class="share-wrap">
        <div class="share-icons">
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="icon icon-weibo"></i>
          </a>
          <!-- <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="icon icon-weixin"></i>
          </a> -->
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="icon icon-qq"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="icon icon-douban"></i>
          </a>
          <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a>
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="icon icon-facebook"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="icon icon-twitter"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="icon icon-google"></i>
          </a>
        </div>
      </div>
    </span>
  </div>
</div>

<div class="page-modal wx-share js-wx-box">
    <a class="close js-modal-close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
     <!-- <img src="//pan.baidu.com/share/qrcode?url=https://luckyship.github.io/2022/07/16/2022-07-16-vue-theory/" alt="微信分享二维码"> -->
    </div>
</div>

<div class="mask js-mask"></div>

    
    <div class="clearfix"></div>
  </div>
  </div>
</article>


<nav id="article-nav">
  
    <a href="/2022/07/16/2022-07-16-vuex-theory/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          Vuex核心原理
        
      </div>
    </a>
  
  
    <a href="/2022/07/09/2022-07-09-angular-router/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">angular 路由</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>


<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>







  <section id="comments" style="margin:10px;padding:10px;background:#fff;">
    <div id="vcomment" class="comment"></div>
<!-- <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script> -->
<script src="/js/valine.js" async></script>
<script async>
  var notify = 'true' == true ? true : false;
  var verify = 'false' == true ? true : false;
  window.onload = function () {
    new Valine({
      el: '.comment',
      notify: notify,
      verify: verify,
      app_id: '3d3mgdb7guWJsXLE6mWY3Cyn-gzGzoHsz',
      app_key: 'fstd3ABXC89jc5VDSe6ANGV6',
      placeholder: 'Just go go',
      avatar: 'mm',
    });
  };
</script>

  </section>










          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020-2025 <a href="https://luckyship.github.io/" target="_blank">luckyship</a>
    	</div>
      	<div class="footer-right">
			
			
      		GitHub:<a href="https://github.com/JoeyBling/hexo-theme-yilia-plus" target="_blank">hexo-theme-yilia-plus</a> by Litten
      	</div>
    </div>
  </div>

  
	<script async src="/lib/busuanzi.pure.js"></script>
	
  
  
	
	<span id="busuanzi_container_site_pv" style="display:none">
		本站总访问量<span id="busuanzi_value_site_pv"></span>次
	        <span class="post-meta-divider" >|</span>
	</span>
  	<span id="busuanzi_container_site_uv" style='display:none'>
  		本站访客数<span id="busuanzi_value_site_uv"></span>人
  	</span>
  
</footer>

    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>




<!--  -->

<script>
  /* 标签页标题切换 */
  var originTitle = document.title;
  var titleTime;
  document.addEventListener("visibilitychange", function () {
    if (document.hidden) {
      document.title = "(つェ⊂) 我藏好了哦~ " + originTitle;
      clearTimeout(titleTime);
    } else {
      document.title = "(*´∇｀*) 被你发现啦~ " + originTitle;
      titleTime = setTimeout(function () {
        document.title = originTitle;
      }, 2000);
    }
  });
</script>



    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 50%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">搜索</a></li>
      
        
      
      <li style="width: 50%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">mongo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">ruby</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">dataTable</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">web</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">javascript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">network</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">base</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">rails</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">git</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">css</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">docker</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">kubernetes</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">centos</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">html</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">debian</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">ubuntu</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">nodejs</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">hexo</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">jquery</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">es6</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">npm</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">video</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">nginx</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">+ vue</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angular</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">sass</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">less</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">angualr</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">typescript</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">react</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">js</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">regexp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">vscode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">regex</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">review</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">tool</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">flutter</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">unicode</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">sql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">postgresql</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">vite</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">go</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia-plus根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
            <a q-attr="href:path|urlformat">
              <p class="search-content" q-show="matchContent.val">
                <span q-text="matchContent.pre"></span><span class="red" q-text="matchContent.val"></span><span q-text="matchContent.next"></span>
              </p>
            </a>
          </li>
        </ul>
    	</section>
    

    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
        
          
  	  		<div class="aboutme-wrap" id="aboutme">前端攻城狮<br>记录分享自己工作、学习中学到的知识</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>

  
  
<script
  type="text/javascript"
  src="/plugins/activate-power-mode/activate-power-mode.js"
></script>
<script>
  document.addEventListener('DOMContentLoaded',function(){
    POWERMODE.colorful = true; // make power mode colorful
    POWERMODE.shake = false; // turn off shake
    document.body.addEventListener('input', POWERMODE);
  });
</script>


  
  <!-- <script async type="text/javascript" size="90" alpha="0.2" zIndex="0" src="/plugins/ribbon.js/ribbon.min.js"></script> -->
  
  
  
</body>

</html>

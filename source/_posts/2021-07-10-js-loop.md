---
layout: post
title: js循环
excerpt: 'for循环 forEach for..of for..in的区别'
tags: [javascript, es6]
comments: true
date: 2020-10-23 16:14:11
---

## forEach

`forEach` 无法使用 `break` 或者 `continue` 跳出循环

优点：使用回调函数，形成特定的作用域，不会污染外部变量

<!-- more -->

### forEach 是不能阻塞的，默认是请求并行发起

来看一个例子

```js
const list = [1, 2, 3];
const square = num => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(num * num);
    }, 1000);
  });
};

function test() {
  list.forEach(async x => {
    const res = await square(x);
    console.log(res);
  });
}
test();
```

上面函数执行，虽然加了异步函数，但是执行结果是同时输出 `1、4、9`

如果想要能够异步执行，需要使用 `for` 循环

```js
async function test() {
  for (let i = 0; i < list.length; i++) {
    let x = list[i];
    const res = await square(x);
    console.log(res);
  }
}
```

或者 `for..of`

```js
async function test() {
  for (let x of list) {
    const res = await square(x);
    console.log(res);
  }
}
```

## for...of

es6 新增，用于迭代器，无法用于对象

```js
var arr = [1, 2, 3, 4, 5];
for (var i in arr) {
  console.log(i);
}
```

## for...in

一般为对象使用，不过 `for...in` 会把对象原型链的属性也遍历出来

```js
Object.prototype.bar = 10; // 修改Object.prototype
var obj = {
  name: 'wjy',
  age: 26,
  sex: 'female',
}; //定义一个object对象
var keys = []; //定义一个数组用来接受key
var values = []; //定义一个数组用来接受value
for (var key in obj) {
  console.log(key + ': ' + obj[key]); //取得value
}
```

> 如果不想遍历原型链的对象，可以使用 `Object.hasOwnProperty()` 来判断是否为自身属性

对象遍历我们一般使用， `Object.keys` 和 `Object.values()`

### 不用于数组的原因

- `for..in`的 key 值是字符串，而数组的 index 是数字，会造成误解
- 如果数组中或原型链中有可枚举的属性，遍历结果中会出现
- 数组是有序的，而对象的`key`是无序的

## for 循环

最基础的循环

### `for`循环和`forEach`的性能区别

在性能对比方面我们加入一个 `map` 迭代器，它与 `filter` 一样都是生成新数组。我们对比 `for` `forEach` `map` 的性能在浏览器环境中都是什么样的：

**性能比较**：for > forEach > map 在 chrome 62 和 Node.js v9.1.0 环境下：`for` 循环比 `forEach` 快 1 倍，`forEach` 比 `map` 快 20%左右。

**原因分析**`for`：for 循环没有额外的函数调用栈和上下文，所以它的实现最为简单。`forEach`：对于 forEach 来说，它的函数签名中包含了参数和上下文，所以性能会低于 `for` 循环。`map`：`map` 最慢的原因是因为 `map` 会返回一个新的数组，数组的创建和赋值会导致分配内存空间，因此会带来较大的性能开销。

如果将`map`嵌套在一个循环中，便会带来更多不必要的内存消耗。当大家使用迭代器遍历一个数组时，如果不需要返回一个新数组却使用 `map` 是违背设计初衷的。在我前端合作开发时见过很多人只是为了遍历数组而用 `map` 的：

---
layout: post
title: åŸºäºvue2å®ç°ä¸€ä¸ªç®€å•çš„minVue
tags: [vue, javascript]
categories: review
comments: true
date: 2021-08-19 10:15:02
---

åŸºäº vue2 å®ç°ä¸€ä¸ªç®€å•çš„å¯ä»¥åŒå‘ç»‘å®šçš„ minVue

1. æ¨¡ç‰ˆæ’å€¼
2. æ•°æ®åŠ«æŒï¼Œå˜é‡æ›´æ–°
3. å¤šä¾èµ–æ›´æ–°
4. å®ç° vue æŒ‡ä»¤ï¼Œ v-textï¼Œv-modelï¼Œv-click

<!-- more -->

## æ¨¡ç‰ˆæ’å€¼

é¦–å…ˆ å®ç°æ¨¡ç‰ˆç¼–è¯‘çš„åŠŸèƒ½
å¯¹äº vue çš„ optionï¼Œæˆ‘ä»¬åªä¼ å…¥ el å’Œ dataï¼Œå…¶ä»–çš„å±æ€§æš‚æ—¶æˆ‘ä»¬ä¸åšå¤„ç†ï¼Œè®© html ä¸­çš„æ–‡æœ¬ä¼ å€¼å¯ä»¥è¢« data ä¸­çš„æ•°æ®æ›¿æ¢

```html
<body>
  <div id="app">
    <p>{{msg}}</p>
    <p>{{count}}</p>
  </div>
</body>
```

```js
new MinVue({
  el: "#app",
  data: {
    msg: "hello,mini vue.js",
    count: 666,
  },
});
```

æ­¤å¤„æˆ‘ä»¬åªè€ƒè™‘å…ƒç´ ä¸­åªæœ‰ä¸€ä¸ªæ–‡æœ¬æ’å€¼çš„æƒ…å†µ

```js
class MinVue {
  constructor(options) {
    this.$el = options.el;
    this.$data = options.data;

    // ç¼–è¯‘æ¨¡æ¿
    new Compile(this);
  }
}

class Compile {
  constructor(object) {
    this.$el = object.$el;
    this.$data = object.$data;
    this.compile(document.querySelector(this.$el));
  }

  compile(el) {
    const childNodes = el.childNodes;

    Array.from(childNodes).forEach((node) => {
      if (this.isTextNode(node)) {
        this.compileTextNode(node);
      } else if (this.isElementNode(node)) {
        this.compileElement(node);
      }

      if (node.childNodes && node.childNodes.length) this.compile(node);
    });
  }

  isTextNode(node) {
    return node.nodeType === 3;
  }

  isElementNode(node) {
    return node.nodeType === 1;
  }

  compileTextNode(node) {
    // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
    // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
    const reg = /\{\{(.+?)\}\}/g;
    const text = node.textContent;

    if (reg.test(text)) {
      // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
      let key = RegExp.$1.trim();
      node.textContent = text.replace(reg, this.$data[key]);
    }
  }

  compileElement(node) {}
}
```

è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†æ–‡æœ¬æ’å…¥çš„åŠŸèƒ½ï¼Œæˆ‘ä»¬çœ‹ä¸€ä¸‹å®Œæ•´ä»£ç 

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{msg}}</p>
      <p>{{count}}</p>
    </div>
  </body>

  <script>
    class MinVue {
      constructor(options) {
        this.$el = options.el;
        this.$data = options.data;

        // ç¼–è¯‘æ¨¡æ¿
        new Compile(this);
      }
    }

    class Compile {
      constructor(object) {
        this.$el = object.$el;
        this.$data = object.$data;
        this.compile(document.querySelector(this.$el));
      }

      compile(el) {
        const childNodes = el.childNodes;

        Array.from(childNodes).forEach((node) => {
          if (this.isTextNode(node)) {
            this.compileTextNode(node);
          } else if (this.isElementNode(node)) {
            this.compileElement(node);
          }

          if (node.childNodes && node.childNodes.length) this.compile(node);
        });
      }

      isTextNode(node) {
        return node.nodeType === 3;
      }

      isElementNode(node) {
        return node.nodeType === 1;
      }

      compileTextNode(node) {
        // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
        // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
        const reg = /\{\{(.+?)\}\}/g;
        const text = node.textContent;

        if (reg.test(text)) {
          // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
          let key = RegExp.$1.trim();
          node.textContent = text.replace(reg, this.$data[key]);
        }
      }

      compileElement(node) {}
    }

    new MinVue({
      el: "#app",
      data: {
        msg: "hello,mini vue.js",
        count: 666,
      },
    });
  </script>
</html>
```

## æ•°æ®åŠ«æŒï¼Œå˜é‡æ›´æ–°

æˆ‘ä»¬éƒ½çŸ¥é“ vue2 æ˜¯é€šè¿‡ Object.defineProperty æ¥å®ç°æ•°æ®åŠ«æŒçš„ï¼Œæˆ‘ä»¬ä¹Ÿæ¥å®ç°ä¸€ä¸ªç®€å•çš„ observer

```js
class MinVue {
  constructor(options) {
    this.$el = options.el;
    this.$data = options.data;

    new Observer(this.$data);

    // ç¼–è¯‘æ¨¡æ¿
    new Compile(this);
  }
}

class Observer {
  constructor(data) {
    this.data = data;
    this.walk(data);
  }

  walk(data) {
    Object.keys(data).forEach((key) => {
      this.defineReactive(data, key, data[key]);
    });
  }

  defineReactive(obj, key, value) {
    Object.defineProperty(obj, key, {
      get() {
        return value;
      },
      set(newValue) {
        if (newValue !== value) {
          value = newValue;
        }
      },
    });
  }
}
```

è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†æ•°æ®åŠ«æŒï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æƒ³ä¸€ä¸‹ï¼Œå¦‚ä½•å»å®ç°æ•°æ®ä»£ç†çš„åŠŸèƒ½

é¦–å…ˆæˆ‘ä»¬æƒ³è¦åœ¨å“ªé‡Œå»åšä¾èµ–æ”¶é›†æ¯”è¾ƒåˆé€‚ï¼Œé‚£å°±æ˜¯åœ¨`compileTextNode`æ–¹æ³•é‡Œé¢ï¼Œä»–ä¼šè®¿é—®æ‰€æœ‰çš„æ–‡æœ¬æ’å€¼çš„å†…å®¹ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨è¿™é‡Œè¿›è¡Œä¾èµ–æ”¶é›†ã€‚

```js
dep = null;

class Observer {
  constructor(data) {
    this.data = data;
    this.walk(data);
  }

  walk(data) {
    Object.keys(data).forEach((key) => {
      this.defineReactive(data, key, data[key]);
    });
  }

  defineReactive(obj, key, value) {
    let updateCallBack = () => {};
    Object.defineProperty(obj, key, {
      get() {
        if (dep) {
          updateCallBack = dep;
        }
        return value;
      },
      set(newValue) {
        if (newValue !== value) {
          value = newValue;
          updateCallBack && updateCallBack(newValue);
        }
      },
    });
  }
}

compileTextNode(node) {
  // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
  // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
  const reg = /\{\{(.+?)\}\}/g;
  const text = node.textContent;

  if (reg.test(text)) {
    // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
    let key = RegExp.$1.trim();

    node.textContent = text.replace(reg, this.$data[key]);

    // ç»‘å®šæ•°æ®æ›´æ–°
    dep = (newValue) => {
      console.log(newValue);
      node.textContent = newValue;
    };

    // è§¦å‘getæ–¹æ³•
    console.log(this.$data[key]);
    dep = null;
  }
}
```

æˆ‘ä»¬å…ˆä½¿ç”¨ä¸€ä¸ªå…¨å±€å˜é‡ `dep`ï¼Œç”¨æ¥å­˜å‚¨ä¾èµ–æ”¶é›†çš„å›è°ƒå‡½æ•°ï¼Œå½“æ•°æ®å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨è¿™ä¸ªå›è°ƒå‡½æ•°æ¥æ›´æ–°è§†å›¾ï¼Œæˆ‘ä»¬åœ¨`defineReactive`æ–¹æ³•é‡Œé¢è¿›è¡Œä¾èµ–æ”¶é›†ï¼Œå½“æ•°æ®å‘ç”Ÿæ”¹å˜æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨`updateCallBack`å›è°ƒå‡½æ•°æ¥æ›´æ–°è§†å›¾ã€‚

æˆ‘ä»¬æ­¤å¤„å…ˆè€ƒè™‘ä¾èµ–åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬`dep`åªæ˜¯ä¸€ä¸ªå˜é‡ï¼Œåç»­æˆ‘ä»¬ä¼šè€ƒè™‘å¤šä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼Œæ‰€ä»¥æˆ‘ä»¬`dep`æ˜¯ä¸€ä¸ªæ•°ç»„æˆ–ç±»ï¼Œç”¨æ¥å­˜å‚¨å¤šä¸ªå›è°ƒå‡½æ•°ã€‚

å®Œæ•´ä»£ç 

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{msg}}</p>
      <p>{{count}}</p>
      <button type="button" onclick="increase()">add+</button>
    </div>
  </body>

  <script>
    function increase() {
      minVue.$data.count = minVue.$data.count + 1;
    }

    class MinVue {
      constructor(options) {
        this.$el = options.el;
        this.$data = options.data;

        new Observer(this.$data);

        // ç¼–è¯‘æ¨¡æ¿
        new Compile(this);
      }
    }

    dep = null;

    class Observer {
      constructor(data) {
        this.data = data;
        this.walk(data);
      }

      walk(data) {
        Object.keys(data).forEach((key) => {
          this.defineReactive(data, key, data[key]);
        });
      }

      defineReactive(obj, key, value) {
        let updateCallBack = () => {};
        Object.defineProperty(obj, key, {
          get() {
            if (dep) {
              updateCallBack = dep;
            }
            return value;
          },
          set(newValue) {
            if (newValue !== value) {
              value = newValue;
              updateCallBack && updateCallBack(newValue);
            }
          },
        });
      }
    }

    class Compile {
      constructor(object) {
        this.$el = object.$el;
        this.$data = object.$data;
        this.compile(document.querySelector(this.$el));
      }

      compile(el) {
        const childNodes = el.childNodes;

        Array.from(childNodes).forEach((node) => {
          if (this.isTextNode(node)) {
            this.compileTextNode(node);
          } else if (this.isElementNode(node)) {
            this.compileElement(node);
          }

          if (node.childNodes && node.childNodes.length) this.compile(node);
        });
      }

      isTextNode(node) {
        return node.nodeType === 3;
      }

      isElementNode(node) {
        return node.nodeType === 1;
      }

      compileTextNode(node) {
        // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
        // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
        const reg = /\{\{(.+?)\}\}/g;
        const text = node.textContent;

        if (reg.test(text)) {
          // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
          let key = RegExp.$1.trim();

          node.textContent = text.replace(reg, this.$data[key]);

          // ç»‘å®šæ•°æ®æ›´æ–°
          dep = (newValue) => {
            console.log(newValue);
            node.textContent = newValue;
          };
          // è§¦å‘getæ–¹æ³•
          console.log(this.$data[key]);
          dep = null;
        }
      }

      compileElement(node) {}
    }
    let minVue = new MinVue({
      el: "#app",
      data: {
        msg: "hello,mini vue.js",
        count: 666,
      },
    });
  </script>
</html>
```

## å¤šä¸ªä¾èµ–çš„æƒ…å†µ

å¦‚æœæˆ‘ä»¬æœ‰å¤šä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼Œæ¯”å¦‚æœ‰ 2 ä¸ªä½¿ç”¨ count çš„æƒ…å†µï¼Œå°±æ— æ³•ç”¨ä¸€ä¸ª dep å»å®ç°äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬æ­¤å¤„å°† dep æ”¹é€ æˆæ³ªç±»ï¼Œå¹¶æŠŠæ›´æ–°å‡½æ•°å†™åˆ° Watch ç±»é‡Œé¢

```html
<p>{{count}}</p>
<p>{{count}}</p>
```

```js
class Dep {
  constructor() {
    this.watchers = [];
  }

  addWatcher(watcher) {
    this.watchers.push(watcher);
  }

  notify() {
    this.watchers.forEach((watcher) => watcher.update());
  }
}

class Watcher {
  constructor($data, key, cb) {
    Dep.target = this;
    this.key = key;
    this.cb = cb;
    // æ­¤å¤„è°ƒç”¨getæ–¹æ³•ï¼Œè§¦å‘getæ–¹æ³•çš„definePropertyçš„getæ–¹æ³•ï¼Œå°†watcheræ·»åŠ åˆ°depä¸­
    this.$data = $data;
    this._old = $data[key];
    Dep.target = null;
  }

  update() {
    const newValue = this.$data[this.key];
    this.cb(newValue);
    this._old = newValue;
  }
}
```

`compileTextNode`ä¸­æˆ‘ä»¬æ”¹é€ ä¸€ä¸‹ï¼Œä½¿ç”¨ Watcher æ–¹æ³•å»æ›´æ–°

```js
compileTextNode(node) {
  // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
  // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
  const reg = /\{\{(.+?)\}\}/g;
  const text = node.textContent;

  if (reg.test(text)) {
    // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
    let key = RegExp.$1.trim();

    node.textContent = text.replace(reg, this.$data[key]);

    // ç»‘å®šæ•°æ®æ›´æ–°
    new Watcher(this.$data, key, (newValue) => {
      node.textContent = newValue;
    });
  }
}
```

ç„¶åå†æŠŠ Observer ä¸­çš„ä»£ç æ›´æ–°ä¸º`Dep`ç±»çš„æ–¹æ³•

```js
class Observer {
  constructor(data) {
    this.data = data;
    this.walk(data);
  }

  walk(data) {
    Object.keys(data).forEach((key) => {
      this.defineReactive(data, key, data[key]);
    });
  }

  defineReactive(obj, key, value) {
    const dep = new Dep();
    Object.defineProperty(obj, key, {
      get() {
        if (Dep.target) {
          dep.addWatcher(Dep.target);
        }
        return value;
      },
      set(newValue) {
        if (newValue !== value) {
          value = newValue;
          dep.notify();
        }
      },
    });
  }
}
```

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{msg}}</p>
      <p>{{count}}</p>
      <p>{{count}}</p>
      <button type="button" onclick="increase()">add+</button>
    </div>
  </body>

  <script>
    function increase() {
      minVue.$data.count = minVue.$data.count + 1;
    }

    class MinVue {
      constructor(options) {
        this.$el = options.el;
        this.$data = options.data;

        new Observer(this.$data);

        // ç¼–è¯‘æ¨¡æ¿
        new Compile(this);
      }
    }

    class Observer {
      constructor(data) {
        this.data = data;
        this.walk(data);
      }

      walk(data) {
        Object.keys(data).forEach((key) => {
          this.defineReactive(data, key, data[key]);
        });
      }

      defineReactive(obj, key, value) {
        const dep = new Dep();
        Object.defineProperty(obj, key, {
          get() {
            if (Dep.target) {
              dep.addWatcher(Dep.target);
            }
            return value;
          },
          set(newValue) {
            if (newValue !== value) {
              value = newValue;
              dep.notify();
            }
          },
        });
      }
    }

    class Dep {
      constructor() {
        this.watchers = [];
      }

      addWatcher(watcher) {
        this.watchers.push(watcher);
      }

      notify() {
        this.watchers.forEach((watcher) => watcher.update());
      }
    }

    class Watcher {
      constructor($data, key, cb) {
        Dep.target = this;
        this.key = key;
        this.cb = cb;
        // æ­¤å¤„è°ƒç”¨getæ–¹æ³•ï¼Œè§¦å‘getæ–¹æ³•çš„definePropertyçš„getæ–¹æ³•ï¼Œå°†watcheræ·»åŠ åˆ°depä¸­
        this.$data = $data;
        this._old = $data[key];
        Dep.target = null;
      }

      update() {
        const newValue = this.$data[this.key];
        this.cb(newValue);
        this._old = newValue;
      }
    }

    class Compile {
      constructor(object) {
        this.$el = object.$el;
        this.$data = object.$data;
        this.compile(document.querySelector(this.$el));
      }

      compile(el) {
        const childNodes = el.childNodes;

        Array.from(childNodes).forEach((node) => {
          if (this.isTextNode(node)) {
            this.compileTextNode(node);
          } else if (this.isElementNode(node)) {
            this.compileElement(node);
          }

          if (node.childNodes && node.childNodes.length) this.compile(node);
        });
      }

      isTextNode(node) {
        return node.nodeType === 3;
      }

      isElementNode(node) {
        return node.nodeType === 1;
      }

      compileTextNode(node) {
        // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
        // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
        const reg = /\{\{(.+?)\}\}/g;
        const text = node.textContent;

        if (reg.test(text)) {
          // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
          let key = RegExp.$1.trim();

          node.textContent = text.replace(reg, this.$data[key]);

          // ç»‘å®šæ•°æ®æ›´æ–°
          new Watcher(this.$data, key, (newValue) => {
            node.textContent = newValue;
          });
        }
      }

      compileElement(node) {}
    }
    let minVue = new MinVue({
      el: "#app",
      data: {
        msg: "hello,mini vue.js",
        count: 666,
      },
    });
  </script>
</html>
```

è¿™æ ·æˆ‘ä»¬å°±å®ç°äº†å¤šä¸ªä¾èµ–æ›´æ–°çš„æƒ…å†µ

## å®ç° vue æŒ‡ä»¤

### å®ç° v-text

æˆ‘ä»¬ä¹‹å‰å¯¹é text èŠ‚ç‚¹æ²¡æœ‰ä½œç‰¹æ®Šå¤„ç†ï¼Œç°åœ¨å¤„ç†ä¸€ä¸‹ï¼Œå®ç° v-text çš„åŠŸèƒ½

```js
compileElement(node) {
  const attrs = node.attributes;

  if (attrs.length) {
    Array.from(attrs).forEach((attr) => {
      if (this.isDirective(attr.name)) {
        // æ ¹æ®v-æ¥æˆªå–ä¸€ä¸‹åç¼€å±æ€§å
        let attrName = attr.name.indexOf(":") > -1 ? attr.name.substr(5) : attr.name.substr(2);
        let key = attr.value;

        this.update(node, attrName, key, this.$data[key]);
      }
    });
  }
}

isDirective(dir) {
  return dir.startsWith("v-");
}

update(node, attrName, key, value) {
  if (attrName === "text") {
    node.textContent = value;

    // è¿™é‡Œä¸å†textnodeå¤„ç†ï¼Œ æ‰€ä»¥æˆ‘ä»¬è¦è¿˜æ˜¯è¦åšWatchçš„æ›´æ–°
    new Watcher(this.$data, key, (newValue) => {
      node.textContent = newValue;
    });
  }
}
```

åœ¨ html ä¸­è¯•ä¸€ä¸‹ï¼Œèƒ½å¤Ÿæ­£å¸¸å±•ç¤º ğŸ˜Š

```html
<p v-text="msg"></p>
```

### v-model

ç„¶åæˆ‘ä»¬å®ç° v-model

```js
update(node, attrName, key, value) {
  if (attrName === "text") {
    node.textContent = value;
    new Watcher(this.$data, key, (newValue) => {
      node.textContent = newValue;
    });
  }

  if (attrName === "model") {
    node.value = value;
    new Watcher(this.$data, key, (newValue) => {
      node.value = newValue;
    });

    node.addEventListener("input", (e) => {
      this.$data[key] = node.value;
    });
  }
}
```

```html
<input v-model="msg" />
```

å¯ä»¥æ­£å¸¸ä½¿ç”¨

### v-click

æœ€åæˆ‘ä»¬å®ç°ä¸€ä¸‹ v-click æŒ‡ä»¤

```js
class Compile {
  constructor(object) {
    this.$el = object.$el;
    this.$data = object.$data;
    this.methods = object.methods; // æ³¨å†Œ
    this.compile(document.querySelector(this.$el));
  }

  update(node, attrName, key, value) {
    if (attrName === "text") {
      node.textContent = value;
      new Watcher(this.$data, key, (newValue) => {
        node.textContent = newValue;
      });
    }

    if (attrName === "model") {
      node.value = value;
      new Watcher(this.$data, key, (newValue) => {
        node.value = newValue;
      });

      node.addEventListener("input", (e) => {
        this.$data[key] = node.value;
      });
    }

    if (attrName === "click") {
      node.addEventListener(attrName, this.methods[key].bind(this.$data));
    }
  }
}
```

```js
class MinVue {
  constructor(options) {
    this.$el = options.el;
    this.$data = options.data;
    this.methods = options.methods;

    new Observer(this.$data);

    // ç¼–è¯‘æ¨¡æ¿
    new Compile(this);
  }
}

let minVue = new MinVue({
  el: "#app",
  data: {
    msg: "hello,mini vue.js",
    count: 666,
  },
  methods: {
    increase() {
      this.count = this.count + 1;
    },
  },
});
```

```html
<button type="button" v-click="increase">vue add+</button>
```

åˆ°è¿™é‡Œï¼Œæˆ‘ä»¬å°±å®ç°äº†ä¸€ä¸ªç®€å•çš„ minVue äº†ï¼Œä¸€èµ·æ¥çœ‹ä¸‹æœ€åçš„å®Œæ•´ä»£ç å§

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div id="app">
      <p>{{msg}}</p>
      <p>{{count}}</p>
      <p>{{count}}</p>
      <p v-text="msg"></p>
      <input v-model="msg" />
      <button type="button" onclick="increase()">add+</button>
      <button type="button" v-click="increase">vue add+</button>
    </div>
  </body>

  <script>
    function increase() {
      minVue.$data.count = minVue.$data.count + 1;
    }

    class MinVue {
      constructor(options) {
        this.$el = options.el;
        this.$data = options.data;
        this.methods = options.methods;

        new Observer(this.$data);

        // ç¼–è¯‘æ¨¡æ¿
        new Compile(this);
      }
    }

    class Observer {
      constructor(data) {
        this.data = data;
        this.walk(data);
      }

      walk(data) {
        Object.keys(data).forEach((key) => {
          this.defineReactive(data, key, data[key]);
        });
      }

      defineReactive(obj, key, value) {
        const dep = new Dep();
        Object.defineProperty(obj, key, {
          get() {
            if (Dep.target) {
              dep.addWatcher(Dep.target);
            }
            return value;
          },
          set(newValue) {
            if (newValue !== value) {
              value = newValue;
              dep.notify();
            }
          },
        });
      }
    }

    class Dep {
      constructor() {
        this.watchers = [];
      }

      addWatcher(watcher) {
        this.watchers.push(watcher);
      }

      notify() {
        this.watchers.forEach((watcher) => watcher.update());
      }
    }

    class Watcher {
      constructor($data, key, cb) {
        Dep.target = this;
        this.key = key;
        this.cb = cb;
        // æ­¤å¤„è°ƒç”¨getæ–¹æ³•ï¼Œè§¦å‘getæ–¹æ³•çš„definePropertyçš„getæ–¹æ³•ï¼Œå°†watcheræ·»åŠ åˆ°depä¸­
        this.$data = $data;
        this._old = $data[key];
        Dep.target = null;
      }

      update() {
        const newValue = this.$data[this.key];
        this.cb(newValue);
        this._old = newValue;
      }
    }

    class Compile {
      constructor(object) {
        this.$el = object.$el;
        this.$data = object.$data;
        this.methods = object.methods;
        this.compile(document.querySelector(this.$el));
      }

      compile(el) {
        const childNodes = el.childNodes;

        Array.from(childNodes).forEach((node) => {
          if (this.isTextNode(node)) {
            this.compileTextNode(node);
          } else if (this.isElementNode(node)) {
            this.compileElement(node);
          }

          if (node.childNodes && node.childNodes.length) this.compile(node);
        });
      }

      isTextNode(node) {
        return node.nodeType === 3;
      }

      isElementNode(node) {
        return node.nodeType === 1;
      }

      compileTextNode(node) {
        // .+?æ­£åˆ™æ‡’æƒ°åŒ¹é…, éè´ªå©ªåŒ¹é…, åŒ¹é…èŠ±æ‹¬å·é‡Œé¢çš„å†…å®¹
        // åªåŒ¹é…ç¬¬ä¸€ä¸ªèŠ±æ‹¬å·ï¼Œåç»­çš„ä¸åŒ¹é…ï¼ˆåªè€ƒè™‘å…ƒç´ é‡Œé¢åªæœ‰ä¸€ä¸ªæ¨¡ç‰ˆå­—ç¬¦ä¸²çš„æƒ…å†µï¼‰
        const reg = /\{\{(.+?)\}\}/g;
        const text = node.textContent;

        if (reg.test(text)) {
          // å¦‚æœåŒ¹é…æˆåŠŸ, è·å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„å†…å®¹
          let key = RegExp.$1.trim();

          node.textContent = text.replace(reg, this.$data[key]);

          // ç»‘å®šæ•°æ®æ›´æ–°
          new Watcher(this.$data, key, (newValue) => {
            node.textContent = newValue;
          });
        }
      }

      compileElement(node) {
        const attrs = node.attributes;

        if (attrs.length) {
          Array.from(attrs).forEach((attr) => {
            if (this.isDirective(attr.name)) {
              // æ ¹æ®v-æ¥æˆªå–ä¸€ä¸‹åç¼€å±æ€§å
              let attrName = attr.name.indexOf(":") > -1 ? attr.name.substr(5) : attr.name.substr(2);
              let key = attr.value;

              this.update(node, attrName, key, this.$data[key]);
            }
          });
        }
      }

      isDirective(dir) {
        return dir.startsWith("v-");
      }

      update(node, attrName, key, value) {
        if (attrName === "text") {
          node.textContent = value;
          new Watcher(this.$data, key, (newValue) => {
            node.textContent = newValue;
          });
        }

        if (attrName === "model") {
          node.value = value;
          new Watcher(this.$data, key, (newValue) => {
            node.value = newValue;
          });

          node.addEventListener("input", (e) => {
            this.$data[key] = node.value;
          });
        }

        if (attrName === "click") {
          node.addEventListener(attrName, this.methods[key].bind(this.$data));
        }
      }
    }
    let minVue = new MinVue({
      el: "#app",
      data: {
        msg: "hello,mini vue.js",
        count: 666,
      },
      methods: {
        increase() {
          this.count = this.count + 1;
        },
      },
    });
  </script>
</html>
```
